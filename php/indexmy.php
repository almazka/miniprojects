echo 'Hello World'; 
<?='Hello, World!'?> - то же самое, но сокращенный вариант echo (работает, если включен short open tag) Тут перед закрытием не надо тчк с зпт 

echo '<h1>Hello, World!</h1>';  Идентичный результат, что и:
<h1><?php echo 'Hello World';?></h1>
или echo '<h1>', 'Hello, World!', '</h1>'; 

print 'Hello, World!'; // почти то же, что и echo

$peremen_2; // так пишутся переменные, должна начинаться только либо с буквы, либо с _, но не с цифр, цифры внутри можно. Чувствительна к регистру.

$per = 5; // присваивается переменной значение 5
$sau = 'JOhn'; // присваивается переменной значение строковое (в кавычках писать)
$per = 28; // присваивается переменной значение 28? если до этого ее же используем, то прошлое значение ЗАМЕНЯЕТСЯ
$perper = 2 + 2; // присваивается переменной результат сложения - 4 присвоит
echo $per; // выведет значение переменной per
$pser = $col; // присваивает переменной pser значение переменной col
unset($col); // удаляет переменную

ТИПЫ ДАННЫХ
boolean // это да/нетошный тип. Имеет значение true - false Эти надписи регистронезависимы.
$lol = true; // присваиваем переменной lol значение true
echo $lol; // если выводить через echo, он выводит когда true - 1, когда false - пустоту

integer // это числовой тип
$orft = 1234; //присвоили переменной десятичное число
$ot = -123; //присвоили переменной отрицательное число
$oret = 0123; //присвоили переменной восьмеричное число
$ogdt = 0x1A; //присвоили переменной шестнадцатеричное число

float // тип с плавающей точкой

О кавычках - Разница есть между одинарными и двойными
echo "Hello, $col" // в двойных можно писать сочетание с переменными и не надо никаких плюсов писать там
echo "Hello, \n$ctol" // в двойных можно писать знаки табуляции (браузер их не видит, т-ко для кода)        
echo "Hello, \"hellops\" $ctol" // кавычки внутри кавычек отобразятся с слэшами
в двойных кавычках работают спецсимволы.
спец-символы: 
\n  новая строка
\r  возврат строки
\t  горизонтальная табуляция
\\  обратная косая черта
\$  знак доллара
\"  двойная кавычка 

В одинарных ковычках выводится все как есть, не распознаются эти спец-символы и переменные

heredoc // аналог тега pre, когда много надо писать и чтобы не громоздить кучу слешей и кавычек. Выводит не как есть, теги заменяет
Конструкция label
<<<label // вместо label любое имя, главное, чтоб после имени не было ничего - даже пробела!
        <p>Меня зовут "лялка"</p>
        <p>Мне $age лет</p>
label; // тут тоже ничего не должно быть после! И до него тоже НЕЛЬЗЯ! 
nowdoc // то же, что хередок, но пишется в кавычках одинарных первый заголовок, разница в том, что переменные тогда не подставляются и теги, все выводится так как написано
<<<'lol'
        <p>Меня зовут "лялка"</p>
        <p>Мне $age лет</p>
lol;

null // тип данных типа ноль. Если переменной нет - то она null, если ей присвоено null, то она null, если она удаленная, то тоже null

echo "He drink some ${beer}s"; // экранирование переменной
echo "He frend some {$beer}s"; // экранирование переменной, чтоб она не смешивалась с текстом и была распознана

$srt = 'Yellow, World!';
$first = $srt{0};// выборка первого символа - Y из строки по его номеру (считает с нуля)
$first = $srt[0]; // то же самое, см выше

чтоб выбрать последний символ, надо высчитать сперва кол-во их
$len = strlen($srt); // strlen подсчитывает количество символов
$pos = $len - 1; // принимаем переменную с вычетом одного, т.к. считает с нуля
$last = $srt{$pos}; 
сокращенно $dlin = $len{strlen($len) - 1}; // сокращенно вычислить последний символ
        
ОПЕРАТОРЫ
+  сумма
-  разность
*  произведение
/  частное
%  целочисленный остаток
.  оператор присоединения
?: выбиральщик тру $a=условие ? true : false ; То же самое что if () { .. } else {.. }

$a += $b; // работает со всеми операторами. То же, что и $a = $a + $b. Это часто надо когда надо переменную сложить с другой и результат добавить в эту же переменную

> если используются эти арифметические операторы, то все, с чем они используются приведется к числу
> если использовать со строковыми переменными, то они будут приведены к 0, если в них нет цифр. Или берет эти цифры, те, что в середине не берет

$eru .="World";// точка - оператор присоединения. К переменной eru, в которой уже что-то есть, добавляем слово world

// немного встроенных функций
pow(base, exp); // возвращает степень числа
isset(imya); // сообщает, есть ли такая переменная. True или false дает.
empty(imya); // сообщает true если переменная существует и она пустая. Пустая - это если ей присвоен ноль, строка ноль, значение false или пустота в кавычках
gettype($imya); // возвращает тип переменной. float возвращает словом double
settype($eru, "integer") // конвертирует тип, присваивает тот тип, что в кавычках укажешь, только если совпадает. Числу - integer, он тога отсекает число и убирает буквы из значения этой переменной
$a = '10peas';
echo (integer)$a; // временная конвертация типа, т.е. выводить он будет только число из значения этой переменной
is_null($item) //встроенная функция is_... означающая null true той переменной, имя которой в скобках, можно is_ этот использовать со всеми остальными типами для экономия места

== сравнение
$a == $b // отправляет TRUE если $a равно $b. Тут он тип притягивает за уши
$a === $b // если и по типам совпадает, тогда TRUE
$a != $b // TRUE если $a не равно $b
$a !== $b // TRUE если $a не равно $b и по типу тоже
$a > $b // TRUE если $a больше $b
$a < $b // TRUE если $a меньше $b
$a >= $b // TRUE если $a больше или равно $b
$a <= $b // TRUE если $a меньше или равно $b
   
НЕ ПУТАТЬ = и == !!!!
  
Логческие операторы
$a and $b // дает TRUE если и $a, и $b TRUE
$a or $b // дает TRUE если или $a, или $b TRUE
$a && $b // дает TRUE если и $a, и $b TRUE - но приоритет выше
$a || $b // дает TRUE если или $a, или $b TRUE - но приоритет выше
!$a // дает TRUE если $a не TRUE


Условия
$shop = true;
if($shop){ // переводится как если то, что в скобках - тру, тогда...
echo 'Иду';
} // скобки фигурные ставить если много условий к if более одного, без - если одно
echo 'Не иду';

TRUE и FALSE в PHP
Рассматривает как FALSE
 целое 0
 0.0
 пусая строка и строка 0
 пустой массив
 установленный null


else - тоже фгурные скобки надо, если несколько
echo ($a==1) ? 'One' : 'Zero'; // сокращенная запись if-else. Пишется сначала действие, потом условие, можно без скобок после знака вопрос то, когда условие true, через двоеточие то, что else 
$b = ($a==1) ? 'One' : 'Zero';

elseif - соединение else и if
в больших цепочках. И в конце пишется else.

Альтернативный синтаксис, когда вместо фигурных скобок после каждого if, else, elseif ставится : а в конце ставится endif.
        if($age>17 && $age<60):
        echo 'Вам еще работать и работать';
        elseif($age>=1 && $age<18):
        echo 'Вам еще рано работать';
        else:
        echo 'Неизвестный возраст';
        endif;
        
switch для проверки переменных, чтобы не писать 10 if-ов        
$age = 1;
        switch ($age) {
    case 0:
        echo 'Ноль';
                break; // брейк нужен, чтобы выкидываться из счета и заново подставлять
    case 1:
        echo 'Один';
                break;
    case 2:
        echo 'Два';
                break;
    case 3:
        echo 'Три';
        break;

    default: echo 'Много';
        break;
}   
ini_get('имя_директивы') //дает значение деректив любых, как например максимальное количество символов формы у разных хостеров
    
// тип массив - array
$user[] = 'lol'; // массив обозначается квадратными скобками. Они значает - ячейка
$user[] = 'root';
$user[] = '1234';
$user[] = 25;
$user[] = TRUE;

echo count($user); // функция count возвращает числом количество ячеек массива $user

echo $user[0]; // выборка конкретного элемента массива. Нумерует их он от нуля. Первая - нулевая

print_r($user); // функция для просмотра элементов массива

var_dump($user); // функция просмотра всех элементов массива

$user1 = array('lol', 'root', '1234', 25, true); // создали массив, внутри перечислены, идентичен тому массиву, что сверху

$user2 = array(10=>'lol', 'root'); // стрелка означает что мы даем номер-имя ячейке 10. Идентично $user2[10]

$user['name'] = 'lol'; // имя ячейки можно задавать словом. Можно имя писать без кавычек, если несколько массивов в двойных кавычках используется. Тогда ей уже число не присваивается. С ними также можно указать краткую версию, см выше. Но не надо без кавычек просто писать, тк без кавычек и знака доллара пишутся у нас константы!

многомерный массив

$cars['user'] = array (
    'name' => 'Sergey',
    'e-m' => 'fire@lol.lo',
    'tel' => '8908908908',
    'age' => 25 
);
$cars['nouser'] = array (
    'noname' => 'Sergey',
    'noe-m' => 'fire@lol.lo',
    'notel' => '8908908908',
    'noage' => 65
);

Константы
define('имя константы', значение); // имя констаны принято писать большими буквами ей нельзя присваивать, удалить, ничего сделать
defined ('имя'); // проверка существования константы. Возвращает true и false, false - если константа существует, true - если отсутствует
Константы регистрозависимы!

define('имя константы', значение,true); // true добавляем, чтобы константа была регистронезависимой. Но это не особо надо делать

Циклы
Операторы инкремента и декремента:
++ Увеличивает значение переменной на 1
-- Уменьшает значение на 1
+=2 Увеличивает на 2
-= уменьшает на 2

++$a // PRE инкремент/декремент, увеличивает $a на единицу и возвращает значение а
--$a // PRE инкремент/декремент, уменьшает $a на единицу и возвращает значение а
$a++ // POST инкремент/декремент, возвращает значение а и увеличивает $a на единицу 
$a-- // POST инкремент/декремент, возвращает значение а и уменьшает $a на единицу

$a = 1
echo 'Вывод числа: '. $a++; // вывод числа 1
echo 'Вывод числа: '. $a; // вывод числа 2
echo 'Вывод числа: '. ++$a; // вывод числа 2
echo 'Вывод числа: '. $a // вывод числа 2
        
for
for (часть1; часть2; часть3){
    инструкция 1;
    инструкция 2;
    ...
}
часть 1 - там нечто, что он тупо делает. можно несколько значений писать через зпт. часто счетчик
часть 2 - как бы if, когда true - он что-то делает из тела цикла
часть 3 - так же, как и первая, счетчик прибавляется
И он снова возвращается в часть 2, если true, то снова делаем, false - заканчиваем        

for ($i=1; $i<=30; $i++) {
    ...
}

while
while (условие проверяется на true) {
    инструкция 1;
    инструкция 2;
    ...
}

$r = 1;
while ($r<50){
echo $r . '<br>';
$r+=2;
if ($i == 5)
break; // оператор break для выброса из цикла
}
while ($r<56){
$r+=2;
if ($i == 5)
    continue; // оператор continue для возврата в условие вайла из цикла. Так он там только раз бывает
    echo $r . '<br>';
}

break и continue выбрасывает только на одном уровне. Если цикл внутри цикла, то его брейк и будет уровня. Поэтому чтобы брейк действовал на следующем уровне тоже - надо писать его с цифрой и континуе тоже break 2, continue 2

do {
    инструкция 1;
    инструкция 2;
} while (условие) // это используется чтоб он сначала выполнил, а потом уже смотрел условие

    //foreach - цикл работы с массивами
    foreach ($cars as $v) { // имя массива и имя переменной, в которую загоняется каждый элемент 
    echo $v.'<br>'; // выведет все ячейки массива в столбик
}
foreach ($array as $key => $value) {
// $key - это ключ ячейки, в него будут записываться ключи
}

перемещение по массиву шагами
echo current($user); // значение текущей ячейки, что стоит первая, если мы на нее не переходили
echo next($user); // следующая
echo current($user); // теперь ужеследующая будет текущей, если так и писть после некста
echo prev($user); // предыдущая
echo end($user); // последняя
echo reset($user); // первая
echo key($user); // возвращает ключ текушей ячейки

Функции
$arr = range(1, 1000000); // заполняет массив ячейками от 1 до 10000000
function imyaF () {// имя функции регистронезависимо. Действует только по вызову по имени - это объявление функции
echo "<h1>Hello, World!</h1>";
} 
imyaF(); //вызвали функцию, можно много раз вызвать подряд и не подряд, а объявить несколько раз ее нельзя

есть куча встроенных функций, можно проверить
function_exists($function_name); // возвращает true или false есть ли функция или нет с этим именем

function functionName($param, $n) {
echo "<h$n>Hello, $param!</h$n>"; // в функцию можно передать параметры, тогда при вызове функции надо будет все аргументы указывать - 
} // а чтобы не указывать, можно установить умолчание для аргументов, пишется оно через равно:
function functionName($param, $n=3){ } // теперь даже если вызвать функцию с одним параметром, второй будет по умолчанию и ошибки не возникнет! НО сначала перечисляются обязательные, потом - не обязательные
functionname ('John', 1); // передали параметры

$sttr = 'functionname';// если переменной присвоить имя функции, то можно вызывать по имени переменной
$sttr('Guest', 3);//вызов функции functionname через переменную sttr с передачей параметров

global $ant;
$ant = 'Vasya'// глобальная переменная. Если ее задать внутри функции, то она будет действовать и вне ее тела, а так все переменные внутри функции отдельные, даже если имена у них совпадают с какими-то вне. НО он локальную удаляет и заменяет этой, если она там где-то была 
$GLOBALS['Vasya'] // вот так выглядит любая глобальная переменная,заданная в php, он ее запсывает в свой массив ГЛОБАЛС и ее можно оттуда вызвать без слова global и не перезаписывать другие такого же имени переменные...
        
function trolls(){
static $a = 0; // делаем переменную почти глобальной, после выхода из описания функции php ее запоминает, не забывает. Поэтому при следующем входе в функцию ей уже присвоено какое-то значение
echo $a++;
}
trolls(); // выведет 0
trolls(); // выведет 1
trolls(); // выведет 2

function getSum($n1,$n2) {
return $n1+$n2; // когда функция должна что-то вернуть используется слово return, внимание! return заканчивает функцию, как break, после него уже не исполняется, что бы ни было написано внури функции
}
echo getSum(2,3); // напечатается вернутое значение функции

Рекурсивная функция - ф-ция. которая вызывает сама себя
function factorial($n)
{
    if($n == 0) return 1;
    return $n * factorial($n-1); // функция внутри функции, пока не наступило 0
}
$resiult = factorial(5)
        echo "5!".$result;

function foo(){
echo func_num_args();// выведет 3 - возвращает количество переданных в функцию данных
$args = func_get_args();
print_r($args); // выведет аргументы как они есть
echo func_get_arg(1); // выведет второй переданный по счету (с нуля) аргумент,в данном случае 35

$a = 10;
$b = &$a; // это типа ярлык на переменную а, b означает а. Ссылка, а не копия

}
foo('a',35,true);

foreach ($array as $val){
    $val = 10; // эта запись улетает в воздух, т.к. за основу берется уже извесная переменная и ей не присвоится, т.к. foreach работает со ссылками (ярлыками)
}
foreach ($array as &$val){
    $val = 10; // тут получается, foreach работает не с ссылками, а наоборот, т.е изменит в итоге массив, перезапишет глобальную переменную
}

print_r(get_defined_functions()); // возвращает список функций, доступных для установленной версии php

Описание функций есть в документации, в удобном виде. Их очень много

Часто используемые функции работы с переменными. Возвращают true или false по соответствию указанному типу
is_array($var)
is_bool($var)
is_float($var)
is_integer($var)
is_numeric($var)
is_string($var)
is_null($var)
intval($var [, int $base]) //возвращает целочисленное значение аргумента
floatval($var) //возвращает вещественное значение аргумента
        
Функции математические

max($values) // возвращает наибольшее число из заданных
acos(arg) // возвращает значение арккосинуса
cos(arg) // возвращает косинус числа в радианах
min(values) // возвращает наименьшее число из заданных
decbin(number) // возвращает двоичное представление целого числа
log(arg) // возвращает натур логарифм значения
pi(oid) // возвращает приблизительное число пи
rad2deg(number) // возвращает в градусах значение аргумента, заданного в радианах
round(val) // возвращает округленное до ближайшего целого числа значение заданное аргументом
sqrt(arg) // извлечение квадратного коорня из числа
rand(oid) // возвращает число, лежащее между двумя необязательными аргумертами включительно

Функции обработки строк

addslashes(str) // экранирует спецсимволы в строке
stripslashes(str) // реэкранирует спецсимволы в строке
explode(delimiter, string) // разбивает строку на подстроки
htmlentities(string) // преобразует символы в соответствующие html сущности
trim(str) // удаляем пробелы из начала и конца строки
str_replace(search, replace, subject) // заменяет строку поиска на строку замены
strpos(haystack, needle) // возвращает позицию первого вхождения подстроки
strip_tags(str) // удаляет html и php теги из строки
strstr(haystack, needle) // находит первое вхождение подстроки
substr(string, start) // возвращает подстроку
strlen(string) // возвращает длину строки

Функции работы с массивами

array_search(needle, haystack); // в массиве нидли ищет значение хайстек и возвращает ключ. Или если проверка, то третьим параметром можно передать тру/фолс
array_pop(array) // извлечь последний элемент массива
array_shift(array) // извлечь первый элемент массива
array_rand(input) // одно или несколько случайных элементов из массива
array_reverse(array) // возвращает массив с элементами в обратном порядке
count(var) // посчитать количество элементов массива или кличество свойств объекта
in_array(needle, haystack) // проверить, присутствует ли в массиве значение
array_key_exists(key, search) // проверить, присуствует ли в массиве ключ
implode(glue, pieces) // объединить элементы массива в строку
        
php.net - там ссылка на документацию

Есть языковые консрукции, а есть функции - не путать! Отличие в том, что яз конструкции никогда ничего не возвращают, например echo. Исключение - языковая конструкция print возвращает 1

Как читать описание функции в документации
Например int intval(mixed $var [, int $base])

[] означает необязательность параметра и у него есть значение по умолчанию

перед переменными слова означают ожидаемый тип, int - integer, mixed - означает что можно туда передать больше чем один тип, какие - пишется ниже в описании. Перед самой функцией тот тип, который она возвращает - тут int// если туда делать не ожидаемый тип, то php конвертирует в ожидаемое

в списке параметров описано то, что входит в mixed: var - скалярное...
Еще похожие функции пишутся в "СМ также"

Но лучше в мануале сидеть онлайн, там и коменты, и поиск легче...

Функции работы с датой-временем

$arr = getdate(); // вернет массив с состоянием даты - времени
$arr = getdate(1234567890); // если туда передать дату в этом формате - это формат временная метка, он выдаст расшифровку, когда это было.
echo date ("d-m-Y H:i:s"); // выводит дату в введенном формате
echo date("d-m-Y H:i:s", 1234567890); // выведет дату по метке, все буквы и обозначения есть в мануале на функции
time(); // возвращает текущую временную метку
mktime(0,0,0,2,15,1978); // вернет метку времени Unix для этой даты (15 фев 1978)
mktime(0,0,0,1,1,2011); // дата 1 янв 2011
mktime(0,0,0,13,1,2010); // дата 1 янв 2011
mktime(0,0,0,12,32,2010); // дата 1 янв 2011
checkdate(month, day, year) // дает true если эта дата существует или false - если нет
есть функция для вывода разницы между двумя датами
$s = date_create('2009-10-11'); // записываем сначала две даты
$e = date_create('2009-10-13');
$i = date_diff($s, $e); // функция собирает две эти даты
echo $i->format(%R%d days); // у нее есть метод, котрый возвращает разницу дней

Псевдофункции пишутся в войных подчеркиваниях - константы
echo __LINE__; // выведет номер строчки, в которой она прописана

echo __FILE__; // вернет полный путь к файлу

function FunctionName()
{
    echo __FUNCTION__; // вернет имя функции, в которой она прописана

}
echo PHP_VERSION; // выведет версию PHP, вообще подобных констант, описывающих PHP, много

КАК ВЫВЕСТИ НА ЭКРАН В ВИДЕ КОДА МАССИВ
echo '<pre>';
print_r($arrayname);
echo '</pre>';

$_SERVER // массив, содержащий инфу о сервере и всем всем с этим связанном, ай-пи всякие, порты, адреса и т.д.
$ip = $_SERVER["REMOTE_ADDR"]; // вытаскиваем ip

Как достучаться до этих масивов? Через Глобалс либо по ним самим, если они отдельные:

echo $GLOBALS[_POST]['a']; // то же через глобалс (массив с глобальными переменными)
echo $_POST['a']; // одно и то же, но короче. Напрямую чаще всего, так пишут

echo 'Powered by '.$_SERVER['SERVER_SOFTWARE']; // выведет ячейку массива $SERVER с инфой о конфигурации

SSI
SSI - это когда мы отправляем несколько кусков, а на сервере они склеиваются воедино. Php это все дело заменяет
Есть функции эмуляции SSI в PHP
include (); include_once();
require (); require_once ();

include 'text.php'; // на это место вставить содержимое файла text.php если ошибка, то будет варнинг, но код продолжает выполняться. Можно сколь угодно этот файл сто раз ставить в разные места
require 'text.php'; // то же, но если есть ошибка, то ошибка будет фатал еррор и код не продолжится
include_once 'text.php'; // для избежания ошибок повторов подключить единожды. Если потом еще раз это написано, то он игнорит, подключает только один раз.


Копирайт самообновляющийся и поверед бай для крутости
?>
<b>&copy; SuperWebmaster, <?=date(Y)?></b>
<hr>
Powered by <?=&_SERVER['SERVER_SOFTWARE']?>

Как защититься от ошибок
Бывает, что при ошибке показывается путь к файлу и это могут взять хакеры и взломать все. Поэтому есть приемы против этого. Сразу смотрим слабые места, где могут быть ошибки в случае, если кто-то случайно поменяет код. Это функции в данном случае.

Функция должна что-то возвращать, чтоб проверить ее на успешность выполнения или неуспешность.
Например, если в переменную пришел не массив, то должно возвращаться false

пишем в функции так:
function FunMenu($usermenu, $vertical=true)
if (!is_array($usermenu)) // если это не массив, то возвращаем ложь
    return false;
$styleHorizont = '';
if (!$vertical) {
    $styleHorizont = ' style="display:inline; margin:15px"';
}
echo '<ul style="list-style-type:none">';
foreach ($usermenu as $key=>$value) {
    echo "<li$styleHorizont><a href='http://lol.ru/$value'>$key</a></li>";
}
echo "</ul>";
return true; // в конце возвращаем тру, если все работает
}
 
А там, где вызов функции, пишем так:
            <?php
            if (!getMenu($leftmenu))
            echo 'Извините, что-то произошло...';
            ?>
вместо простого <?php getMenu($leftmenu);?>

Лучше это упростить и универсализировать - завести под надпись "Извините. что-то произошло" - консанту, константа может содержаться в другом отдельном файле вместе с др. константами.

Функция без функции
Можно инклюдный файл использовать как функцию, для этого никаких имен не надо - в файле пишем условия и внизу что вернуть надо. Подключаем файл и он возвращает результат, как функция

$a = 2; $b = 3;
$c = $a + $b;
return $c; // это пишется в инклюдном файле.

а в другом файле пишем
$res = include 'file.php';
echo $res; // выведет 5


Куки

устанавливаем куки - задаем (отправляем)
setcookie ($name // имя куки - обязательный параметр
    , $value, // значение параметра 
    $expire= 0, // истечение срока годности, если надо установить на какое-то время, то бишь например, чтобы браузер не удалял куку неделю. Но если пользователь чистит куки, то исчезнет, конечно
    $path //  опредеяет часть домена. Например при запросе Specialist.ru/docs - надо, а при specialist.ru/contacts - не надо
    , $domain // по домену, например specialist.ru эту куку получит, а sare.ru - не получит.
     , $secure= false // безопасность, если труе, то будет идти через https
     $httponly= false)
setcookie("testcookie", $val); // кука по имени testcookie и посылается какие-то значение
setcookie("test2cookie", $val,time()+3600); // вешаем куку с периодом действия 1 час, даже если браузер закр/откр, она живет
setcookie("test2cookie", $val,time()+3600, "/docs/", " .site.com", 1); // вешаем куку с периодом действия 1 час, которая доступна в папке докс, только /docs ее получит. Доступна всем поддоменам сайта .site.com - new.site.com/docs, lol.site.com/docs например, плюс https исполняется

Важно! Куку надо отправлять до вывода чего-либо. То бишь после echo setcookie не работает, так как вывод уже начался, а выводит браузер заголовки вначале, если после вывода заголовков вывести еще что-то и попросить вывести куку - не выведет, потому что уже заголовки выводил и перебил как бы выводом другого
Внимание ! любые пробелы и все все в html (вне php) - уже считается выводом, а в php только всякие echo, print_r и т.д.

echo "a";
setcookie("name", "lol"); // выведет ошибку, не будет работать. Внутри php всякие echo считаются выводом, вне php любые пробелы - считаются выводом.


Куки записываются в глоб массив
echo $_COOKIE["name", "lool"]; // name - имя, в lool может быть массив

сохранить массив
$arr1 = array('one' => 1,
                'traa' => 'lol'
                '09' => true); 

echo serialize($arr1); // чтобы сохранить массив куда-то, но чтобы и структура сохранилась, есть serialize. Он хранит в строку, но при этом сохраняет инфу о структуре
$mass = unserialize($arr1); // развернуть обратно сохраненный массив $arr1 в массив $mass

удаление куки
Чтоб кука быстро удалилась, можно передавать ее пустой, с пустым значением или с отрицательным именем
setcookie("name"); // официально при отсутствии всех остальных данных, только обязательные - имя - кука удаляется при закрытии браузера.
setcookie("name","");
setcookie("name","",time() - 3600);

ВНИМАНИЕ! Нельзя редактировать файлы PHP в виндовсовском блокноте, т.к. он заменяет кодировку и делает ее с ВОМ, а значит куки все накроются!
Если кракозябры, то в корне сайта (папке) надо создать файл .htaccess и с помощью любого редактора вписать AddDefaultCharset UTF-8

header("string: значение"); // функция посылания заголовков
Можно сооружать свои собственные заголовки. Например
header("myTime: ".date("H:i:s"));
header("location: cookie.php"); // заголовок задаем страницу. все остальное браузер записывает уже из названного файла. Перенаправение это. Полный адрес надо писать. Они должны как куки посылаться ДО ВВОДА
header("location: ".$_SERVER["PHP_SELF"]); exit; // Это переход на ту же самую страницу и примочка чтобы после запуска данных формы при обновлении эти данные больше не запускались по сто раз, exit надо ставить
header("Refresh: 1"); // число - кол-во секунд. Перезагрузка каждые определенное количество секунд
header("Refresh: 2;url=http://www.lol.ku") // автоматическое перенаправление через указанное кол-во секунд
header("content-type: text/xml"); // отобразить документ как xml формат, по умолчанию - html
header("Cache-Control: no-store"); отмена кэширования совсем
header("content-type: text/html; charset=UTF-8"); // прописывать кодировку важно и нужно! И круто прописывать ее именно не в meta, a в header чтоб браузер не гадал и не было кракозябр. Бесплатные хостинги выставляют не utf-8
<meta http-equiv="content-type" content="text/html; charset=UTF-8"> // Заголовок приоритетнее, чем то же самое на мета-тегах, а мета рассматривается только если выше в заголовках не прописывается

существуют всякие обманные ходы...
header("content-type:file/ostet-stream"); // мы ему говорим считать файл текстовым документом
header("content-disposition:attachment; filename=\"mytext.txt\""); // мы присваиваем другое имя, шифруем файл, так как будто это тхт
header("cache-control: no-store"); // запрет кэширования
header("last-modified: ".gmdate("D, d M Y H:i:s")." GMT"); // дата последнего изменения - нельзя ставить вот так (как советует википедия), это неудачно. А надо вписывать руками сюда дату. Для поисковиков, т.к. они свежак ставят первее
header("cache-control: PUBLIC"); // разрешение на кэширование
header("expires: ".date("r", time()+3600)); // вторая часть разрешения кэширования
header("Set-Cookie: name=John; expires=Wed, 19 Sep 02 14:39:39 GMT"); // задаем куки через заголовки

md5("str"); // функция зашифровки. Расшифровать нельзя, но плюс в том, что он дает постоянный код для каждой комбинации, так можно шифровать и хранить пароли

Сессии
Это файлы временные на сервере, аналог кук, только в файлах
session_start(); // прописывается на  страницах - кусочках сессии
$_SESSION["user"] = "John"; // по аналогии с куками все записывается в глоб массив Session
echo $_SESSION["user"];
Кука сама отправляется с именем и ид сессии при создании сессии. Временный файл с сериализованным массивом создается в папке темп.
session_id(); // id сессии
session_name(); // имя сессии
session_destroy(); // удалить сессию, но файл остается, он только очищается. Надо физически удалять и плюс удалить куку, которая будет напоминать данные и браузер будет создавать этот файл
Сессии можно поставить время жизни

$lol = explode("|", $massname); // функция для преобразования строки в массив. Выбираем разделитель и все между разделителями будет уложено в ячейки нового массива $lol
list($n,$m,$k,$l) = explode("|", $massname); // разбиваем строку и кладем части полученного массива в переменные

Работа с файлами
parse_ini_file(); // функция делает из ини-файла массив построчно и через = разбивает
file_exists("filename.txt"); // существует ли файл
filesize("filename.txt"); // размер файла
fileatime("filename.txt"); // дата посл обращения к файлу, возвращается временная метка
filemtime("filename.txt"); // дата изменения файла, возвр врем метка
filectime("filename.txt"); // дата создания файла, возвр врем метка
fopen("filename.txt", mode); // открываем файл для чего-либо. mode - пишем режим. "r" - только для чтения, "r+" - для чтения и записи, "w" - для чтения и записи, текущее содержимое файла затирается, текущая позиция ставится в начало, "a" - для записи. Текущая заапись будет добавлена в конце файла, "a+" - для чтения и записи. В конец файла вносится запись, "b" - обрабатывать бинарный файл, для работы с бинарными файлами windows
$f = fopen("text.txt", "w+") or die("Ошиба"); // в переменную F в данном случае возвращается ресурс - указатель на файл. Тип данных - ресурс. там типа ссылка
fclose($f); // после открывания файла его надо закрывать!
fread("$f", 5); // читать первые 5 букв файла ресурса $f
fread("$f", filesize("text.txt")); // зачитать весь файл
fgets($f); // считывает построчно. вернет первую строку. Передаем $f - ресурс, дискриптор файла. Если друг за другом, то он первую сначала, потом вторую строку зачитывает, третью и т.д.
fgetss($f,255, "<br><a>"); // если файл с тегами, то зачитывать он гео будет игнорируя теги, параметр длина строки добавляется. Третьим параметром можно указать теги, которые хотим сохранить, если их несколько, то просто в строчку их пишем, без разделения
fgetc($f); // побуквенно: вернет первую букву ресурса. Если писать последовательно несколько раз, то вернет следующие буквы.
fwrite($f, string, 67); // пишем в файл. Задается дискриптор (ресурс), строка, что пишем,  и третий параметр необязателен, ограничение длины. Пишет прямо поверх, как insert.
fseek(handle, offset); // установка курсора в определенное место файла. offset - кол-во символов, на которое надо передвинуться. Можно отрицательное число -тогда движение справа налево. Третьим параметром можно задать константы:
SEEK_SET // движение начинается с начала файла
SEEK_CUR // движение идет от текущей позиции (по умолчанию)
SEEK_END // движение от конца файла
fseek($f, -10, SEEK_END);
$s = fread($f, 10) // зачитать последние 10 символов файла $f
$pos = ftell($f); // узнать текущую позицию курсора
rewind($f); // сброс курсора, перемещение его в начало
feof($f); // возвращает true или false - дошли ли мы до конца файла или нет
file("data.txt"); // получим масссив, где файл построчно в массиве, в каждой ячейке своя строка
file_get_contents($f); // файл возвращается в виде одной большой строки
file_put_contents("data.txt", "\nzapiskadata", FILE_APPEND); // запись. data - что пишем. Внимание! Затирает то, что было! Если мы добавляем, а не заново пишем, то последним параметром передаем константу FILE_APPEND
Внимание! Если файла не существует, то php будет пытаться его создать, если используются file_put_contents, file_get_contents. Но выдаст ошибку, если file(filename)
copy(source, dest); // копирование файла
rename(oldname, newname); // переименование
unlink(filename); // удаление файла
rename("folder1/test.txt", "folder2/text.txt"); // перемещение файла путем его переименования

if ($_SERVER["REQUEST_METHOD"]=="POST") { // проверка того, что форма была отправлена, проверка отправки формы
    ---
}

Прием в php для приема живых данных, отпрвленных через POST
$rawPost = file_get_contents('php://input');




strip_tags(str); // удаление всех php и html тегов из заданной строки
$_POST["fname"]; // это мы выбираем что прислал input с именем name="fname", который отправлялся методом post
trim(strip_tags($_POST["fname"])); // очищаем от всяких пробелов и тегов то, что было введено в поле name="fname" формы с методом post

Директории (папки)
mkdir("pathname"); // создать директорию
rmdir("dirname"); // удадение директории. Внимание! Директория удаляется только когда она пустая!!! Чистить надо перед удалением
$dir = opendir("path"); // заходим в директорию. Возвращает название, ресурс, ссылку, дискриптор, как в файлах
$name = readdir($dir); // возвращает имя файла или папки, которое внутри $dir, причем возвращает без расширения и фиг пойми, что это - папка там или файл. Для этого используем is_dir, is_file
is_file("filename"); // по аналогии с is_array
is_dir("filename");
closedir(); // закрытие директории, как с файлом после работы
$d = opendir("."); // открыть ТЕКУЩУЮ директорию. Точка означает текущую
closedir($d); // мы ее закрываем
scandir("directory", 1); // аналог file() - возвращает все содержимое папки в массив. Если второй параметр - 1, то массив будет построен в обратном порядке
function dirs($dir, $tab) // функция для вывода дерева папок
{
    $d = opendir($dir);
    while ($name = readdir($d)) {
        if ($name=="." or $name=="..") { // обязательно с точками папки убирать
            continue;
        }
        if (is_dir($name)) {
            echo "<b>".$tab."[$name]</b><br>";
            $tab .= '-';
            dirs($dir."/$name",$tab);
        }else
        echo "$tab$name<br>";
            }
closedir($d);
}
dirs(".", "");

загрузка папок на сервер
Для этого надо настраивать php.ini
file_uploads // должен стоять on
upload_tmp_dir // временная папка на машине для загрузок, адрес прописать можно. Туда все файлы попадают после нажатия кнопки загрузить. Вся инфа про них попадает в массив $_FILES
upload_max_size // максимальный размер загрузки файлов

возможность загружать файл через форму строка "обзор"
<form action="files.php" method="POST" enctype="multipart/form-data"> // Внимание! обязательно должен быть такой параметр у enctype, иначе придет не файл, а его имя.
<input type="file" name="uf">
<input type="submit">
</form>
по умолчанию минимальный размер файла 2 мб, если хотим уменьшить, то после form создается
<input type="hidden" name="MAX_FILE_SIZE" value="51200"> // например, для аватарок, но не очень надежно, лучше на сервере проверить через $_FILES["lol"]["size"];

$_FILES["userfiles"]['name'] // userfiles - имя инпута с type="file", с кнопкой обзор, через который грузили файл, name - имя файла
$_FILES["userfiles"]['tmp_name'] // временное имя, физ путь к нему
$_FILES["userfiles"]['size'] // размер, через него можно проверить размер и не пустить
$_FILES["userfiles"]['type'] // тип файла
$_FILES["userfiles"]['error'] // тру или фолс, нормальный ли файл, целый и т.д.
move_uploaded_file("filename", "destination"); // filename - путь файла, где он лежит и имя, destination - куда сохраняем его
if ($_FILES['uf']['error']==0) {
    $t = $_FILES['uf']['tmp_name'];
    $n = $_FILES['uf']['name'];
    move_uploaded_file($t, "upload/".$n);
}
отправка почты
снова php.ini
[mail function]
; for win32 only.
SMTP = localhost // надо указать имя SMTP-сервера
; for win32 only
sendmail_from = mail@localhost.com // адрес, по умолчанию "от кого"

mail("frog@lol.ru", "Тема письма", "Я к вам пишу\nЧего же боле...\nМне голос был"); // функция для отправки, возвращает true или false - передалось письмо или не передалось почтовику
mail("frog@lol.ru", "Тема", $message, "From: webmaster@$_SERVER_NAME\r\n"."Reply-To: webmaster@$_SERVER_NAME\r\n"."X-Mailer: PHP/" . phpversion()); // это мы добавили дополнтельные заголовки
// еще заголовки: мы загоняем их для удобства в одну переменную, и задать ее четвертым параметром в mail
$headers = "MIME-Version: 1.0\r\n";
$headers .= "content-type: text/html charset=iso-8859-1\r\n";
$headers .= "From: Birthday Reminder <birthday@example.com>\r\n";
$headers .= "Cc: birthdayarchive@example.com\r\n"; // копия
$headers .= "Bcc: birthdaycheck@example.com\r\n"; // скрытая копия

Базы данных
в ячейке таблицы бд должно быть только одно значение!

ЗАПРОСЫ SQL
SELECT // регистронезависимое и пробелонезависимое, но для удобства надо писать заглавными и разделять.
SELECT name // это минимальный запрос. Дай мне все записи из поля "name" таблицы "teachers"
FROM teachers

SELECT name, addr, city // это минимальный запрос. Дай мне все записи из поля "name" таблицы "teachers"
FROM teachers ORDER BY name desc // сортировка по имени, если есть desc - то значит в обратном порядке, name - что сортируем

SELECT title // Выбор всего из колонки тайтл таблицы корсес, только те, в которых длина больше 30
FROM courses
WHERE length > 30 // оператор "где".

SELECT * // Выбор всех полей из колонки тайтл таблицы корсес, только те, в которых длина больше 30. * лучше не использовать.
FROM courses
WHERE length > 30 // оператор "где".
AND title LIKE 'Web%' // можно использовать разные операторы, всчкие or, and. LIKE - это значит вместо % все что угодно

Объединение таблиц
SELECT t.name, t.code, l.course
FROM teachers t //Перевод - "Что объединяем" для ускорения можно сокращать. Сокращение работает только в текущем запросе.  сокращение имен таблиц записывается в FROM - имя полное и через пробел сокращенное. И тогда он понимает, что t.name означает выборку ячейки name в таблице с названием teachers
INNER JOIN lessons l ON t.id = l.tid //INNER JOIN - внешнее объединение. Перевод - "с чем объединяем и по какому правилу" здесь тоже указание псевдонима lessons - l.
DESCRIBE msms; // запрос инфы о столбцах таблицы msms внутри созданной БД

В ответ этому запросу приходит таблица объединенная. Она строится из полей, которые "бьют"
LEFT OUTER JOIN lessons l ON t.id = l.tid // тоже объединение, но включаются и поля, которые не "бьют". Колонка без соответствия заполняется NULL-ом
SELECT DISTINCT length // выбирает единичные упоминания значений в указанном столбце length оператор, игнорирует совпадения, берет только уникальные

INSERT INTO courses // INSERT - оператор на вставку новой записи. courses - имя таблицы, 
VALUES (NULL, 'Java2', "...",40) // в скобках значения, которые вставляются в эту таблицу. Первое значение пойдет в первую колонку, второе - вторую и т.д. Внимание! Строковые данные в SQL заключаютс в оДИНАРНЫЕ каввычки!
INSERT INTO courses (title, length) // вставка в определенные колонки - они указываются в скобках и вставляется инфа соответственно и через пробел пишем
VALUES ('Java2', 40)

DELETE FROM lessons //удалить запись указанную или все, если не указано условия
WHERE lessons.date = '2005-06-11'

UPDATE teachers // изменение на уже существующую запись
Set
zarplata = zarplata * 2,
premia = premia * 10
WHERE name LIKE 'Иванов%' // WHERE - условие, которое обязательно, иначе просто все обновятся, а не те, что надо
OR name LIKE 'Петров%'
OR name LIKE 'Сидоров%'

UPDATE teachers
Set
zarplata = zarplata * 2,
premia = premia * 10
WHERE name IN
('Иванов', 'Петров', 'Сидоров') // то же, что и выше, только списком через IN

SET NAMES 'cp866'; // установка кодировки для отображение русс букв


$lolDB = mysql_connect("localhost","root","rafikider"); // подключаемся к серверу mysql. Передаем сервер, логин, пароль, в переменную идет типа ссылка, линк на бд, удобно, если 2 соединения и более. По умолчанию у mysql пожизняк логин root и пустой пароль, можно менять
mysql_select_db("database_name") or die(mysql_error()); // выбор бд, аналог use в mysql. И сразу если ошибка в БД, чтоб выводил, а так не выведет
mysql_errno(); // возвращает номер ошибки
mysql_error(); // возвращает описание ошибки
mysql_query("query"); // посылание запроса, что надо делать, например delete
mysql_query("SET NAMES 'cp1251'") or die(mysql_error()); // установка кодировки
$result = mysql_query("SELECT * FROM teachers"); // результат запроса mysql передаем в переменную
$sql = "SELECT * FROM teachers"; // лучше всего запрос писать в отдельную переменную, чтоб избежать ошибок, в случае ошибки легко можно будет вывести с помощью echo
$result = mysql_query($sql);
mysql_close(); // закрывает соединение с БД, не обязательный, но лучше закрывать
mysql_close([$lolDB]); // можно так

алгоритм
// Сначала подумать, сколько раз нам надо будет подключаться к базе, если 1, то коннект и селект пишем отдельно вверху, где константы
mysql_connect(); // устанавливаем соединение с бд
mysql_select_db("database_name"); // выбираем бд для работы
mysql_query(query); // посылаем запросы
mysql_query("SET NAMES 'utf8'"); // кодировка чтоб норм
mysql_close(); // закрываем соединение

$conn = mysql_connect("host","login","pass"); // лучше записывать в переменную.
mysql_close([$conn]); // и закрывать потом вот так
mysql_fetch_array($result,MYSQL_ASSOC); // возврашает массив из бд, но он удвоенный, если не указать MYSQL_ASSOC и ассоциативный, если указать. MYSQL_NUM - нумерованный массив, MYSQL_BOTH - сдвоенный
mysql_fetch_assoc(result); // аналог ассоциативный
mysql_fetch_row(result); // аналог нумерованный
while ($row = mysql_fetch_assoc($result)) {
    echo $row[name]."<br>";
 } // вывод данных таблицы, массива в столбик через вайл
mysql_result($result, 5, field); //точечная выборка
mysql_num_rows(result); // подсчитать количество записей
mysql_num_fields(result); // подсчитать количество полей
mysql_field_name(result, field_offset); // имя поля
mysql_affected_rows([$coll]); // количество изменений, до закрытия соединения пишется
mysql_insert_id([$conn]); // ид последней записи, работает только при автоинкременте

if (!empty($_POST['name']) and !empty($_POST['email'])) { // проверка заполненности формы
    ...
}

<a href='gbook.php?del=<?=$user["id"]?>'>Delete</a> <?php // это мы отправляем в массив Get ячейку del, которая содержит определенный id
if (isset(["del"])) { // проверяем, если существует дел в массиве Get, то ...
  $id = ClearData($_GET["del"],"i"); // выполняем действие с определенным id
}

MYSQLi
$conn = mysqli_connect('host', 'root', 'rafikider', 'news'); // у MySQLi, в отличие от Mysql при соединении сразу обязательно последним параметром прописывать имя БД, с которой соединяешься, там нет select_bd
$result = mysqli_query($conn, 'SELECT * FROM articles'); // у MySQLi, в отличие от Mysql при запросе обязательно первым параметром указывать переменную соединения.
mysqli_close($conn); // закрытие

MySQl View
// это типа призрачной таблицы, ярлык
CREATE TABLE t // создали таблицу t, где две колонки - gty числовое и price числовое
(gty int, price int);
CREATE VIEW v AS // создаем призрачную таблицу v как
SELECT gty,price,gty*price AS value FROM t // выбранные из таблицы t столбцы и плюс добавляем столбец с их произведением (в таблице t его нет)
SELECT * FROM v; // вызов этой таблицы-ярлыка будет по имени v
get_magic_quotes_gpc // принудительное экранирование в php, желательно этот параметр ставить off, для этого в файле htaсcess пишем строку php_flag get_magic_quotes_gpc off

<a href='gbook.php?del=<?=$user["id"]?>'>Delete</a> // передача методом get чего-либо в адресную строку, само слово get не надо писать тут, а любое - del,id и т.д.
// Функция для переделки ресурса БД в массив <?php
function db2array($data)
{
    $arr = array();
    while ($row = mysql_fetch_assoc($data)) {
        $arr[] = $row;
     }
    return $row;  
}
"SELECT count(*) FROM tablenm" // запрос на получение количества строк таблицы tablenm

mysql_result($result, 5, "field"); // чтобы потом вывести результат -т.е вычленить одно значение. field - имя колонки, $result - переменная, которая возвращает то, откуда надо вытащить, 5 - позиция записи, если запись одна, то 0.

$sql = "SELECT count(*) FROM basket WHERE customer='".session_id()."'"; // строковый параметр customer пишется в кавычках

$sql = "SELECT c.author, c.title, c.pubyear, c.price, b.id, b.goodsid, b.quantity, b.customer
FROM catalog c, basket b WHERE customer='".session_id()."'"; // объединение нескольких колонок разных таблиц, выборка по session id, совпадающему с session_id, записанным ранее в customer


Объекты
Это восьмой тип данных - object

class Animal { // в классе содержится описание объекта, его свойства, т.е. переменные
    public $name; // можно просто объявить
    public $age = 0; // можно что-то присвоить
    function FunctionName($word) // метод описывается функцией в описании класса. Называется Метод
    {
        echo $this->name.' сказал '.$word;  // если внутри метода надо вызвать переменные из свойств, то через this
        $this->DrowBr(); // вызов метода в методе тоже через $this
    }
    function DrowBr()
    {
        echo "<br>";
    }
}
$cat = new Animal(); // объект создается оператором new, если без переменной, то он просто создается, и никуда не присваивается. $cat называется экземпляр класса Animal, в скобках передается данные для __construct
$dog = new Animal;
$cat->name = 'Мурзик'; // свойству name дается значение (как в массиве ячейке lol[p], тут lol->p, можно обращаться как к переменной)
$dog->name = 'Тузик'; // Внимание! переменная, в которую кладется объект - это ССЫЛКА на него, то есть копированием переменной не скопируешь объект, только клонированием
$cat->FunctionName('Мяу'); // обращение к методу-функции
$dog->FunctionName('Гав');
__METHOD__ // псевдоконстанта, возвращает имя класса и имя метода, внутри функции которого находится в таком виде MyClass::myMethod
Вообще, внутри класса ссылка на само имя класса пишется как self:: и дальше какое-то свойство, self::$inst при этом можно не бояться и менять имя класса
__CLASS__ // Возвращает имя класса, внутри функции которого находится
__DIR__ // псевдоконстанта, возвращает имя папки
function __construct(){} // служебная функция, которая вызывается автоматом при создании объекта, как автозагрузка при new, вместо имени __construct можно использовать одноименное имя с именем класса
function __destruct(){} // что надо делать при удалении объекта, в его скобки ничего нельзя передать, из него нельзя обращаться к другим объектам, т.к. порядок удаления неизвестен
$bigcat = clone $cat; // копия объекта $cat, конструктор при копировании не вызывается, но есть специальная функция __clone для этого, она записывается в класс объекта
function __clone(){} // задается какое-то автоматическое действие при копировании элемента, ему ничего нельзя передать и к нему никак нельзя отдельно обратиться
function __autoload($classname){require_once($classname.'.inc');} // функция автозагрузки, чтобы ее вызвать, надо просто создать объект.
class User extends AnotherUser // наследование класса. Класс User новый, AnotherUser - родитель, от которого наследуются свойства, свойства наследуются напрямую, как будто они описаны в новом классе, хотя они описаны в родителе
public function FunctionName()
{
    parent::print(); // обращаемся к родительскому методу print(), чтобы добавлять
}
public // это называется модификатор, бывает кроме public - общедоступный, к нему можно обратиться откуда угодно var перед именами свойств означает, что писали на 4-м пхп
protected // к нему можно обратиться только из класса, где он объявлен и из класса-наследника
private // к нему можно обратиться только из класса, где он объявлен, традиция их писать начиная с подчеркивания _name ВНИМАНИЕ! ПО умолчанию private
try{ // обработка исключений, если мы догадываемся, что $b может принять значение 0, но ошибки нам не надо, мы пишем допущение. ПИШЕТСЯ внутри метода
    $a = 1;
    $b = 0;
    if ($b == 0) {
        throw new Exception("Деление на 0!"); // возбуждаем встроенный класс Exception, в который прописываем определенное сообщение
    }
    $c = $a / $b;
} catch(Exception $e) { // здесь в $e передается ранее введенное сообщение
    echo $e->getMessage(); // вывод сообщения
    echo $e->getLine(); // 
    echo $e->getFile(); // вывод имени файла
}

SQLite
$b -> escapeString($string); // функция для экранирования переменной $string
$db = new SQLite3('text.db'); // создание БД через класс и файл, класс можно перегружать, менять свойства и т.д.
$db->close(); //  завершить работу с текущей бд
$db->open('another.db');  // начать работу с новой бд файла another.db
class ClassName implements AnotherClass {} // наследование без возможности менять
$res = $db-> exec($sql); // возвращает тру-фолс, запрос скл-запроса на тру и фолс
$db-> changes();// узнать о количестве изменений
$db -> lastErrorCode(); // вернет код ошибки mysqlite
$db -> lastErrorMsg(); // вернет описание ошибки mysqlite
sqlite_error_string(sqlite_last_error($db)) // возвращает описание ошибки - в скобках передаем дискриптор подключения к бд
sqlite_open(BASE_NAME); // создание или открытие БД в mysqlite
sqlite_close($db); // закрытие соединения с бд
$sql = 'SELECT name FROM user WHERE id = :id'; // подготовленный запрос, двоеточие и ид - это плесхолдер, может использовать поименованные с : и индексированные - номер с ? как в адресной строке 
$stmt = $db -> prepare($sql); // анализ подготовленного запроса, возвращает объект, у которого есть свои методы.
$stmt -> bindParam(':id', $id); // выбираем метод bindParam и задаем ':id' равное значению $id
$result = $stmt -> execute(); // вызываем оттуда же метод екзекьют и он исполняет запрос, вернет объект, или false
$stmt -> close(); // обращаемся к методу клос для закрытия, если мы его больше не собираемся использовать, или reset()
$row = $result -> fetchArray(); // и в конце обращаемся к методу fetchArray для создания в виде массива
$db -> querySingle($sql,true); // встроенный метод для выборки, вытаскивает одну запись или одну колонку. возвращается значение или null, если указываем true вторым параметром, то возвращает массив или empty array, если пустой массива, или false
$db -> query($sql); // аналогичный, возвращает результат или фалсе
$row = $result -> fetchArray(); // возвращает массив. Туда передается одна из трех констант: SQLITE3_BOTH для сдвоенного, SQLITE3_NUM для нумерованного и SQLITE3_ASSOC для ассоциативного. По-умолчанию сдвоенный

XML
ПРАВИЛА
1.Кодировка должна быть указана, плюс сам документ в ней должен быть сохранен
2. Чувствителен к регистру символов
3. Элементы, состоящие из откр тега, закр тега и содержимого.
4. Все теги надо закрывать, одинарные просто палкой <br/>
5. Должен присутствовать корневой элемент - корневой тег, это аналог тега html, но с любым другим названием, единственный, который все остальное сдержит.
6. Элементы могут иметь атрибуты, синтаксис ="" обязательно с кавычками. У одного элемента атрибуты не должны повторяться
Внимание! К xml документу можно задать стили css, только надо после первой строчки в xml прописать сие: <?xml-stylesheet type="text/css" href="style.css"?>
потом при чтении и выводе эти стили сохраняются, но некорректно, поэтому надо использовать XSL/T

XHTML - это html с правилами xml, теги все закрытые, регистр низкий и т.д.

Корректный xlm-документ - тот, что построен правильно и читается
Валидный - проверяется валидаторами по написанному шаблону - структуре DTD - определение типа документа и XML схемы
Как читается DTD:
<!ELEMENT catalog (book+)> // означает, что должен быть элемент корневой под названием catalog, а внутри него элемент book от одного и более
<!ELEMENT book (title, author+, price, exists?)> // в элементе book может содержаться один элемент title, автор минимум 1, прайс один и экзист в кол-ве 0 либо 1, или есть. или нет то есть.
<!ELEMENT title (#PCDATA)> // внутри тайтла может лежать только простой текст, больше ничего
<!ELEMENT author (#PCDATA)>
<!ELEMENT price (#PCDATA)>
<!ELEMENT exists (#PCDATA)>
<!ATTLIST price currently CDATA #IMPLIED> // у прайса есть некий атрибут карентли, необязательный, там текст, который не анализируется, берется как есть
DTD прописывается в начале документа xml
<?xml version="1.0"?>
<!DOCTYPE catalog SYSTEM "catalog.dtd"> // заодно указывается элемент корневой catalog

xml схема для валидации выглядит так:
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="страна" type="Страна"/> // есть элемент с названием страна и типом страна, дальше он его описывает
<xs:complexType name="Страна"> // это некий комплексный тип под названием страна
    <xs:sequence>
        <xs:element name="название" type="xs:string"/> // в его составе элемент название и
        <xs:element name="наcеление" type="xs:decimal"/> // элемент население
    </xs:sequence>
</xs:complexType>
</xs:schema>
Выглядеть xml в таком случае будет так:
<страна xmls:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceShemaLocation="country.xsd">
<название>Франция</название>
<население>57,5</население>
</страна>
SAX - получение инфы их XML-документа, основан на событиях, только для чтения, не модификация и изменение
DOM - чтение, модификация и создание новых xml-доков
SimpleXML - чтение и модифкация xml-доков, личная разработка php для чтения xml и изменения
XSLT - для преобразования XML документов в другие форматы

чтение через  SAX
Читальщик документа xml
Ориентируется на события, например, "открывающий тег найден", "закрывающий тег найден", "найден текстовый узел". Читает и генерирует события.
И мы ему даем функции, которые надо делать, когда случилось событие - он нашел открывающий тег, например

АЛГОРИТМ
l_parser_create("encoding"); // кодировку лучше вписывать UTF-8

// Шаг 2. Определение функции обработки
 Функция для обработки открывающего тега должна иметь три атрибута, называть как угодно, но чтоб 3 
function FunctionName($xml, $tag, $attributes){} // задали функцию, которую он выполняет, найдя открывающийся тег. В первую переменную парсер передает себя, т.е. $parser, вторым элементом он передает имя тега, который он нашел, что открывается - в ВЕРХНЕМ  регистре, и третьим параметром он передаст массив атрибутов этого тега, названия и значения

 Функция для обработки закрывающего тега должна иметь два атрибута, называть как угодно, но 2 
function FunctionName($xml, $tag){} //себя передает и имя тега

 Функция для обработки текстового узла должна иметь два атрибута 
function FunctionName($xml, $data){} //себя передает и найденный текст туда он запихает

//Шаг 3 Регистрация функций
xml_set_element_handler($parser, "FunctionName", "FunctionName"); // функция регистрирует работу с открывающим и зкрывающим тегами -  тут передаем имя читальщика, имя ФУНКЦИИ для начального тега и имя ФУНКЦИИ для конечного тега.

xml_set_character_data_handler($parser, "FunctionName"); // регистратор функции для работы с текстовыми узлами. Указываем имя парсера и название ФУНКЦИИ, прописанной выше для работы с текстовым узлом.

// Шаг 4 Запуск парсера
xml_parse($parser, "xml в виде строки"); // запускаем парсер, переводим файл в строку с помощью функции file_get_contents

чтение и изменение через  DOM
Читает, создает xml, представляет в виде дерева элементов - самый мощный инструмент, но ресурсы занимает. Документ как объект, все внутри - узлы
$dom = new DOMDocument();
$dom = new DOMDocument("1.0","utf-8"); // при создании нового документа xml надо прописать версию и кодировку и эти данные запишутся в xml version="1.0" encoding="utf-8"
$dom->formatOutput = true;
$dom->preserveWhiteSpace = false; // эти две строчки пишем под создающимся файлом xml, чтобы он был выстроен как надо, с иерархией

Узлы бывают такие и плюс за ними закреплены жесткие номера!:
1 - ELEMENT // элемент типа <book></book>
2 - ATTRIBUTE // атрибут элемента типа lang="ru"
3 - TEXT // текстовый узел типа труляля
8 - COMMENT // комментарий <!- типа коммент-->
9 - DOCUMENT // узел документа типа document
10 - documentType // декларация типа документа типа <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 5 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">
Есть соотношения элментов в дереве, иерархия, родительские элементы, дочерние... они пишутся через стрелу, это встроенные методы
$book->lastChild;
$dom->load("catalog.xml"); // загружает в xml-файл
$dom->loadXML($str); // закгружает в конкретную строку файла xml
$dom->loadHTMLFile($filename); // загружает в html файл
$dom->loadHTMLFile($strhtml); // загружает в строку html
$root = $dom->documentElement; // встроенный метод для выборки корневого элемента ВСЕ они РЕГИСТРОЗАВИСИМЫ
$type = $root->nodeType; // для получения типа элемента, возвращает в виде цифры- номера узла (см выше)
$children = $root->childNodes; // выборка всех потомков любого элемента, объект возвращает, с ним можо работать через foreach. Внимание! Детьми считается все, даже пробелы и переводы строк, поэтому надо делать if, чтобы устранить лишние типы
if ($book->nodeType == 1){}
echo $book->textContent; // получение текстового содержимого узла
$title = $dom->getElementsByTagName("title"); // обратиться к узлу с определенным именем
echo $title->item(0)->textContent; // получаем текстовое содержимое узла с определенным именем, item - это типа порядковый номер
$bookDom = $dom->createElement("book"); // создание нового элемента
$titleText = $dom->createTextNode("Php5"); // для создания текстового элемента своя команда
$bookDom->appendChild($titleText); // вкладываем созданные элементы. В $bookDom вкладываем titleText, можно так несколько друг в друга вкладывать
$dom->save("newfile.xml"); // сохранение объекта в документ xml

чтение через  SimpleXML
$smxl = simplexml_load_file("catalog.xml"); // конвертирует в элемент файл xml, все элементы становятся свойствами.
echo $smxl->book[0]->title; // выбрали заголовок первой книги из файла
count($smxl); // подсчитывает количество элементов
echo $smxl->book[0]->title = "xml cool"; // присвоит, но в файл не запишет, это присвоилось на уровне объектов покамест, надо переконвертировать в файл
file_put_contents("catalog1.xml", $smxl->asXML()); // конвертация в файл
$attrs = $smxl->book[0]->title->attributes(); // метод атрибутов возвращает атрибуты
echo $smxl->book->title["color"]; // возвращает значение конкретного атрибута элемента title, атрибут color
Внимание! Можно писать не по всем тегам, что там есть, а пропускать теги и через стрелочку писать пункт а и б -без промежуточных
$smxl = simplexml_load_string($str); // конвертирует в элемент строку, если там правильный код html, например:
$str = <<<LABEL
<html>
    <head>
        <title>Test</title>
    </head>
    <body>
    <p>Это <a href="#">мой сайт</a></p>
    </body>
</html>
LABEL;
В этом слчае надо вывести строку "Это мой сайт":
echo $smxl->body[0]->p->asXML();

XPATH - язык для выборок, с помощью него можно xml файл использовать как БД
$titles = $smxl->xPath("/catalog/book/title"); // возвращает все титлы в каталоге бук файла каталог
$titles = $smxl->xPath("/catalog/book/title[@id=3]"); // Возвращает по атрибуту с айдишником 3, можно использовать тут всякие and и знаки больше, всякие ! , четность и т.д., меньше, возможностей для выборки большие

XSLT
Стилевая технология для трансформации xml документа в другие форматы
Таблицы стилей XSL создаются по правилам xml-документов и состоят из набора шаблонов
Записывается так:
<?xml-stylesheet type="text/xsl" href="style.xsl"?>

Файл xsl - это xml файл и в нем прописана первая строка об этом 
и дальше описания шаблонов, туда же можно писать отрисовку в таблицах и стили
Для работы модуля xsl должен быть подключен модуль php_xsl.dll
В документе xsl теги типа, а внутри ссылки на шаблон, что означает "когда доходим до данного тега, примени к нему этот шаблон", и другие команды типа "это поменяй на это", "вот здесь напиши это" и т.д. Возможностей у него очень много


алгоритм работы с xml файлом с xsl
Обычно код файла со стилем xsl будет в виде xtml с прописанным вверху стайлом xsl, можно сделать, чтобы он отображался как простой html, уже выстроенный по правилам стайла
$xml = new DOMDocument(); // создаем объект и
$xml->load("catalog.xml"); // загружаем искомый хмл файл
$xsl = new DOMDocument();
$xsl->load("catalog.xsl"); // точно так же поступаем с xsl
$processor = new XSLTProcessor(); // создаем xsl парсер для чтения этого файла
$processor->importStylesheet($xsl); // отдаем объект, в который загружен стиль, в данном случае $xsl
$html = $processor->transformToXML($xml); // парсинг xml и получение большой строки xml файла через встроенный метод transformToXML, он возвращает строку
echo $html;

С помощью XSLT можно перегонять форматы в другие форматы. FB2 формат написан на xml, XHTML - тоже, DOCX - тоже на нем, им можно прописывать стили по xsl
transformToFB2, transformToDOCX, transformToXHTML

XMLReader
Отличие основное: 
SAX поточный
DOM - более контролируемый
XMLReader - нечто среднее, где можно останавливаться, поточный, но можно остановиться и уйти вглубь
$xml = new XMLReader(catalog.xml); // создание объекта
$xml->XML($string); $xml->open($url); // загрузка контента
$xml->read(); $xml->next(); // перемещение курсора
$xml->name; $xml->value;
$xml->nodeType; $xml->depth; // свойства элемента
$xml->expand(); // получение объекта DomNode

XMLWriter
$xml = new XMLWriter; // создание объекта
$xml->openURI('file.xml'); // созд потока часть 1
$xml->openURI('php://output'); // создание потока
$xml->startElement('book'); // создание элемента шаг 1 - открытие тега
$xml->text('book'); // создание элемента шаг 2,
$xml->endElement(); // создание элемента шаг 3, закрытие тега
$mem->openMemory(); $r = $mem->outputMemory();
$xml->writeRaw($r); $mem->flush();

Службы PHP и XML Web Service
Фактически служба - это морда, которая принимает запрос, отправляет их куда надо, получает ответ и передает его пользователю, посредник.
Обмен данными проходит в формате XML по протоколу HTTP, язык называеся WSDL
много ресурсов с веб-службами - www.xmethods.net
Там много готовых служб
RPC - штука для вызова удаленных процедур, реализована в текстовых протоколах - XML-RPC и SOAP

SOAP раcширение для создания служб и клиентов к ним. Перевод - простой протокол доступа к объектам.
Запросы посылаются ХТТП методом ПОСТ
Этот запрос имеет структуру, у него как бы конверт - корневой элемент Envelope, у которого есть заголовки и боди. Выглядит оно как xml-строка, типа:
<soap:Envelope xmlns:soap="http://schemas.xmlnsoap.org/soap/envelope/">
    <soap:Body>
        <getStock xmlns="http://site.ru/ws">
            <num>12345</num>
        </getStock>
    </soap:Body>
</soap:Envelope>
Ответ SOAP идет подобный по виду, с элементами, заголовком, боди...
Надо подключить php_soap.dll, в нем есть основные классы:
SoapClient - для создания SOAP-клиента
SoapServer - SOAP-сервера
SoapFault - обработка об ошибках
и др мелкие классы

АЛГОРИТМ создания SOAP сервера
Шаг 1. Описание службы
function getStock(){}
Шаг 2. Отключение кэширования WSDL документа
ini_set("soap.wsdl_cache_enabled", "0");
 // это только при разработке, а когда сервер выкладываешь, то его надо будет включить
Шаг 3. Создание SOAP сервера
$server = new SoapServer("stock.wsdl"); // тут лучше прописывать полный адрес, если даже он в одной папке
Шаг 4. Добавление функции как метода сервера
$server->addFunction("getStock"); // указываем конкретные функции, ведь их может быть много и не все должны быть методами сервера Соап. 

ВНИМАНИЕ! Метод addFunction вызывается только один раз, поэтому если несколько функций, то сначала их имена вносим в массив и потом этот массив передаем в addFunction
$arr = array("foo1","foo2");
$server->addFunction($arr);
Если подход не процедурный, а ООП то функцию надо запихать в класс. Было:
function getStock($num)
{
    $stock = array(
            "1"=>100,
            "2"=>200,
            "3"=>300,
            "4"=>400,
            "5"=>500,
        );
    if (array_key_exists($num, $stock)) {
        return $stock[$num];
    } else {
        return 0;
    }
}
стало:
class StockService {
function getStock($num)
{
    $stock = array(
            "1"=>100,
            "2"=>200,
            "3"=>300,
            "4"=>400,
            "5"=>500,
        );
    if (array_key_exists($num, $stock)) {
        return $stock[$num];
    } else {
        return 0;
    }
}}
плюс добавляем регистрацию класса
$server->setClass("StockService"); // пишем это вместо addFunctions

Шаг 5. Запуск
$server->handle();

Документ WSDL читается снизу вверх.

**** АЛГОРИТМ создания SOAP клиента ****
Шаг 1. Создание soap клиента
$client = new SoapClient('http://site.ru/stock.wsdl'); // все методы из указанного wsdl становятся методами объекта и мы через объект можем обращаться к функции, например
$res = $client->getStock("2");

var_dump($client->__getFunctions()); // на случай, если мы не умеем читать файл wsdl и получаем информацию о методах и параметрах из этого файла, ведь теги там - это методы и параметры

Серверная часть, обработка ошибок
throw new Exception("Server", "Несуществующий id товара");
Клиентская часть
try {
    $client = new SoapClient("stock.wsdl");
    $result = $client->getStock("7");
    echo "Текущий запас: ", $result;
} catch (SoapFault $exception) {
    echo $exception->getMessage();
}

XML-RPC
Старый, но Вордпресс его поддерживает, он поддерживет около 10 типов данных. В нем не используется wsdl и параметры надо передавать подробно, например такой запрос:
<?xml version="1.0"?>
<methodCall>
    <methodName>getStock</methodName>
        <params>
            <param>
                <value><i4>3</i4></value>
            </param>
        </params>
</methodCall>
RPC-ответ:
<?xml version="1.0"?>
<methodResponse>
    <params>
        <param>
            <value>
                <i4>600</i4>
            </value>
        </param>
        <param>
            <value>
                <string>Sony</string>
            </value>
        </param>
    </params>
</methodResponse>

Алгоритм XML-RPC сервер
Должен быть подключен php_xmlrpc.dll
Шаг 1. Описание службы
function get_Stock($methodName, $args, $extra){} // передается 3 параметра, сервер считывает пришедшие данные и в первый параметр передает метод, во второй - параметры, которые пришли, третий параметр - можно еще что-то.

Шаг 2. Создание XML-RPC сервера
$server = xmlrpc_parser_create();

Шаг 3. Добавление функции как метода сервера
xmlrpc_server_register_method($server, "getStock", "get_Stock");// когда придет запрос на метод getStock, дернуть функцию get_Stock
Шаг 3. Прием запроса
$req = file_get_contents("php://input"); // это не постом приходит, как при отправке формы, а тут надо отлавливать сырые данные. 
Шаг 4. Запуск службы
echo xmlrps_server_call_method($server, $reg, $null);

Алгоритм XML-RPC клиент
Шаг 1. Создание XML-RPC запроса 
xmlrpc_encode_request("getStock", array($id)); //  метод getStock дернуть и передать параметр
Шаг 2. Запрос и прием XML-RPC ответа
$request = запрос_методом_POST($url);
Как заслать методом ПОСТ без формы. Там свои прибабахи

ВНИМАНИЕ! ТЕМУ ДО КОНЦА НЕ ИЗУЧИЛА

Шаг 3. Получение ответа
$result = xmlrpc_decode($request);
Отслеживание ошибки
xmlrpc_is_fault($req); // возвращает тру или фолс

ПРОДОЛЖЕНИЕ далее

Графика в PHP
Нужна библиотека GD2 
Расширение php_g2.dll
Поддерживает gif, jpeg, png

<img src="create_imagae.php" alt=""> <?php // запись img при этом 
$img = imageCreate(500, 300); // создание картинки, возвращает дискриптор данной картинки, 500 - ширина, 300 - высота, для гифа только
$img = imagecreatetruecolor(width, height); // для создания цветных
header("Content-Type: image/gif"); // передача заголовка, чтобы браузер воспринимал файл php как указанный, это делаем до создания конкретной картинки, но после свойств картинки -
imagegif($img,"test.gif"); // создание конкретной картинки, передаем дискриптор, для других форматов в конце просто png, jpeg, если указан второй параметр, то картинка сохраняется на диске по указанному пути и имени
imagejpeg($img, "test.jpg", 90); // для жпегов можно указать третьим параметром сжатие, но в это случае оно не отдается в браузер, т.к. указывается второй параметр и оно сохраняется а диск... В этом случае второй параметр надо оставить пустым ""
imageantialias($img, true); // работает только при imagecreatetruecolor, это сглаживание
$red = imagecolorallocate($img, red, green, blue); // в цифрах. возвращает индекс цвета
imageline($img, x1, y1, x2, y2, color); // функция нарисовки линии
imagerectangle($img, x1, y1, x2, y2, color); // прямоугольник imagefilledrectangle - залить
imagepolygon($img, $points, 3, color); // многоугольник, но нужен массив точек $points, из него можно использовать не все, а несколько точек, это третий параметр, filled - залитый
imageellipse($img, cx, cy, width, height, color); // окружность, cx, cy - х и у центра, вторые - предполагаемая ширина и высота прямоуг, в который вписан эллипс filled - залитый
imagearc($img, cx, cy, width, height, start, end, color); // дуга, старт - градус начала и конца
imagefilledarc($img, cx, cy, width, height, start, end, color, style); // последним параметром передаем одну из констант: IMG_ARC_PIE - кусок пирога, IMG_ARC_CHORD - хорда, IMG_ARC_NOFILL - не залитая дуга, IMG_ARC_EDGED - тоже пирог, IMG_ARC_NOFILL | IMG_ARC_EDGED - незалитый сектор
imagestring($img, font, x, y, string, color); // font - размер текста не в пикселях, х и у - точка начала текста, верхняя левая - но это гемор
imagettftext($img, size, angle, x, y, color, fontfile, text); // тут уже сайз в поинтах, англ - угол наклона,  х и у - нижняя левая точка и шрифт можно любой
imagecreatefrompng(filename); // не с нуля картинку, а поверх существующей рисовать, png, jpg, gif

Socket Сетевое программирование
$s = fsockopen("localhost", 80, $e1, $e2, 30); // через другой файл можно отправить сокетом данные методом post, 80 - порт, е1 - код ошибки, если будет ошибка, е2 - описание ошибки, 30 - таймаут в сек, если зависание, то соединение прерывается, первый параметр - то, куда посылать
$str = "name=John&age=25"; // post-строка
$out = "POST /file.php HTTP/1.1\r\n"; // посылка http запроса file.php - конкретная страница, куда шлем
$out .= "Host: localhost\r\n";
$out .= "Content-Type: application/x-www-form-urlencoded\r\n"; // без этого он придет не в пост, а в пост роу дата
$out .= "Content-Length: ".strlen($str)."\r\n\r\n";
$out .= $str."\r\n\r\n";
fputs($s, $out); // отправляем
while (!feof($s)) { // получение и вывод ответа пока есть что читать из потока $s
    echo fgets($s)."<br>";
}
fclose($s);
***** Функции сетевого программирования *****
$hostname = gethostbyaddr('127.0.0.1'); // узнать имя хоста
$ip = gethostbyname('www.lol.org'); // возвращает ip
$hosts = gethostbynamel('www.lol.org') // если несколько айпишников, то эта ф-ция возвращает массив их
$port = getservbyname("http", "tcp"); // вернет порт, на котором висит служба
$serv = getservbyport(80, 'tcp'); // возвращает протокол по номеру порта

UML - язык моделирования 
универсальный 
Сложный, состоит из всяких там схем и стрелочек

Шаблоны проектирования
Design Patterns
1. Основные шаблоны (Fundamental)
    Delegation pattern / Шаблон делегирования
    Functional design / Шаблон функционального дизайна
    Immutable / Неизменяемый объект
    ...
2. Порождающие шаблоны проектирования (Creational)
    Factory Method / Фабричный метод
    Abstract Factory / Абстрактная фабрика
    Builder / Строитель
    Prototype / Прототип
    Singleton / Одиночка
    ...
3. СТруктурные шаблоны (Structural)
    Adapter / Адаптер
    Bridge / Мост
    Composite / Компоновщик
    Decorator / Декоратор
    Facade / Фасад
    ...
4. Поведенческие шаблоны (Behavioral)
    Mediator / Посредник
    Observer / Наблюдатель
    Strategy / Стратегия

Singleton
Идея в том, чтобы соорудить класс, от которого можно воспроизвести только один объект, все свойства там приватные, из вне не вызовутся
class DBConn { // например класс для бд, где описывается процесс соединения
    const DB_NAME = 'mydb.db';
    private $_db; // Шаг 0 для Синглтона - заводим переменную, в которую будет попадать создаваемый единственный экземпляр объекта
    static private $_instance = null; // Шаг 1 для Одиночки: создается приватный статический инстанс, в котором пусто, нул
    private function __construct() // Шаг 1.1, функцию констракт делаем приватной, в ней описывается действие, подключение к датабазе
    {
       $this->_db = new SQLiteDatabase(self::DB_NAME); // экземпляр новоиспеченного объедка попадет в _db
    }
    private function __clone() // Шаг 2 для Одиночки - приватим клон, чтобы исключить, запретить копирование 
{}
    static function GetInstance() // Шаг 3. для Одиночки - статический метод ГетИнстанс, в котором проверка, есть ли уже экземпляр или нет
    {
        if (self::$_instance == null) { 
            self::$_instance = new DBConn(); // если там пусто, то создаем в инстансе экземпляр класса, если там не пусто, то он уже создан, значит просто его возвращаем, и если создали, то тоже возвращаем
        }
        return self::_instance; // возвращаем
    }
    public function GetDB($value='')
    {
        # code...
    }
}
$db = new DBConn(); // выдаст ошибку, т.к. там приват
$db = DBConn::GetInstance; // вот такое создание объекта будет, либо уже готового, либо нового
$db->GetDB();

Factory
Идея в том, что существует абстрактный класс с описанием или без, от которого наследуется несколько других классов с перегрузкой методов мона, и еще есть отдельный класс с методом, через который задается принцип, чего с детьми его делать
Strategy
Очень похож на Фактори, только в итоге не объект возвращает, а дело, действия
Существует абсрактный класс с описанием, от которого наследуются дру классы. И есть класс-стратег, в котором под протектедом стоит элемент, в который мы в определенном случае передаем определенный экземпляр объекта и в нем же функция, что с этим экземпляром делать, ссылаясь на метод из класса того экземпляра
Обращаемся к стратегу
Адаптер
как нечто между двумя классами, но не наследник
Декоратор
Сцена одна - декорации разные


SPL
spl_classes(); // возвращает массив имен интерфейсов и классов, которые доступны, этот список есть и в php info
$func = function ($value) // анонимная функция (лямбда-функция), а в переменную $func вернется объедок
{
    echo "Hello, $value!";
};
$func('John'); // вызываем анонимную функцию
$newarr = array_map('foo', $arr); // возвращает массив, каждый элемент которого пропускает предварительно через указанную функцию 'foo'
$newarr = array_map(function($v){return $v * 10;}, $arr); // использование анонимной функции
function () use(&$str){echo $str;} // c помощью use функция хватает и использует переменную, объявленную вне ее. Но! Она ее хватает в таком виде, в котором она стоит до этого юза, чтоб видела - надо использовать & - амперсант
$add = function($num){return function($v) use($num) {return $v + $num;};}; // зацикленная функция, клосетная анонимная, то бишь что-то через нее пропускают, а потом если этому чему-то передать значение, то она его схавает и выполнит далее
$add2 = $add(2); // вернет function($v) {return $v + 2}
$add2(5); // вернет 5 + 2

Интерфейсы SPL
Это коллекция интерфейсов и классов для решания типичных проблем php - сплетения из изобретенных велосипедов

Итератор Iterator
По большому счету это шаблон
Это как бы форич по косточкам, внутри него можно менять, все этапы форича записаны в описании объедка, объедок возвращает массив и остается его профорычить для вывода. Сам код короче делается.
Нужно сделать класс и наслеловать его от Iterator, перегружая методы:
состав (публичные функции):
rewind // присваиваем начальной точке что-то
key // возвращает скалярное число - выбираем ключевой ключ, над которым будут совершаться все действия
current // возвращает само действие, что к ним делать, увеличивать, уменьшать, умножать и т.д.
next // какой следующий элемент, например ++
valid // возвращает тру/фолс - условие, до коле должен крутиться цикл, пока что-то меньше чего-то, например

Интефейс Serializable
Это фактически перегрузка стандартного сериалайза
Когда надо сериализовать массив, в который входит приватная переменная из родительского объекта
Нужно этот класс сделать implements Serializable

Observer Наблюдатель
Используется вместе с интерфейсом SplSubject. Создается два объедка, один из них - подписчик, второй - источник. Если в источнике что-то меняется, то объект подписчик об этом узнает автоматом.
Состав его:
attach(SplObserver $o); // присоединяет наблюдаттеля, т.е кладет его в первый элемент массива
detach(SplObserver $o); // удалитель наблюдателя с проверкой если он есть
notify(); // передает сообщение наблюдателю, вызывает метод update


ArrayAccess
С его помощью с объектом можно работать как с массивом, без стрелочек там, обращаться через квадратные скобки
Нужно сделать класс и имплементировать его от ArrayAccess, перегружая методы:
Состав:
offsetExists // возвращает тру/фолс, иссетом проверяет, есть или нет
offsetGet // возвращает какой-то элемент массива
offsetSet // передать какое-то значение в элемент массива
offsetUnset // удаление

IteratorAggregate
Наследует Traversable. Это как бы обертка для простого итератора. Указываем итераторы, которые надо использовать для объекта

ArrayIterator
Создает итератор из массива. Он наследует много других интерфейсов - Iterator,Traversable,ArrayAccess,SeekableIterator,Countable,Serializable, их методы все доступны и их можно использовать, соответственно
Но он работает только с одномерным массивом, для многомерного есть другой итератор, который наследует ArrayIterator. Это RecursiveArrayIterator

** RecursiveIteratorIterator **
Нужен для форича многомерного массива. Простой форич пройдется только по верхам, в него передаем RecursiveArrayIterator, в нем есть полезнфй метод, позволяющий узнать, на каком уровне мы находимся

** FilterIterator **
Например, из массива выбрать некий отрезок от какого-то до какого-то значения
Фильтр итератора. Использует метод accept() с условием фильтрации, возвращает тру/фолс. Внутри accept обращение к getInnerIterator().

** DirectoryIterator **
Сообщает инфу по папке и файлам в ней хранящимся. Наследует SplFileInfo

** SimpleXMLIterator **
Для работы с SimpleXML

** SplFileInfo **
Сообщает инфу о файле, для этого просто надо создать экземпляр объекта SPLFileInfo и передать туда файл
$fileinfo = new SPLFileInfo(FILE_Name); // и по его методам можно выдергивать размер, тип файла, т.д....

** SplFileObject **
Попытка под одно крышей собрать все файловые функции. Тут не просто дает инфу по файлу, но и зачитывает, действия с файлом...
Расширяет SplFileInfo По файлу и его содержимому, зачитывает и т.д., куча методов

** ArrayObject **
Обратный ArrayAccess, тут идея в том, чтобы с массивом работать как с объектом

** SPLObjectStorage **
Как бы корзинка, хранилище для объекта или коллекция разных объектов. Наследует ArrayAccess,Serializable,Traversable,Iterator,Countable
Объект в качестве ключа массива

Очереди SplQueue
Есть SplDoublyLinkedList, он наследует Iterator,Countable,ArrayAccess
Есть SplQueue, наследует SplDoublyLinkedList
Сооружается очередь созданием объекта SplQueue
Типа очередь из дел - прочитать книгу, сходить в магаз... выстраивает, можно с приоритетом

** SplFixedArray **
Массив с фиксированной длиной. Через создание объекта, в скобках указываем длину массива, кол-во ячеек, уменьшает количество занимаемой памяти массивом


InfiniteIterator
Бесконечная итерация. Наследует IteratorIterator со всеми фичами, например для посылания запросов, когда надо ходить бесконечно. Им можно симитировать событие онклик

iterator_count(); // считает количество элементов итератора
iterator_apply(iterator, function); // позволяет установить функцию обратного вызова, аналог аррэй_мэп, только по итератору, а не масссиву
iterator_to_array(iterator); // вернется массив из итератора
spl_autoload_extensions('.php'); // задавать разные расширения
spl_autoload_register(); // он ищет файл с именем класса и заданным расширением, инклюдит на лету файл с описанием класса. Можно туда передать описанную функцию и он ее вызовет автоматом, если пустая, то файл ищет в папке. Работает последовательно. Если третьим параметром передать true, то у нее приоритет, ее первее (вторым фолс)
spl_autoload_functions(); // возвращает зарегестрированные автолоадом функции
spl_object_hash(); // возвращает уникальный хэш для объекта, у ссылок на один объект одинаковые хэши. Но хэш одноразовый

PHP Data Objects
Облегчает работу с БД. Идея его в том, чтобы уравнять все БД, чтобы все было единообразно, т.к. в разных БД разные правила.
Набор драйверов, констант и классов БД.
Работает через создание класса PDO
Классы:
PDO, PDOStatement, PDOException
PDO поддерживает большое количество всего, всех баз данных и т.д.
foreach (PDO::getAvailableDrivers() as $driver) {
   echo $driver."<br>"; // способ вывести подключенные драйверы PDO в PHP
}

Подключение к БД
$conn = new PDO("mysql:host=$host;dbname=$db",$user,$pass); // универсальный код PDO для подключения к БД MySQL и выбора БД вместо типичного mysql_connect($host,$user,$pass); mysql_select_db($db);
$conn = new PDO("sqlite:/path/database.db"); // подключение для SQLite
$conn = new PDO("sqlite::memory:"); // для соединения с SQLite на лету, бд создается на момент сеанса в памяти
$conn = new PDO("pgsql:host=$host dbname=$db",$user,$pass); // подключение к бд для PostgreSQL
$conn = new PDO("OCI:dbname=mydatabase;charset=UTF-8","username","pass"); // для соединения с БД Oracle
$conn = new PDO("odbc:Driver={Microsoft Access Driver(*.mdb)};Dbq=C:\database.mdb;Uid=Admin"); // для ODBC
$conn = new PDO("firebird:dbname=hostname:C:\path\to\database.fdb","username","pass"); // для Firebird
$conn = new PDO("informix:DSN=InformixDB","username","pass"); // для Informix
$conn = new PDO("dblib:host=hostname:port;dbname=mydb","username","pass"); // для DBLIB

Подключение через ini файл
в файле config.ini пишем:
db.conn="mysql:host=localhost;dbname=test"
db.user='vasya'
db.pass='parol'
В нужном php пишем
$params = parse_ini_file("config.ini");
$conn = new PDO($params['db.conn'],$params['db.user'], $params[db.user],$params['db.pass']);

Выполнение запроса к БД
$result = $conn->exec($sql); // где conn - подключалка, см выше, sql - запрос, exec возвращает количество строк, над которыми было выполнено действие НО! SELECT с ним не работает

Выборка данных из БД
$res = $conn->query($sql); // где conn - подключалка, см выше, sql - запрос типа селект

Отслеживание ошибок
try {
    $dbh = new PDO('pgsql:dbname=wrong;host=localhost' ,'user','pass');
} catch (PDOException $e) { // отслеживание ошибок через тру кэч
echo $e->getMessage();
}
$conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
$conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING); // можно выбрать уровень варнинга
$conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT); // подавление ошибок, то бишь он молчит, не показывает ошибку
$conn ->errorCode(); // код ошибки
$conn ->errorInfo(); // инфа об ошибке

Фильтрация строк
$name = "O'Brian"; // например, имя требует фильтра
$name = $conn->quote($name);
$result = $conn->query("SELECT * FROM users WHERE name='name'");
quote, иными словами, из всего сделает строку, будь там написан даже код, селект какой-нибудь , даже с коментами (чем пользуются хакеры) - он не пройдет, отфильтруется и будет как строка

Fetch
$res = $conn->query($sql); // запрос выполняем и потом
$result = $res->fetch(PDO::FETCH_ASSOC); // ассоциативный
$result = $res->fetch(PDO::FETCH_NUM); // нумерованный
$result = $res->fetch(PDO::FETCH_BOTH); // двойной
$result = $res->fetch(PDO::FETCH_OBJ); // вернет объект
$result = $res->fetch(PDO::FETCH_LAZY); // совокупность двойного и объекта, можно и по индексу и как к объекту обращаться
$result = $res->fetchALL(PDO::FETCH_CLASS,'User'); // в отличие от простого фетча, вытаскивает все записи без вайла
$result = $res->fetchObject('User'); // возвращает конкретный объект, экземпляр класса
$result = $res->setFetchMode(PDO::FETCH_INTO,$user); // если объект уже существует, в него что-то положить. $user - объект, в который кладем

Подготовленные запросы
$id = 5; // допустим значение id
$result = $res->prepare("SELECT * FROM users WHERE id = :id AND name = :name"); // обозначение общее, вместо :id :name сюда что-то будет приходить
$result->bindParam(':id',$id,PDO::PARAM_INT); // привязка параметров, указывается тип в конце
$result->bindParam(':name',$name,PDO::PARAM_STR); // привязка
$result->execute(); // запуск подг запроса

или:
$sql = "SELECT * FROM users WHERE id = :id AND name = :name"
$stmt = $db->prepare($sql);
$stmt->execute(array(':id'=>5, ':name'=>'John')); // запрос и сразу описываем, что где в виде массива

Транзакции
$data = array('id'=>1, 'name'=>'Ivan');
$stmt = $conn->prepare("SELECT * FROM users Where id = :id AND name = :name");
$stmt->bindParam(':id',$id,PDO::PARAM_INT);
$stmt->bindParam(':name',$name,PDO::PARAM_STR);
$stmt->execute($data);

Связывание полей таблицы
$sql = 'SELECT id, name, email FROM users';
$stmt = $conn->prepare($sql);
$stmt->execute();
$stmt->bindColoumn(1, $id); // прописываем, что из колонки 1 попадает в колонку $id
$stmt->bindColoumn(2, $name); // прописываем, что из колонки 2 попадает в колонку $name
$stmt->bindColoumn('email',$email); // прописывать можно и не по номерам, а по именам. Пишем, что из колонки email попадает в $email

Reflection
Состоит из интерфейса Reflector и класса Reflection

Reflection::export(new ReflectionFunction('FooNane')); // статический метод export класса Reflection возвращает полную инфу по выбранной функци, где описана, что принимает, что отдает...

$func = new ReflectionFunction('SayHello'); // рефлектит функции
printf(
    "<p>====>%s функция '%s'<br>". // %s - формат строковый
    "------объявлена в %s<br>".
    "------строки с %d по %d", // %d формат типа числа
    $func->isInternal() ? 'Internal' : 'User', // метод isInternat возвращает тру фолс - встроенная или не встроенная функция. Здесь если встроенная, выводим интернал. если нет - юзер
    $func->getName(), // имя функции, которое пойдет в '%s'
    $func->getFileName(), // имя файла, где функция находится
    $func->getStartLine(), // цифра строки начала функции
    $func->getEndLine() // цифра строки конца
    );
if($static = $func->getStaticVariables()) // метод getStaticVariables за статические переменные, если в этой функции есть статическая переменная, то написать ее со значением.
    echo "<br>".var_dump($static);
echo $func->invoke('John','1');  // метод invoke вызывает саму функцию с переданными параметрами
$func->getDocComment(); 
$func->getNumberOfParameters(); // количество параметров
$func->getNumberOfRequiredParameters(); // количество обязательных параметров
$func->getParameters();
$func->isUserDefined();
$func->returnsReference();
$param->allowsNull(); // допустим ли Нулл в параметре
$param->isPassedByReference(); // передан ли параметр по ссылке
$func->isOptional();// является ли опциональным параметр - bool
$refm = new ReflectionMethod('ClassName','methodname'); // Рефлектит методы. Наследует ReflectionFunctionAbstract, reflector
$refm->isAbstract(); // абстрактный ли
$refm->isFinal(); // финальный ли
$refm->isPublic(); // паблик ли
$refm->isProtected(); // протектедный ли
$refm->isPrivate(); // приватный ли
$refm->getModifiers(); // модификаторы
implode(' ', Reflection::getModifierNames($method->getModifiers())); // выведет конкретные имена модификаторов
Reflection::export(new ReflectionClass('Exception')); // возвращает всю инфу по классу, можно встроенные даже так просветить
ReflectionObject // рефлектит объект
ReflectionProperty // рефлектит свойства методов
ReflectionExctention // расширения, например SQLite и т.д., что подключается в расширениях
Reflection::export(new ReflectionExctention('standard')); // если стандард, то дает инфу по всем встроенным функциям, константам
get_declared_classes(); // возвращает все существующие классы, например, из интерфейса

PEAR
Это библиотека PHP - приложений. В виде пакетов. Набор php-скриптов. Расширение PHP PECL
Оформлены по определенным стандартам
Статусы: Dev (стадия разработки, экспериментальная версия), A (альфа, нестабильная версия), B (бета - более менее стабильная версия), RC (релиз кандидат - почти готовая версия), Pl(исправленная версия, редко)
Чтобы установить, в php.ini должен быть прописан путь к папке с пиром - include_ppath = ".;путь\PEAR"
Пиры на сайте pear.php.net/go-pear
Нужна Cli-версия PHP
Есть еще phpDocumentor www.phpdoc.org

Регулярные выражения
PCRE и POSIX
Формат определения шаблонов:
<разделитель><шаблон><разделитель>[<модификаторы>]
Разделитель "/"("|","@")
Используются для этого еще разные функции. Например,
$result = preg_match($pattern, $subject[,$natches]); // функция поиска, возвращает тру-фолс, нашел или нет, или если указать последний параметр, то возвращается массив с результатами поиска
preg_match_all(pattern, subject, matches); // выполняет поиск всех совпадений ваще
preg_grep(pattern, $arrayy) // поиск в массиве, вместо строки
preg_replace($pattern, $replacement, $str); // функция замены
preg_split($pattern, $str, 2); // разделяет на части. Указть рег выражение, строку и вернется массив из частей, третьим параметром можно передать ограничение количества частей, разбивает так же, только возвращает первые эн элементов
сайт по регулярным выражениям для тренировки - 
regexlib.com 
Там есть готовые велосипеды

В помощь имеются:
Метасимволы
Спец. последовательности символов
Модификаторы
Функции -поиска, -замены, -разделения на части

Метасимволы:
\ экранирование метасимволов и разделителей, внутри них можно писать те же +,* всякие и это не будет означать метасимволы, а будет означать текст, что мы ищем *,+ и т.д.
. любой символ, кроме символа перевода строки
/ разделители, мы говорим, где началось, где закончилось
? либо 0, либо одно совпадение
+ одно или более совпадений, минимум одно
* 0 или более совпадений, от 0 до бесконечности
{m},{m,n},{,m},{n,} указать количество, точное, от m до n, от 0 до m, от m до бесконечности...
^ граница начала, начинаться должно со следующих за ней символов. НО если она в квадратных скобках перед символами, означает ОТРИЦАНИЕ, КРОМЕ
$ граница окончания, чем заканчиваться должно
[] класс искомых символов, диапазон, например [12] означает 1 или 2, [0-9], [a-z], [A-Z], сочетать все можно [^0-9]+, молификаторы должны идти за границей скобок, галка и тире только могут быть внутри
() группировка элементов типа сначала это, потом отдельно это. И он кладет результат в разные ячейки массива. Это кармашки еще называются. Они за кадром нумеруются автоматом $1,$2 - по этому можно вытянуть
(?:...) участок строки, который не должен попадать на выход (?:ith)
(?P<имя>) задается именованный вложенный шаблон, ячейка на выходе будет под этим именем
\d спец символ, означает [0-9]
\D спец символ, означает [^0-9]
\s означает любой пробельный символ типа \n,\r, сам пробел и т.п [\t\n\f\r]
\S все, кроме, т.е. [^\t\n\f\r]
\w любая буква, цифра или символ подчеркивания
\W все, кроме см выше
\b то, что между символами \w и \W
\B противоположность \b
i говорим о том, что надо игнорировать регистр символов /[a-z]/i = /[a-zA-Z]/
m многострочный поиск, типа искать после символа \n
S однострочный поиск, ищеттолько по первой строке
x пропуск пробелов и комментариев (#) в тексте шаблона
D если строка не заканчивается на \n
U ленивость по умолчанию, то есть '/<a.*?>(.*?)</a>/' = '/<a.*>(.*)</a>/U'
u включить режим кодировки utf8

preg_match('/./', 'PHP5', $matches); // в массив $matches вернется первая буква заданной строки - $matches = [0] => P, ищем мы любой символ, начиная с первого берется один символ первый.
preg_match('/PHP.?5/', 'PHP 5', $matches); // совпадение со строкой "PHP5" и со строкой "PHP 5", т.к. между словами может быть любой символ или 0 или одно совпадение
preg_match('/a+b/', 'caaabc', $matches); // даст aaab. C этим шаблоном (a+b) могут совпадать строки "ab", "aab", "aaaaaab"
preg_match('/de*f/', '...', $matches); // этому шаблону соответствуют строки: "df", "def", "deeeef" и т.д.
preg_match('/^ghi/', 'bknghill', $matches); // соответствует ghill и ghi
preg_match('/John$/', '...', $matches); // пройдет "Mike, John", "Mike, John\n", но не John Smith
preg_match('/([A-Za-z]+)(?:ith)/', 'John Smith', $matches); // дает $matces = [0]=>John Smit,[1]=>John Sm
preg_match('/\b.+\b/', '###Test123###', $matches); // даст $matches = [0]=>Test123
preg_match('/<a.*>(.*)</a>/', '<a href="..."PHP</a>has lol bla bla bla <a href="nla.tu">kku</a>', $matches); // выберет все  до конечного </a>, чтобы он выбрал только первую ссылку, нужно писать так: '/<a.*?>(.*?)</a>/', что означает ограничение в одно 

Пространство имен Name Space
namespace MY_NS {}; // объявляем пространство имен под определенным именем и внутри писать любые функции, которые могут совпадать с именами встроенных функций, strlen, например... и они будут принадлежать этому пространству имен.
Внимание! Объявлять надо пространство имен перед всем, вначале документа, перед ним ничего не должно быть
Мона их объявлять в отдельном файле
Перед использованием функций из пространства имен, надо испльзовать use ИМЯ_ПРОСТР
или сделать фигурные скобки
namespace {
    MY_NS\strlen();
}
Синтаксис не определен, но смешивать способы отображения нельзя, будет ошибка
__NAMESPACE__ - псевдоконстанта, возвращает имя пространства

Модульное тестирование  unit testing
Проверяет на корректность определенные модули
PhpUnit это делает. Его нужно устанавливать через cmd, как peer www.phpunit.de

xDebug
для отладки. xdebug.org
Подключается просто, файл dll надо прописать в php.ini, если нет, то добавить файл

MVC
Модель. В нем контроллер, который все разруливает. В зависимости от ситуации он выбирает ту или иную модель поведения. 
Серверная часть
Запрос на какой-то файл в адресной строке типа /path/to/somefile.php
будет вида:
/controller/action[/key 1][/value 1]...[/key n][/value n] // первым пищется имя контроллера, потом имя экшена, потом факультативно можно передавать какие-то ключи и их значения

Приложение (внутренности)
- контроллер (интерпретация переменных, направление исполняемого кода)
- actionControllers (action=method, создает моделей, шаблонов парсинг, вывод результата)
- models (классы-утилиты)
- views (шаблоны)

Структура
- папка style со стилями
- папка images с изображениями
- файл .htaccess
- index.php
- папка application, внутри нее лежат папки controllers, models, views

Точка единая входа называется бутстрап файл. Это index.php в корне

Создается Главный Контроллер, FrontController, который обычно не прописывается вручную, там прописано принятие параметров из адресной строки и раскидывание их по "кармашкам" - где будет контроллер, где экшен, где ключи и значения.

В точке входа главный метод Фронтконтроллера надо проинициализирвать:
$front = FrontController::GetInstance();
$front->route();
echo $front->getBody();

Фреймворки
Чтобы не залезать внутрь, но использовать, что-то уже описано. В отличие от cms это система создания и редактирования самой cms
Самый мощный - Zend Framework, но медленный, надежный
Code Egniter - тоже хорош, документация хор, но описан с оглядкой на 4 php, а пятый не особо
Cohana - продолжение Code Egniter для пятого только, но там документация хреновая
FatFree Framework - документация хорошая
slimframework - самый мелкий фреймворк

Система управления версиями
Для работы в коллективе, когда все над одним проектом, все меняют одновременно и т.д.
Subversion
subversion.apache.org
TortoiseSVN интерфейс для него, а так он по командной строке

REST-сервисы
Для обращения к службам
В отличие от soap, rpc, REST - это подход
Данные могут передаваться в любых форматов, не только xml

JSON 
В php встроены функции для работы с Json

$val = array("abc" => 12,
            "foo" => "bar",
            "bool" => false,
            "bool1" => true,
            "arr" => array(1,2,3,null)
);
$str = '{"add": 12, "foo": "bar"}';
$output = json_encode($val); преобразует все в JSON строку
$in = json_decode($str); наоборот, преобразует строку из JSON в объект, массив













/********************************
********* Быстрый старт *********
********************************/
Шаг 1. создаем папку с новым локальным сайтом
Шаг 2. 
Скачиваем последнюю версию wordpress с сайта wordpress и распаковываем прямо в корень, чтобы в корне были сразу всякие wp-admin-ы и др. файлы

Шаг 3.
Заходим в phpMyAdmin и создаем новую БД. Присваиваем ей имя и задаем кодировку UTF8 unicode ci

Шаг 4. Делаем Fetch my-wp

Шаг 5. Заходим в корень папку, открываем файл wp-config. Далее идем на сайт https://api.wordpress.org/secret-key/1.1/salt/ и копируем весь сгенерированный текст
Вставляем текст на месте похожего текста (куча define-ов)
Сохраняем файл wp-config

Шаг 6. Далее надо в браузере просто перейти на адрес нашего сайта - выходит WP окно c 5-минутной установкой

Шаг 7. Идем в wp-content -> themes -> new. Переименовываем папку именем нашего сайта. 

Шаг 8. Копируем папки img, js, css, pixLayout из проекта в папку темы. Из папки sass вытаскиваем файл и он должен быть в теме голым, без папок, как и style.css!
После перекопирования sass, вставляем в него строки о теме, обязательно:
/*  
Theme Name: Almazka-Master
Theme URI:
Description: Theme for portfolio Almazka-Master
Version: 1.0
Author: Aliona
Author URI: almazka-master.tk
*/

Шаг 9. Открываем файл index.php в папке темы и копируем туда содержимое body из файла, где верстали. Переименовываем все пути, как сказано в памятке, в index.php и убираем памятку.

Шаг 10. Заходим на сайт, оказываемся в админке и применяем нужную тему. Смотрим, как отображается сайт.
<div></div>
********************************
********** Настройка **********
********************************
Шаг 1.
Сперва устанавливаем сервак Apache, MySQL, PHP по нинструкции - http://gansik.ru/ubuntu/ustanovka-i-nastroyka-apache-php-mysql-phpmyadmin-na-ubuntu-14-04-lts/

Плюс на этапе захода в phpMyAdmin - добавляем в файлик sudo nano /etc/apache2/apache2.conf
Include /etc/phpmyadmin/apache.conf
и перезагружаем апач
sudo service apache2 restart

Далее у нас уже есть папка www и в неЙ корень сайта.

Шаг 2. 
Скачиваем последнюю версию wordpress с сайта wordpress и распаковываем прямо в корень, чтобы в корне были сразу всякие wp-admin-ы и др. файлы

Шаг 3.
Заходим в phpMyAdmin и создаем новую БД. Присваиваем ей имя и задаем кодировку UTF8 unicode ci

Шаг 4.
Заходим в корень сайта. Копируем файл wp-config-sample и переименовываем его в wp-config. Открываем и редактируем.
Прописываем название созданной БД, пользователя MySQL и пароль
Далее идем на сайт https://api.wordpress.org/secret-key/1.1/salt/ и копируем весь сгенерированный текст
Вставляем текст на месте похожего текста (куча define-ов)
Сохраняем файл wp-config

Далее надо в браузере просто перейти на адрес нашего сайта - выходит WP окно c 5-минутной установкой

********************************
************* Темы *************
********************************
Темы хранятся в wp-content > themes, в папках.
Минимальный набор файлов для темы:
style.css - стили

index.php - главный файл, в него подключаются footer.php, header.php, sidebar.php

Эти два файла - основа, с их создания начинается создание темы wp

Далее создаются:
single.php - шаблон страницы по нажатию "читать далее"

page.php - шаблон постоянной страницы типа "О нас", "Контакты"

search.php - шаблон вывода результатов поиска
footer.php
header.php
sidebar.php
searchform.php
functions.php
404 - страница 404

Для создания темы создаем папку с файлами index.php и style.css

В style.css прописываем строки:
/*  
Theme Name: Almazka-Master
Theme URI:
Description: Тема для Almazka-Master
Version: 1.0
Author: Aliona
Author URI: 
*/

В index.php прописываем стандартный код:
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/11">

	<title><?php bloginfo('name'); ?><?php wp_title(); ?></title>

	<meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php bloginfo('charset'); ?>" /> 
	<meta name="generator" content="WordPress <?php bloginfo('version'); ?>" /> <!-- leave this for stats please -->

	<link rel="stylesheet" href="<?php bloginfo('stylesheet_url'); ?>" type="text/css" media="screen" />
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="<?php bloginfo('rss2_url'); ?>" />
	<link rel="alternate" type="text/xml" title="RSS .92" href="<?php bloginfo('rss_url'); ?>" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="<?php bloginfo('atom_url'); ?>" />
	<link rel="pingback" href="<?php bloginfo('pingback_url'); ?>" />

	<?php wp_get_archives('type=monthly&format=link'); ?>
	<?php //comments_popup_script(); // off by default ?>
	<?php wp_head(); ?>
</head>
<body>
	тут будем писать содержимое сайта
</body>
</html>

Переносим папки с изображениями и скриптами в папку с темой

Перекопировываем содержимое файла стилей в style.css, который лежит в папке темы

Из файла index.html из старой папки берем подключенные скрипты и переносим их в head нового index

Потом переносим содержимое body
На этом этапе графика не работает. Нужно поменять пути, потому что сайт запускается от корня, а изображения в папке темы.
Неудобно описывать всю колбасу названия, да и не универсально. Лучше пользоваться функциями Вордпресса.
Например
<?php bloginfo('stylesheet_url'); ?>
Возвращает адрес главного файла стилей темы - style.css

<?php bloginfo('template_url') ?>
Возвращает путь к шаблону, остается дополнить путь, указать папку и файл
<script type="text/javascript" src="<?php bloginfo('template_url') ?>/scripts/jquery-2.1.3.min.js"></script>
Так же прописываем адреса картинок в css файле, было прописано "../img", меняем на "./img"
И еще надо довести до ума через bloginfo('template_url') пути к картинкам в самом index.html

ВНИМАНИЕ!
На этом этапе не проканает копировать в папку темы другие папки и писать на них пути, он их не будет видеть. Все скрипты должны быть засунуты в папку scripts или js, а картинки - в images или img

Разбиение на логические части
Это хедер, сайдбар, футер
Создаем отдельные файлы под них - header.php, sidebar.php, footer.php

Переносим нужный код в файлы.
На место кода прописываем соответствующие функции
<?php get_header(); ?>
<?php get_sidebar(); ?>
<?php get_footer(); ?>

в Sidebar идет весь блок сайдбара, то есть если у тебя 
<div class="sidebars">
	<div class="sidebar"></div>
	<div class="sidebar"></div>
	<div class="sidebar"></div>
</div>
То весь его и переносим, а не отдельно sidebar

Но! Поддержку виджетов для сайдбара надо еще включить, а то не будет отображать
К сайдбару потом вернемся.

Вверху страницы появилось пустое пространство - это панель wp для админа. Чтобы она появлялась, надо в файле футера прописать функцию
<?php wp_footer(); ?>

/********************************
****** Стандартный цикл WP ******
********************************/
have_posts() - это метод объекта по умолчанию, который проверяет, есть ли записи у этого объекта
Если есть, проходимся по ним в цикле и получаем

Для каждого шаблона это свой объект - для page.php - объект со страницами, для post - с постами, для кастомных - со своими кастомными соответственно.

if ( have_posts() ) : while ( have_posts() ) : the_post(); ?>
<!-- post -->
<?php endwhile; ?>
<!-- post navigation -->
<?php else: ?>
<!-- no posts found -->
<?php endif; ?>


********************************
******** Блоговая часть ********
********************************
Статический код заменяем на динамический с функциями в цикле, например, для повторяющихся элементов div post:
<?php if(have_posts()) : ?>
	<?php while (have_posts()) : the_post(); ?>
			<div class="post"> <!-- start post -->
				<h2><a href="<?php the_permalink();?>"><?php the_title(); ?></a></h2>
				<div class="mediacontent">
					<img src="<?php bloginfo('template_url') ?>/img/slider-blog2.jpg" height="300" width="650" class="post-slider">
				</div>
				<div class="post-info">
					<div class="data">
						<h4>Date</h4>
						<p><?php the_date_xml(); ?></p>
						<h4>Tags</h4>
						<p>Website | Design</p>
						<h4>Comments</h4>
						<p>4</p>
					</div>
					<div class="text">
					<?php the_excerpt(); ?> <a href="<?php the_permalink();?>">...</a>
					</div>
				</div>
			</div> <!-- end post -->
	<?php endwhile; ?>
<?php endif ?>

А полное тело записей будет по шаблону в файле single.php

Можно добавить пагинацию с помощью плагина или стандартную

********************************
**** Постраничная навигация ****
********************************
Незамысловатая, просто в виде ссылок "Предыдущая страница - Следующая страница"
Пишется она после окончания цикла while, в котором выводятся посты
После <?php endwhile; ?>
Например, в блоке nav
<div class="nav">
	<?php posts_nav_link(); ?>
</div>
В параметрах можно указать разделитель

ПРАВИЛО ИЕРАРХИИ СТРАНИЦ WP
Если при открытии текста, например, записи, WP не найдет шаблона, по которому он должен выводиться - single.php, то он пытается вывестись. Он будет использовать ближайший шиблон более высокого уровня.

Иерархия такая:
Уровень 1
style.css
index.php

Уровень2
single.php
page.php
search.php
footer.php
header.php
sidebar.php
searchform.php
functions.php
404.php

То бишь. Допустим, мы жмем по ссылке the_permalink читать далее. Если он не находит single.php, то он пытается вывести текст статьи в шаблоне index.php

Создаем файл single.php, копируем туда код из шаблона, вносим правки, что оставить и т.д.
Вместо the_excerpt() ставим the_content()

Здесь можно поставить еще ссылки на предыдущую - последующую статью

********************************
******* Пред-след статья *******
********************************
<?php previous_post_link(); ?>
<?php next_post_link(); ?>



********************************
****** Миниатюры картинок ******
********************************
Для вывода записей. С нуля их нет, их надо включить в файле functions.php и прописать размер, добавляем туда код:
<?php 
add_theme_support('post-thumbnails');
add_image_size('sizethumb', 300, 200, true); /*имя, размер, обрезка или нет*/
?>

Дальше нужно зайти на страницу шаблона - single.php или index, или blog
Вместо картинки вставляем код функции
<?php the_post_thumbnail(); ?>
или
<?php the_post_thumbnail('имя размера'); ?>
У миниатюр создается собственный стиль, поэтому его надо стилизовать
Внимание!
Свойство размера изоббражений начинает работать после его добавления в functions, не работает со старыми картинками. Чтобы перезагрузить старые картинки, нужен плагин Regenerate Thumbnails

/********************************
********* Простое меню *********
********************************/
Без сайдбаров, простое меню, настраиваемое из админки
Подключаем его в functions.php 
<?php
// register menu
function theme_register_nav_menu() {
	register_nav_menu( 'primary', 'Primary Menu' );
}
add_action( 'after_setup_theme', 'theme_register_nav_menu' );
?>

********************************
*********** Сайдбар ***********
********************************
Включим виджеты. Для этого нужно создать файл functions.php
И прописать в нем код:
<?php 
if (function_exists('register_sidebar')) {
	register_sidebar();
}
 ?>

Допустим, у нас 2 сайдбара независимых, один - справа, со своим стайлом, второй - в футере, с другим стайлом

Тогда в functions.php пишем:
<?php 
if (function_exists('register_sidebar')) {
	register_sidebar(array("name" => "имя бара справа"));
	register_sidebar(array("name" => "имя бара футера"));
}
 ?>

Теперь заходим в файл sidebar.php, меняем тело меню в нужном месте на код:
<?php if(!function_exists('dynamic_sidebar') || !dynamic_sidebar('имя')) ?>
<?="виджеты не назначены" ?>
<?php endif ?>

Для футера пишем это в файле footer соответственно

Назначаются виджеты в "Внешний вид" - "Виджеты"
Берем из левой части и перетаскиваем в правую часть. Например, "Рубрики" в нужный сайдбар. Вписываем заголовок

Если мы хотим что-то еще выводить в сайдбаре, то в файле же sidebar после данного кода пишем это

Внимание! Автоматически строится меню в виде li, поэтому надо настроить стили

********************************
************ Метки ************
********************************
Вставляем код на место вывода меток:
<?php the_tags() ?>

********************************
*********** Страницы ***********
********************************
Создаем страницы сайта.
Это делается в админке, в разделе "Страницы".
При создани можно назначить им порядок

Для вывода ссылок на созданные страницы, в теле меню на главной или где там - пишем функцию <?php wp_list_pages('title_li='); ?>

Для отображения страниц нужно сделать шаблон page.php. Иначе по иерархии мы попадаем на single.php

Копируем код из single.php или из index в файл, удаляем ненужное

Заголовок страницы возвращает функция wp_title();

********************************
********** Функции WP **********
********************************
add_item_support('post-thumbnails');
Включение поддержки миниатюр для записей
После этого на странице написания записи появится поле для загрузки миниатюры.

set_post_thublnail_size(300, 100, bool);
Задание размера для миниатюры. Передается ширина, высота и третьим параметром - false (default) - картинка, если больше, будет пропорцинально уменьшена, true - картинка будет обрезана по центру по заданным размерам

the_post_thumbnail();
выводит картинку-миниатюру текущей записи

<?php bloginfo('name'); ?>
заголовок сайта.
Изменить его можно в Параметры > Общие настройки

wp_title();
Заголовок страницы возвращает функция

<?php bloginfo('description'); ?>
Краткое описание
Изменить его можно в Параметры > Общие настройки

<?php bloginfo('url') ?>
выводит адрес сайта

<?php the_title() ?>
вывод заголовка записи. Если просто прописать, то выводит заголовок последней записи

<?php the_permalink() ?>
Выводит ссылку на запись

<?php the_content() ?>
Вывод текста записи
Внимание! Эта функция может быть использована только в цикле.
Например:
<?php if (have_posts()) : ?>
<?php while (have_posts()) : the_post(); ?>
<a href="<?php the_permalink();?>"><?php the_title();?></a>
<?php the_content(); ?>
<?php endwhile; ?>
<?php endif; ?>

<?php have_posts() ?>
Функция возвращает тру-фолс, имеются ли записи

<?php the_post() ?>
Функция выводит пост
Количество отображаемых постов редактируется в Параметры > Настройки чтения - На страницах блога отображать не более

<?php the_date_xml(); ?>
Выводит дату поста в формате гггг-мм-дд

<?php the_exerpt(); ?>
Выводит первые строки поста (55 слов)
Поменять количество выводимого текста можно:
Заходим в редактирование поста. Выдеяем нужное количество текста, копируем его и вставляем в поле "Цитата". Если нет поля "Цитата", жмем сверху справа "Настройки экрана" - "Цитата"

<?php posts_nav_link() ?>
Навигация по страницам. Добавляет "На следующую", "На предыдущую страницу"
Можно передать параметры
первый параметр - то, что находится между ссылками "Предыдущая стр." "Следующая стр"
второй параметр - перед ссылкой
третий - после ссылки

<?php get_header(); ?>
Подключение хедера

<?php get_home_url(); ?>
Возвращает ссылку на главную

<?php get_sidebar(); ?>
Подключение сайдбара

<?php get_footer(); ?>
Подключение футера

<?php the_tags() ?>
Вывод меток

<?php wp_footer(); ?>
Вывод панели админа

<?php wp_title(); ?>
Выводит заголовок записи или страницы

wp_list_pages();
Вывод ссылок на страницы. Передать можно параметр 'title_li='. Можно его сделать пустым, можно 'title_li=PAGE', тогда будет типа заголовка над ссылками

<?php previous_post_link(); ?>
Выводит ссылку на предыдущую запись
Можно прописать параметры для разделителя

<?php next_post_link(); ?>
Выводит ссылку на следующую запись
Можно прописать параметры для разделителя

<?php posts_nav_link(); ?>
Навигация по страницам с постами, простая, в виде двух ссылок - "Следующая страница - Предыдущая страница", можно в параметрах указать разделитель


********************************
*********** Плагины ***********
********************************

Плагины хранятся в wp-content - plugins


/********************************
**** Перенос сайт с локала ****
********************************/
перенос сайта с локала
1. Заводим домен - имя типа almaz.tk (на dot.tk)
2. Заходим в хостинг и там добавляем сайт
3. Создаем пустую БД на хостинге, называем ее, например, 123
4. На локале заходим в wp-config и меняем данные на примерно такие:
define('DB_NAME', 'u858493170_123');

/** Имя пользователя MySQL */
define('DB_USER', 'u858493170_123');

/** Пароль к базе данных MySQL */
define('DB_PASSWORD', 'rafikider');

/** Имя сервера MySQL */
define('DB_HOST', 'mysql.hostgo.tk');


5. Экспортируем эту БД с локала и импортируем на хостинге через phpmyadmin
Перед импортом открыть файл бд, заменить все utf8mb4 на utf8, utf8mb4_... на utf8_general_ci
Тогда норм

6. На локале можно вернуть данные о БД в wp-config


/********************************
******* Произвольные поля *******
********************************/
Через плагин Advanced Custom Fields

Самая простая схема - 
1. создать поля в админке в меню слева будет "Произвольне поля"
2. Переходим на создание заметки, создаем и там добавляем содержимое полей, настройки вида и выбрать, для каких типов контента (ну там - для пунктов поста, страницы, кастомные...)
3. В коде на месте вывода поля - <?php the_field('имя поля'); ?>

/********************************
********* Стрелка вверх *********
********************************/
Плагин To Top link
Настройки в Настройки - To Top Link
Все элементарно

/********************************
********* Дочерние темы *********
********************************/
Создаем папку и называем ее имя-темы-child и тема не будет обновлять ее с обновлением основной темы
В документации смотри, что там где прописывать

про слаг почитать

/********************************
******* Custom post types *******
********************************/
Произвольные типы
Это типа посты, продукты, товары, в собственной категории, типа того, которые выносятся в меню слева в админке
Вручную:
Вписываем в файл function.php в теме
<?php
// сustom post type Products
if (!function_exists('my_custom_post_types')):
		function my_custom_post_types() {
				register_post_type('Products', array (
						'label' => 'Products',
						'public'=> true,
						'publicly_queryable' => true,
						'menu_position' => null,
						'show ui' => true,
						'menu_icon' => 'dashicons-welcome-learn-more',
						'capability_type' => 'post',
						'hierarchical' => false,
						'rewrite' => true,
						'query_var' => true,
						'supports' => array (
								'title',
								'editor',
								'excerpt',
								'trackbacks',
								'custom-fields',
								'comments',
								'revisions',
								'thumbnail',
								'author',
								'page-attributes',)
				));
		}
add_action('init', 'my_custom_post_types');
endif;
?>
Имя вписывается, другие параметры
Этот вариант предпочтительнее, чем плагин.

С использованием плагина:
CPT UI (custom post type ui)
Ставим плагин и он появляется слева. Жмем создать/отредактировать и создаем поле. Вписываем характеристики те же, какие надо, сохраняем и появляется слева в админке кастомный тип постов, теперь их можно добавлять, как посты

Вывод кастомных типов постов.
По умолчанию выводит только стандартный тип поста - пост.
Вывод обычных постов происходит в цикле. ПОсле <?php if(have_posts()) : ?> надо добавить строку:
<?php /* Start the Loop */ query_posts(array('post_type' => array('post', 'products', 'superpro')));?>
где через зпт указать нужные типы постов, какие надо выводить, в данном случае кастомные типы 'products', 'superpro'

<div class="posts">
<?php if(have_posts()) : ?>
	<?php /* Start the Loop */ query_posts(array('post_type' => array('post', 'products', 'superpro')));?>
	<?php while (have_posts()) : the_post(); ?>
			<div class="post"> <!-- start post -->
				<h2><a href="<?php the_permalink();?>"><?php the_title(); ?></a></h2>
				<p><?php the_field('brand'); ?></p>
				<div class="post-info">
					<div class="data">
						<h4>Date</h4>
						<p><?php the_date_xml(); ?></p>
						<h4>Tags</h4>
						<p>Website | Design</p>
						<h4>Comments</h4>
						<p>4</p>
					</div>
					<div class="text">
					<?php the_excerpt(); ?> 
<a href="<?php the_permalink();?>">more...</a>
					</div>
				</div>
			</div> <!-- end post -->
	<?php endwhile; ?>
<?php endif ?>
		</div> <!-- end posts -->

/********************************
******* Написание плагина *******
********************************/
1. Создаем папку с именем плагина в папке plugins, рядом с папкой темы
2. В папке создаем главный файл плагина имя.php,
3. В нем пишем первым делом титле плагина:
/*
Plugin Name: VKPB
Description: Create post in vk wall
Version: 1.0
Author: Aliona Yakovlenko
Author URI: almazka-master.tk
License: GPLv2 or later
*/
4. Задаем нужные константы, имя плагина и т.д., так удобнее
<?php
const VKPB_PLUGIN_ID = 'vkpb';
const VKPB_PLUGIN_NAME = 'VKPB';
const VKPB_USER_ID_OPTION = 'vkpb_user_id';
const VKPB_CLIENT_ID_OPTION = 'vkpb_client_id';
const VKPB_ACCESS_TOKEN_OPTION = 'vkpb_access_token_id';
?>

5. Активируем и пишем функцию активации
<?php
add_action('admin_menu', 'vkpb_settings_menu');
function vkpb_settings_menu()
{
	add_options_page(
		'Settings plugin'.VKPB_PLUGIN_NAME,
		VKPB_PLUGIN_NAME, /*пункт меню как будет называться*/
		8, /*права доступа 8 - только админ*/
		VKPB_PLUGIN_ID, /*уникальный id*/
		'render_vkpb_settings_page' /*имя функции плагина*/
	);
}
function render_vkpb_settings_page()
{
	include 'settings.php'; /*подключаемый файл настроек плагина*/
}
?>
6. Создаем файл settings.php - это страница настроек плагина, со всякими инпутами, которые мы придумываем сами
В начале файла пишем обычную процедуру присвоения пришедших методом ПОСТ данных типа
<?php 
if (isset($_POST[VKPB_USER_ID_OPTION]) && isset($_POST[VKPB_CLIENT_ID_OPTION]) && isset($_POST[VKPB_ACCESS_TOKEN_OPTION])) {
	update_option(VKPB_USER_ID_OPTION, $_POST[VKPB_USER_ID_OPTION]);
	update_option(VKPB_CLIENT_ID_OPTION, $_POST[VKPB_CLIENT_ID_OPTION]);
	update_option(VKPB_ACCESS_TOKEN_OPTION, $_POST[VKPB_ACCESS_TOKEN_OPTION]);
	echo "<div class='updated'><p>Настройки сохранены</p></div>";
}
 ?>
update_option() заносит данные в базу под опр. именем (первый параметр)
class updated - из вордпрессовского стайла

Далее обычная форма с принятием нужных параметров
Функция get_option возвращает сохраненное в базе значение по его имени. Ее можно тоже использовать, например, для сохранения value
<?=get_option(VKPB_CLIENT_ID_OPTION)?>

/********************************
******** Где что у меня ********
********************************/
Плагин VKPB для автоматического репоста на стену ВК у меня самописный - в проекте Intent, он отключен

/********************************
********** Изображения **********
********************************/
Если не грузятся, то надо wp-content/uploads задать права 777
Вручную в галерею можно закидывать картинки - в эту же папку


/********************************
****** Блог на др странице ******
********************************/
Чтобы выводились посты на не главной странице, а на Page, к которой уже привязан шаблон, надо создать новый шаблон спецом для этой страницы и привязать (в редактровании этой страницы)
Файл шаблона кладем в папку темы. В нем надо прописать примерно сие:
<?php 
/*
	Template Name: Blog
*/
?>
И после этого код шаблона - всякие хедеры подключаем и посты выводим

<?php 

/********************************
* Функция при активации плагина *
********************************/
register_activation_hook($file, $function); - функция выбора функции при активации плагина. Крючок. Срабатывает при активации плагина.

$file - место нахождения прикрепляемой функции, если это текущий файл, то пишем __FILE__
$function - имя функции, которую надо выполнить при активации плагина

Например, отправить письмо, создать сущность и т.д.
wp_mail(); - функция wp для отправки письма
wp_mail(get_bloginfo('admin_email'), 'Плагин активирован','Произошла успешная активация плагина');

Вместо имени функции можно написать само тело функции, если она анонимная:
register_activation_hook(__FILE__, function(){
	wp_mail(get_bloginfo('admin_email'), 'Плагин активирован','Произошла успешная активация плагина');
});

Внимание! Анонимные функции работают только в php начиная с версии 5.3.0!!!
А в ранних будет фатал еррор

Например, проверка версии php при активации плагина и не активировать его, если версия не подходит
register_activation_hook(__FILE__, 'plug_activate');
function plug_activate()
{
	if (version_compare(PHP_VERSION, '5.3.0', '<')) {
		header("Content-type: text/html; Carrset=utf-8"); // для нормального русского отображения
		exit('Для работы плагина нужна версия php >= версии 5.3.0');
	}
}

То же самое с использованием классов

/**
* activate with add log notice
*/
class ClassName
{
	
	function __construct(argument)
	{
		register_activation_hook(__FILE__, array(this, 'plug_activate'));
	}
		function plug_activate()
		{
			$date = date("Y-m-d H:i:s");
			error_log($date." Плагин активирован\r\n",3, dirname(__FILE__."/mylogs.log")) // запись сообщения в файл логов, 3 - значит в логи наши, 0 - логи сервера. dirname возвращает путь к каталогу, где хранится текущий файл и прикрепляем файл логов, который тут будет
		}
}
$activateplugin = new ClassName; // не забываем запустить

Еще вариант использования с классом, но без вызова объекта
class ClassName extends AnotherClass
{
	static function plug_activate() // static используется, чтобы можно было обратиться к функции, не вызывая объекта
	{
		# code...
	}
}
register_activation_hook(__FILE__, array('ClassName', 'plug_activate'));

/********************************
**** Оформление вызова хуков ****
********************************/
Если несколько хуков и функций, то комильфо писать сначала все вызовы хуков, а ниже - описания всех функций, а не парами - вызов - описание

/********************************
 Функция при деактивации плагина 
********************************/
register_deactivation_hook(); 
Применение аналогично, цепляем на нее нужную функцию и ниже ее описываем

Вынести описание функции в другие файлы
Через include dirname(__FILE__)."/file.php";
Или require 'file';

/********************************
***** При удалении плагина *****
********************************/
2 способа - через хук и через файл
register_uninstall_hook();
Применение аналогичное, файл и функция передаем, описываем и он при удалении плагина ее исполняет.

Внимание! 
Для успешного удаления через хук:
Любая фигня в главном файле плагина должна быть обернута в function
Не должно быть вызова никаких функций в файле плагина, все вызовы только через хуки

Через файл - более комильфо способ.
В файле uninstall.php
В нем пишем:
if (!defined(WP_UNINSTALL_PLUGIN))
	exit;
wp_mail(get_bloginfo('admin_email'), 'Плагин активирован','Произошла успешная активация плагина'); // наше действие по удалении

/********************************
** Отличние фильтров от экшнов **
********************************/
Фильтры тоже цепляются к хукам, и action-ы тоже. Разница в том, что фильтр прицепляется применительно к результату выполнения функции-хука, к которой прицепляется, а action  нацелен на выполнение отдельной функции, не обязательно даже связанной с рзеультатом хук-функции, с тем, что она выводит или возвращает, фильтр видоизменяет это.
Например, событие the_title() с хуком, при выводе тайтла filter, прицепленный к этому хуку будет работать с тем, что выводит функция the_title(), а action будет делать параллельно свою, отдельную левую функцию, например, отправку сообщения на e-mail.

Главное отличие фильтра в том, что он ничего не должен выводить, он только возвращает после внесения изменений, фильтрует

Список всех хуков есть на сайте codex.wordpress, он не полный, но базовый - для action и для filter
Полный список есть на сайте adambrown.info/p/wp-hooks/hook

/********************************
************ Фильтры ************
********************************/
add_filter(хук, цепляемая_функция, $priority, $args); - функция создания фильтра, первые два - обязательные, остальные - нет.
$priority - приоритет функций для одного и того же фильтра (минимум 10 - самый высокий, 10 выполняется первее, чем 20, 30)
$args - количество параметров, которые принимает подцепляемая функция (умолчание - 1)

add_action(); - функция создания action-а, параметры все те же самые, что и для add_filter()

/********************************
** Прицепляемся к the_title() **
********************************/
add_filter('the_title', 'my_littera');
function my_littera($value)
{
	return $value."!!"; // обязательно возвращать в итоге после обработки
}
function my_littera($value)
{
	return mb_convert_case($value, MB_CASE_TITLE, "UTF-8"); // делаем каждое слово с большой буквы
}

Но! при таком фильтре надпись the_title будет изменена и в админке, и на странице самого поста, если это не нужно, прописываем:
is_admin(); возвращает true, когда мы в админке
function my_littera($value)
{
	if (is_admin()) return $value;
	return mb_convert_case($value, MB_CASE_TITLE, "UTF-8"); // делаем каждое слово с большой буквы
}
Если применяемая функция - это просто функция php или wp без параметров, то указываем ее без описания

add_filter('the_title', 'ucwords'); // функция ucwords делает каждое слово с большой буквы, но работает только с латиной

С предыдущей mb_convert_case так не проканает, т.к. она принимает не один параметр, поэтому ее надо оборачивать в др функцию

/********************************
* Прицепляемся к the_content() *
********************************/
the_content(); выводит контент

add_filter('the_content', 'myfilter');
function myfilter($content)
{
	if (is_user_logged_in()) { // функция is_user_logged_in() возвращает тру/фолс если пользователь авторизован/нет
		return $content;
	}
	if (is_page()) return $content; // на страницах разрешаем не авторизованным смотреть
	return '<div><a href="'.home_url().'/wp-login.php">Авторизуйтесь для просмотра контента</a></div>';
}

/********************************
***** Использование action *****
********************************/
add_action('comment_post', 'foo');
function foo()
{
	wp_mail(get_bloginfo('admin_email'), 'Комментарий отправлен','Комментарий отправлен и сохранен в БД');
}

/********************************
*** Импорт тестового контента ***
********************************/
Удобно для обучения.
На сайте codex идем в раздел Theme Unit Test, скачиваем XML файл предлагаемый
Перед действиями надо сделать бэкап БД! Это простое экспортирование в phpmyadmin

Инструменты - импорт, выбрать плагин Wordpress - установить, активируем.

В нем выбираем скачанный файл, настройки все по умолчанию, только внизу ставим галку Download and import file attachments
Жмем и ждем.

Появятся разные записи, рубрики, полное заполнение

/********************************
******** Похожие записи ********
********************************/
Бывают записи, похожие по меткам и по рубрикам

Создаем плагин (или просто в функции)
Задача - внутри записи выводить похожие записи (single.php).
Алгоритм:
1. получить id текущей записи
2. по id получить рубрику этой записи, или ее теги
3. по этим тегам или по рубрике вывести другие записи, привязанные к ним.

add_filter('the_content', 'related_posts');
function related_posts($content)
{
	if (!is_single()) {
		return $content; // выводить похожести только если мы на странице шаблона single
	}
	$id = get_the_ID(); // функция возвращает id записи
	$categories = get_the_category($id); // возвращает массив объектов категорий записи
	foreach ($categories as $category) {
		$cats_id[] = $category->cat_ID; // cat_ID - идентификатор опред. категории, на выходе получим массив рубрик
	}
	$related_posts = new WP_Query( // делаем related_posts объектом
		array(
			'posts_per_page' => 5, // постов на странице
			'category_in' => $cats_id // из категории с id
			)
		);
	if ($related_posts->have_posts()) {
		$content .= '<div class="related_posts"><h3>Похожие записи</h3>';
		while ($related_posts->have_posts()) {
			$related_posts->get_post();
			$content .= '<a href="'.get_permalink().'">'.'</a><br>';
		}
		$content .= '</div>';
		wp_reset_query(); // чтоб глобальная переменная сбросилась после изменений (она перезаписалась)
	}
	return $content;
}

Так выведутся ссылки на все похожие посты из той же рубрики. Но без сортировки, все, новые сверху.

Если нужно отсортировать по каким-л параметрам:

Полный список параметров сортировки на сайте WE-Cama "Параметры сортировки и ввода"
Эти параметры дописываются к выборке при создании экз. объекта
Например, вывод в случайном порядке:
$related_posts = new WP_Query( // делаем related_posts объектом
		array(
			'posts_per_page' => 5, // постов на странице
			'category_in' => $cats_id, // из категории с id
			'orderby' => 'rend', // случайный порядок вывода
			'post_not_in' => array($id) // исключить из выборки текущую статью
			)
		);

Другой вид
Допустим, хотим выводить похожие записи в виде картинок-миниатюр, тогда:
if ($related_posts->have_posts()) {
		$content .= '<div class="related_posts"><h3>Похожие записи</h3>';
		while ($related_posts->have_posts()) {
			$related_posts->get_post();
			if (has_post_thumbnail()) { // если есть миниатюра
				$img = get_the_post_thumbnail(get_the_ID(), array(100,100), array('alt' => get_the_title(), 'title' => get_the_title())); // картинка с указанным размером
			} else { // если нет, то ставим по умолчанию др.
				$img = '<img src="'.plugins_url('путь к файлу относительно текущего каталога', __FILE__).'" alt="<?=get_the_title()?>" title="<?=get_the_title()?>">' // plugins_url() формирует норм адрес
			}
			$content .= '<a href="'.get_permalink().'">'.'</a><br>';
		}
		$content .= '</div>';
		wp_reset_query(); // чтоб глобальная переменная сбросилась после изменений (она перезаписалась)
	}

/********************************
* Подключение стилей, скриптов *
********************************/
К плагину подключить стили, скрипты

add_action('wp_enqueue_scripts', 'register_files');
function register_files()
{
	wp_register_script('имя-ярлык скрипта уникальное', plugins_url('js/jquery.tools.js', __FILE__), array('jquery')); // последним параметром указываем тот скрипт, от которого регистрируемый скрипт зависит - array('jquery') - встроенный файл библиотеки jquery из wp
	wp_register_script(...);
	wp_register_style(параметры такого же вида см выше); // регистрация файла стилей
	wp_enqueue_script('имя-ярлык');
	wp_enqueue_script('имя-ярлык');
	wp_enqueue_script('имя-ярлык');
}

wp_enqueue_script() - безопасно добавляет фйлы скриптов
Используется вместе с wp_register_script(); второй после нее. Сперва регистрация, потом - подключение скриптов идет.
В итоге это все подключается в <head>

Внимание! К хуку 'wp_enqueue_scripts' цепляем только для внешней части сайта.
К хуку 'admin_enqueue_scripts' - для панели управления
К хуку 'login_enqueue_scripts' - для страницы входа

Внимание! WP добавляет jquery режим no-conflict, поэтому если вручную писать скрипты на нем, то $ не будет работать. Чтобы работало, нужно код обернуть в:
jQuery(document).ready(function($) {
	код, в котором $ работает
});

Если подключаем из файла функций:
// scripts
add_action( 'wp_enqueue_scripts', 'styles_scripts' );
function styles_scripts() 
{
	wp_register_script('my_colorbox', get_stylesheet_directory_uri().'/js/jquery.colorbox-min.js', array('jquery'));
	wp_enqueue_script('my_colorbox');
	wp_register_script('my_slick', get_stylesheet_directory_uri().'/js/slick.min.js', array('my_colorbox'));
	wp_enqueue_script('my_slick');
	wp_register_script('my_mixitup', get_stylesheet_directory_uri().'/js/jquery.mixitup.min.js', array('my_slick'));
	wp_enqueue_script('my_mixitup');
	wp_register_script('my_scripts', get_stylesheet_directory_uri().'/js/scripts.js', array('my_mixitup'));
	wp_enqueue_script('my_scripts');
}

/********************************
***** Количество просмотров *****
********************************/
Создаем плагин (или просто печатаем функции).
Идея:
1. Нужно добавить в БД поле для количества просмотров. При удалении плагина чтобы данное поле удалялось.
Обычно таблицы не трогаются, а создаются новые таблицы.
Потому что с созданием и удалением таблиц проще сделать проверку - там есть встроенная проверка при создании таблицы и удалении - IF NOT EXISTS или IF EXISTS
Для полей приходится писать функцию проверки существования

Коасс wpdb() предоставляет возможности работы с БД
Он берется из глобальной области видимости
global $wpdb;
Его использовать комильфо
2. функцию основную будем цеплять к хуку the_content, т.к. выводить инфу о просмотрах будем после вывода контента поста.
3. Используем глобал переменную post, в ней хранятся все данные, касаемо постов, которые есть в БД, ее надо взять из глобальной области видимости
global $post;


По-порядку:
главный файл плагина:

include dirname(__FILE__).'/check.php';
register_activation_hook(__FILE__,'create_field');
add_filter('the_content', 'post_views');
add_action('wp_head', 'add_view') // wp-head срабатывает для секции хедера, цепляем к ней действие обновления счетчика поста

function create_field($value='')
{
	global $wpdb; // берем глобал переменную для общения с БД
	if (!check_field('field_name')) { // проверка на существование поля
		$query = "ALTER TABLE $wpdb->posts ADD field_name int NOT NULL DEFAULT '0'"; // запрос на добавление поля - ADD
		$wpdb->query($query); // выполняем запрос через метод объекта
	}
}

function post_views($content)
{
	if (is_page()) {
		return $content; // если это страница, то не выводим просмотры, а просто контент
	}
	global $post; // берем глобал переменную post, чтобы дотянуться до содержимого таблицы БД
	$views = $post->field_name;
	if (is_single()) $views++; // если мы внутри статьи, добавляем этот просмотр в таблицу
	return $content."<b>Количество просмотров: </b>".$views;
}

function add_view()
{
	if (!is_single()) return; // если мы не внутри статьи - отбой
	global $post, $wpdb;

	$m_id = $post->ID; // получаем id текущей статьи
	$views = $post->field_name + 1;
	$wpdb->update( // метод update для обновления данных таблицы
		$wpdb->posts, // параметр - название обновляемой таблицы
		array('field_name'=>$views),
		array('ID'=>$m_id)
		);
}

Файл check.php: // для проверки существования поля БД
public function check_field($coloumn)
{
	global $wpdb;
	$fields = $wpdb->get_results("SHOW fields FROM $wpdb->posts", ARRAY_A); // запрос на выборку всех полей таблицы posts, вернет массив массивов, в массиве поле 'Field' содержит имя каждого поля
	foreach ($fields as $field) {
		if ($field[Field] == $coloumn) {
			return true; // если поле нашлось, то вернуть тру
		}
	}
	return false; // если поле отсутствует, то false
}



В файле uninstall.php:
include dirname(__FILE__).'/check.php';
if (!defined(WP_UNINSTALL_PLUGIN)) exit;
if (check_field('field_name')) {
	global $wpdb;
	$query = "ALTER TABLE $wpdb->posts DROP field_name"; // запрос на удаление поля DROP
		$wpdb->query($query); // выполняем запрос через метод объекта
}

/********************************
************* Трикс *************
********************************/
Если мы не знаем, что возвращает хук в функцию, то просто прикрепляем функцию, передаем в нее и выдаем на экран возвращаемое, чтобы проверить. Например,
add_filter('comment_form_default_fields', 'captcha');
function captcha($fields)
{
	var_dump($fields); // вывод только для проверки! Не забудем, что фильтр может только ретернить!
}

/********************************
************* Капча *************
********************************/
Создаем плагин (или коды в функциях)
Идея: у поля ввода комментария прикрутить капчу.
План:
1. Убираем лишнее поле "Сайт" из формы.
2. Добавление простенькой капчи, в виде отмеченного чекбокса "Я не робот"
Будем использовать хуки функции comment_form() для добавления комментария.
comment_form_default_fields // хук отправки полей по-умолчанию, имени, email, сайт
preproccess_comment // исполняется перед отправкой комментария, здесь проверки заполнения обязательных полей

В основной файл плагина:
// delete site field
add_filter('comment_form_default_fields', 'captcha');
add_filter('preproccess_comment', 'check_captcha');
add_filter('comment_form_field_comment', 'bottom_captcha');

function captcha($fields)
{
	unset($fields['url']); // удаление поля "Сайт" (необязательное), при удалении обязательных - их надо делать необязательными, лезть в др функцию
	$fields['captcha'] = '<p><label for="captcha">Я не робот<span class="required">*</span></label><input type="checkbox" name="captcha" id="captcha">';
	return $fields;
}

// если рещили делать капчу после поля комментарий, то переносим ее в др функцию, цепляемую к хуку comment_form_field_comment

function bottom_captcha($commentfield)
{
	if (is_user_logged_in()) return $commentfield;
	$commentfield .= '<p><label for="captcha">Я не робот<span class="required">*</span></label><input type="checkbox" name="captcha" id="captcha">'
	return $commentfield;
}

function check_captcha($commentdata)
{
	unset($commentdata['comment_author_url']); // если мы удаляем здесь поле Сайт, то само поле не удаляется, а просто игнорируется при проверке его значение, что бы туда не писали
	if (is_user_logged_in()) return $commentdata; // если пользовательн авторизован, не ставим проверку на наличие капчи (т.к. она скрыта)
	if (!isset($_POST['captcha'])) { // заносим данные из массива POST в массив, который тут возвращается (в нем изначально нет)
		wp_die('<b>Ошибка</b>: Вы не прошли проверку н человечность.'); // вывод сообщения об ошибке с нашим текстом
	}
	return $commentdata;
}

/********************************
** Капча для формы авторизации **
********************************/
Создаем плагин (или код в функции)
План:
1. Исправить недоработку WP, когда неверно вводим, то он подсказывает - пишет, что неверное имя. НУжно это сообщение заменить на универсальное, где сказано об ошибке, но не указано, в каком поле именно введены не верные данные
2. Исправить недоработку еще одну - когда вводим верный логин, но не верный пароль, то логин в строке "Имя пользователя" сохраняется. Если логин не верный - то это поле будет пустое при выведении ошибки. Это м.б. подсказкой злоумышленникам

Используем action-хук login_form - срабатывает при выведении формы авторизации. Соответственно, можно перед выводом ее изменить

И для проверки авторизации используем filter-хук authenticate. Он запускается вместе с функцией wp_authenticate( $username, $password ); которая возвращает одно из двух объектов - WP_User, если прошла аутентификация, WP_Error, если не прошла, а также имя пользователя и пароль
хук срабатывает после выполнения wp_authenticate(),принимает не одно значение, как обычно, а 3, это значит, что в прикрепляемой функции мы будем ожидать минимум 3 параметра:
$user (null or WP_User or WP_Error)
$username (string)
$password
Соответственно, наша задача взять из переменной POST значение чекбокса и случае не убранной галки перехватить объект WP_Error и вернуть его с нашим сообщением о том, что человек бот
в случае неверного логина-пароля тоже перехватываем и заменяем в объекте сообщение на сообщение без подсказок, какое поле не верно заполнено.

В основной файл плагина:

add_action('login_form', 'my_captcha');
add_filter('authenticate', 'auth', 30,3); // приоритет ставим 30, тогда функция примет первым параметром не null, а уже результат исполнения функции wp_authenticate()

// добавляем чекбокс к форме
function my_captcha()
{
	echo "<p><label for='check'><input type='checkbox' name='check' value='check' id='check' checked> Я робот</label></p>";
}

// проверка убранной галочки и изменение текста ошибок
function auth($user, $username, $password)
{
	if (isset($_POST['check']) && $_POST['check']) == 'check') {
	return new WP_Error('broke', '<b>Ошибка: </b>вы бот?');
	}
	if (isset($user->errors['invalid_username']) || $user->errors['incorrect_password'])) {
		return new WP_Error('broke', '<b>Ошибка: </b>Неверный логин и/или пароль');
	}
}

/********************************
***** Хлебные крошки title *****
********************************/
Пишем плагин (или в функции)
Изменение главного заголовка страницы, выводимое the_title();
Это навигационная цепочка родителей типа Рубрика>Подрубрика>Статья1, где все ссылки, по которым можно переходить на предыдущий уровень

Идея:
Записывать это будем в заголовок страницы <title></title>. Нужно чтобы в тегах <title> была только функция wp_title(); без других.
Эта функция имеет одноименный фильтр.
Внимание! Если в теме уже был использован add_filter с цеплением к wp_title, то нам нужно прицепиться уже после выполнения той функции, поэтому ставим своей другой приоритет, чтобы они не конфликтовали. Т.о. мы будем принимать данные в прицепленную функцию уже после того, как она прошла через первую прикрепленную функцию и что-то вернула.

В основной файл плагина:
add_filter('wp_title', 'my_title',20);

function my_title($title)
{
	$title = null; // обнулим заголовок, если нам не нужнен результат работы предыдущей функции, или просто ее можно заменить на наш код, если  мы в функциях
	$sep = ' - '; // разделитель
	$site = get_bloginfo('name');
	if (is_front_page()) { // вернет истину если мы находимся на главной независимо от того, статичная она или нет
		$title = array($site);
	} elseif (is_page()) { // если мы на странице,то в массив пойдет название страницы и имя сайта
		$title = array(get_the_title(), $site); 
	} elseif (is_tag()) { // если мы на странице меток, то вернем название метки и назв сайта
		$title = array(single_tag_title('Метка ', false), $site);
	} elseif (is_category() { // если мы в категории
		$cat_id = get_query_var('cat'); // вернем номер категории
		$cat = get_category($cat_id); // получить данные категории, там есть свойство parent, по нему будем ориентироваться, самостоятельная ли это категория
		if ($cat->parent) {
			// если есть родительская катег
			$categories = rtrim(get_category_parents($cats_id, false, $sep), $sep);
			$categories = explode($seep, $categories);
			$title = array_reverse($categories); // переворачиваем массив
			$title[] = $site; // доб назв сайта
		} else {
			$title = array($cat->name, $site); // если это самостоятельная катег
		}
	} 
	if (is_single()) { // если мы на записи
		$category = get_the_category(); // получаем рубрики
		$cat_id = $category[0]->cat_ID; // id первой категории записи
		$categories = rtrim(get_category_parents($cat_id, false, $sep), $sep);
		$categories = explode($seep, $categories);
		$categories[] = get_the_title(); // доб назв записи
		$title = array_reverse($categories); // переворачиваем массив
		$title[] = $site; // доб назв сайта
	}

	elseif (is_archive()) { // если мы на странице архива, то вернем текст и назв сайта
		$title = array('Архив за '.get_the_time('P Y'), $site);
	
	// Внимание! По очередности проверка на рубрику и на теги должны быть до проверки на архив, т.к. функции определения входят в is_archive
	} elseif (is_search()) { // если мы на странице результата поиска, то возвратим текст и назв сайта
		$title = array('Результаты поиска по запросу: '.get_search_query(), $site);
	} elseif (is_404()) { // если мы на 404 странице, вернем текст и назв сайта
		$title = array('Страница не найдена', $site);
	}

	$title = implode($sep, $title); // массив в строку
	return $title;
}

В .htaccess (корневой) прописываем:
ErrorDocument 404 /index.php?error=404

/********************************
*********** Шорткоды ***********
********************************/
Аналогичны bb-тегам. Эти теги могут быть парные и не парные. Преобразуются в что-то. Например, [gallery ids="1,2"] преобразуется в галерею с картинками 1,2
Типа ярлык

add_shortcode( $tag, $func ); // функция регистрации шорт-кода. Передается строка и функция

Внимание! Функция прикрепляемая должна что-то возвращать, а не выводить!

[test user]// параметры в шорт-код ставятся через пробел

[test user=Админ] // значение параметров - через =, более одного слова - обрамляем в кавычки, одно слово необязательно в кавычки, но комильфо
Параметры передаются в виде массива в функцию

add_shortcode('test', 'func');
function func($attr)
{
	$user = isset($attr['user']) ? $attr['user'] : 'Ghost'; // задаем умолчание на случай, если параметры не переданы
	return "Привет, ".$user."!";
}

[test user=Админ]Ваши данные[/test] // парный шорт-код
Обратиться к содержимому шорт-кода можно передав прикрепляемой функции второй параметр, туда идет строка
function func($attr, $content)
{
	$content = !empty($content) ? $content : 'Test data'
	$user = isset($attr['user']) ? $attr['user'] : 'Ghost'; // задаем умолчание на случай, если параметры не переданы
	return "<h3>".$content."</h3>Привет, ".$user."!";
}

Но это все вручную, а есть спец функция для прописывания значений по-умолчанию
К данным можно обращаться через массив типа $attr['content']
Но удобнее к ним обращаться по переменным, для этого используется extract() - извлекает данные из массива и присваивает их переменным, одноименным с ключами
После экстракта $attr['content'] становится $content, например

add_shortcode('test', 'func');
function func($attr, $content)
{
	$attr = shortcode_atts(
		array(
			'user' => 'name',
			'login' => 'login',
			'content' => !empty($content) ? $content : 'Test data'
		), $attr
	);
	extract($attr);
	return "<h3>{$content}</h3>Привет, {$user}!";
}


/********************************
 Убрать ограничение на загрузку 
********************************/
На загрузку изображений убираем ограничение
add_filter( 'upload_size_limit', 'PBP_increase_upload' );
function PBP_increase_upload( $bytes ) {
	return 9000048576; // 9000 megabyte
	}

/********************************
**** Статичные карты Google ****
********************************/
В нужное место файла вставляется шорт-код
[map center='Киев, город Киев, Украина' width='600', height='300' zoom='13']Описание карты[/map]

В параметр center нужно вставлять строку из гугл-карт, как там называется нужное место, в их формате. Для этого находим сначала место на гугл карте, потом копируем название оттуда. 

Создаем плагин.

Основной файл плагина:
add_shortcode('map','my_map');

function my_map($atts, $content)
{
	$atts = shortcode_atts(
		array(
			'center' => 'Киев, город Киев, Украина',
			'width' => 600,
			'height' => 300,
			'zoom' => 13,
			'content' => !empty($content) ? "<h2>$content</h2>" : "<h2>Карта от Гугла</h2>",
		), $atts
	);
	$atts['size'] = $atts['width'].'x'.$atts['height'];
	$atts['center'] = str_replace(' ', '+', $atts['center']); // заменяем пробелы на плюсы
	extract($atts);
	$map = $content;
	$map .= "<img src='http://maps.googleapis.com/maps/api/staticmap?center=".$center."&zoom=".$zoom."&size=".$size."&sensor=false' alt=''>";
	return $map;
}

/********************************
**** Динамичные карты Google ****
********************************/
Останавилась на Disk1-Page1-lesson20 со 2 минуты

/********************************
 Подключение плагинов автоматом
********************************/
'http://tgmpluginactivation.com/
https://thomasgriffin.io/automatically-install-plugins-with-themes-for-wordpress/'

/********************************
*********** Виджеты ***********
********************************/
Небольшие программные модули, выводятся обычно в сайдбаре, но могут и где угодно.
Тут принято ООП использовать

/********************************
******* Виджет текстовый *******
********************************/
Создаем плагин (или просто function.php).

В основном файле:

add_action('widgets_init', 'first_wg');
function first_wg()
{
	register_widget( 'my_widget_class' );
}

class my_widget_class extends WP_Widget
{
	function __construct()
	{
		parent::__construct( // обратиться к конструктору родителя - WP_Widget и перегрузить некоторые параметры, задать свое имя и т.д.
		'wg1', // уникальное ID
		'Widget New' // Имя
		array('description' => 'description-widget')); // описание
	}
}
Но лучше делать отдельно массив аргументов и передавать его потом в конструктор
class my_widget_class extends WP_Widget
{
	
	function __construct()
	{
		$args = array(
			'name' => 'Виджет',
			'description' => 'Description1',
			'classname' => 'myclass' // класс css виджета, будет виден в html
		);
		parent::__construct('wg1', '', $args);
	}
	public function widget($args, $instance) // метод отвечает за фронт-енд, показ на странице сайта, $instance - содержимое полей, в $args - теги, css-классы, в которые обрамлен виджет и т.д.
	{
		extract($args); // чтобы $before_widget['title'] = $before_widget
		extract($instance); // чтобы $instance['title'] = $title

		$title = apply_filters( 'widget_title', $title ); // это применение встроенных фильтров, чтобы плагины могли дотянуться до самодельного виджета и работать с ним (а так они бы дотягивались только до вордпрессовских)
		$text = apply_filters( 'widget_text', $text ); // применяется для каждого поля

		echo $before_widget; // тег до
		echo $before_title.$title.$after_title;
		echo "<p>".$text."</p>";
		echo $after_widget; // тег после
	}
	public function form($instance) // метод отвечает за бэк-енд, настройки виджета среди виджетов. В instance приходит содержимое полей, оно кладется в ячейки с именем, которое мы указываем в get_field_id, get_field_name
	{ 
		extract($instance); // чтобы $instance['title'] = $title
		?>
		<p>
			<label for="<?=$this->get_field_id('title')?>">Заголовок:</label>
			<input type="text" name="<?=$this->get_field_name('title')?>" id="<?=$this->get_field_id('title')?>" value="<?if(isset($title)) echo esc_attr($title);?>" class="widefat" /> <!-- класс widefat - стиль строки поиска, функция esc_attr() заменяет спец символы их мнемониками, чтобы кавычки были кавычками и не терялись -->
		</p>
		<p>
			<label for="<?=$this->get_field_id('text')?>">Текст:</label>
			<textarea name="<?=$this->get_field_name('text')?>" id="<?=$this->get_field_id('text')?>" class="widefat" cols='20', rows="5">
			<?if(isset($text)) echo esc_attr($text);?>
			</textarea>
			 <!-- класс widefat - стиль строки поиска, функция esc_attr() заменяет спец символы их мнемониками, чтобы кавычки были кавычками и не терялись -->
		</p>
		<?php
		// get_field_id() - метод, который дает уникальные id, get_field_name для полей виджета, метод принадлежит объекту WP_Widget. Нужно это для того, чтобы можно было несколько одних и тех же виджеттов ставить на одну страницу
	}
	public function update($new_instance, $old_instance) // необязательный метод. Определяет, что делать при сохранении, например, что-то добавить, убавить. В old_instance попадают старые знаечния. НАпример, из введенного текста повырезать <p></p> и поставить на место </p> <br> И результат прямо в поле ввода и будет виден, и везде
	{
		$new_instance['title'] = !empty($new_instance['title']) ? strip_tags($new_instance['title']) : '';
		$new_instance['text'] = str_replace('<p>', '', $new_instance['text']);
		$new_instance['text'] = str_replace('</p>', '<br>', $new_instance['text']);
		return $new_instance;
	}
}

/********************************
*** Виджет рубрики аккордеон ***
********************************/
Выводиться будет это в виде съезжающегося и разъезжащего аккордеона
Для поведения аккордеона используем js-плагин vertical accordeon menu plugin с сайта 'http://www.designchemical.com/lab/jquery-vertical-accordion-menu-plugin/getting-started/'

Создаем плагин (или в файл function.php)

add_action('widgets_init', 'my_accord');

function my_accord()
{
	register_widget('myAccord');
}
class myAccord extends WP_Widget
{
	
	function __construct()
	{
		$args = array(
			'name' => 'Рубрики: Аккордеон',
			'description' => 'Красивое представление перечня рубрик в виде аккордеона'
		);
		parent::__construct('my_accord', '', $args);
		
		function form($instance)
		{
			extract($instance);
			?>
			<p>
				<label for="<?php this->get_field_id('title')?>"></label>
				<input type="text" name="<?php this->get_field_name('title')?>" class="widefat" id="<?php this->get_field_id('title')?>" />
			</p>
			<?php

		}


		function widget($args, $instance)
		{
			extract($args);
			extract($instance);

			add_action('wp_footer', array($this, 'styles_scripts')); // подключение скриптов в футер

			$title = apply_filters('widget_title', $title);

			$cats = wp_list_categories(
				'title_li' => '', // чтобы заголовок виджета не выводился в li, как его другие элементы
				'echo' => false, // чтобы значение, возвращаемое функцией wp_list_categories не выводилось, а возвращалось просто в переменную
				'exclude' => $exclude// исключить какие-то категории из вывода, по идентификаторам
			);
			$cats = preg_replace('#title="[^"]+"#', '', $cars); // вырезка всплывающих подсказок при наведении на ссылку категории
			$html = $before_widget;
			$html .= $before_title . $title . $after_title;
			$html .= '<ul class="accordion">';
			$html .= $cats;
			$html .= '</ul>';
			$html = $after_widget;
			echo $html;
		}

		function styles_scripts() // подключение к футеру файлов скриптов, важен порядок подключения, указываем последним параметром тот скрипт, что должен стоять выше
		{
			wp_register_script('my_cookie', plugins_url('js/jquery.cookie.js', __FILE__), array('jquery'));
			wp_register_script('my_hoverIntent', plugins_url('js/jquery.hoverIntent.js', __FILE__), array('my_cookie'));
			wp_register_script('my_accordion', plugins_url('js/jquery.accordion.js', __FILE__), array('hoverIntent'));
			wp_register_script('my_scripts', plugins_url('js/scripts.cookie.js', __FILE__), array('accordion'));
			wp_enqueue_script('my_scripts'); // и он п цепочке их один за другим подключит в результате
		}
	}
}

В файл scripts.js:
Если что, другие настройки есть для этого плагина js, они на его сайте, их можно кастомизировать
jQuery(document).ready(function($){
	$('ui.accordion').dcAccordion({
		eventType: 'click', // разворачивать по клику
		disableLink: true, // запретить переход по ссылкам
		speed: 'slow', // скорость раскрытия меню
		hoverDelay: 300, // задержка при наведении
	});
});


остановилась на Disk1-page2-урок5 - 09:46

/********************************
************ Галерея ************
********************************/
По схеме Шорткод + плагин

[gallery ids="1,2,3"] // id - атрибут картинок
id картинок берется в галерее, наводим на название картинки и он в адресе подсказывает номер ее

Картинки в WP - это тоже тип поста, он называется attachment

Можно воспользоваться автоматическим созданием шорт-кода. 
На месте, где мя хотим создать галерею - в посте, в редакторе жмем Добавить медиафайл, и в списке слева Создать галерею.
Далее выбрать картинки для галереи, создать.

НО! При клике картинка открывается как пост, в отдельном окне. Поэтому надо добавить lightbox

Берем папки с лайтбоксом (колорбоксом) - css, img, js и помещаем их в папку с плагином

Зато на вкладке текст создается шорт-код этой галереи с выбранными индексами изображений. Мы его и берем.

Основной файл плагина:

remove_shortcode('gallery' ); // обнулить, чтобы убрать все, что там делается по-умолчанию
add_shortcode( 'gallery','my_gallery' );
add_action('wp_enqueue_scripts', 'my_styles_scripts');

function my_styles_scripts()
{
	wp_register_script('lightbox-js', plugins_url('js/lightbox.min.js', __FILE__), array('jquery'));
	wp_register_style('lightbox-style', plugins_url('css/lightbox.css', __FILE__));

	wp_enqueue_script('lightbox-js');
	wp_enqueue_style('lightbox-style');
}

function my_gallery( $atts ) {
	$img_id = explode(',', $atts['ids']); // вытащим ids картинок из шорт-кода в массив
	if (!$img_id[0]) return '<div class="gallery"><p>В галерее нет картинок</p></div>'; // проверка на наличие картинок
	$html = '<div class="gallery">';
	foreach ($img_id as $item) {
		$img_data = get_posts(array( // get_posts чтоб получить полный объект каждой картинки с полным описанием ее поста, чтоб можно было вытащить любые свойства, всчкие post_title и т.д., обращаясь к $img_data[0]
			'p' => $item,
			'post_type' => 'attachment',
		));
		$img_desc = $img_data[0]->post_content; // вытаскиваем свойство post_content
		$img_caption = $img_data[0]->post_excerpt; // подпись
		$img_title = $img_data[0]->post_title; // название
		$wp_thumb = wp_get_attachment_image_src($item); // функция для получения ссылки на переданную картинку, ее размеры
		$wp_full = wp_get_attachment_image_src($item,'full');
		$html .= "<a href='{$img_full[0]}' data-lightbox='gallery' data-title='{$img_caption}'><img src='{$img_thumb[0]}' alt='{$img_title}' width='{$img_thumb[1]}' height='{$img_thumb[2]}'></a>"

	}
	$html .= '</div>';
	$atts = shortcode_atts( array(
		'default' => 'values'
	), $atts );

	return $html;
}

/********************************
****** Записи со стены ВК ******
********************************/
Виджет

Остановилась на Disk1-page2-урок7

/********************************
****** Настройки плагинов ******
********************************/
Не комильфо все хранить внутри кода, это неудобство пользователя.

Есть страница настроек сайта открывается в админке по адресу wp-admin/options.php, настройки можно менять. И туда добавлять новые настройки.

Для добавления, обновления, удаления есть спец. функции:
add_option(); // добавление
update_option(); // обновляет или доавляет, если опции нет
get_option(); // получить настройку
delete_option(); // удалить настройку

add_option('name_option', 111); // передаем уникальное имя и значение. Она добавится на страница options

Касаемо настроек плагинов, есть основные функции:
register_setting( $option_group, $option_name, $sanitize_callback ); // option_group - группа, option_name - имя настройки. Регает новую опцию, внутри используются функции, описанные выше, автоматом и может вызывать функцию sanitize_callback типа фильтра, через которую данные проходят. МОжно добавить эти настройки в любой раздел настроек, там Чтение и т.д.
add_settings_field(); // добавялет поле для опции, вешается на хук admin_init
add_settings_section();

add_action('admin_init', 'first_option');

function first_option()
{
	register_setting(
		'general', // на какую страницу добавляем. Имя берем из адресной строки
		'my_first_option' // имя опции
	);
	add_settings_field(
		'my_first_option', // id опции, лучше, чтоб совпадало с именем
		'Опция 1', // Заголовок, который на странице над опцией
		'option_cb', // функция обр вызова для html кода поля под опции
		'general' // страница, на которую выводить опцию, должна совпадать с указанной в register_setting
	);
}
function option_cb()
{
	?>
	<input type="text" name="my_first_option" id="my_first_option" value="<?php echo esc_attr(get_option('my_first_option')); ?>" class="regular-text"/><!-- 
	после этого поле опции появится на странице Общие, где можно его заполнять, сохранять, изменения записываются все автоматом -->
	<?php
}

echo get_option('my_first_option');// для вывода опции прописываем в нужном файле в нужном месте

Чтобы не регестрировать тысячу опций по одной, если их много - их надо группировать в блоки с пом.add_settings_section();

Создаем плагин.

Основной файл:

add_action('admin_init', 'theme_options');

function theme_options()
{
	register_setting('general', 'theme_options');
	add_settings_section(
		'theme_options_section_id', // id
		'Опции темы', // имя
		'theme_options_section_cb', // функция для генерации html кода описания секции, можно пустым оставлять
		'general' // для какой страница секцияЫ
	);
	add_settings_field( // поле для хранения настройки для фона
		'theme_options_body', 
		'Цвет фона', 
		'theme_body_cb', 
		'general', 
		'theme_options_section_id');
	add_settings_field('theme_options_header', 'Цвет хедера', 'theme_body_cb', 'general', 'theme_options_section_id'); // поле для хранения настройки для шапки

}
остановилась на папка 3, урок 2, 13:40



ECMAScript-262
Некое стандартизированное ядро языка, которое используется везде практически
Настолько ядрено, что нет способов ввода и вывода данных.

К интерпретатору Google Chrome можно обратиться через F12 Console, задавать и через Enter получать ответы

Типы данных

number
Числовой, включая числа с плавающей точкой и буквой e
Операторы:
+ сложение
* умножение
- вычитание и он же как приставка отрицательных чисел
'/' деление, без кавычек пишется
% целочисленный остаток от деления возвращает, именно остаток, а не целое
Внимание! Целочисленный остаток от деления на 2 у четных чисел равно 0, только надо писать исключение для нуля, 0 тоже подпадает
Интересная вещь - при % делении на 10 любого числа возвращается последняя цифра этого числа, как то:
105%10 вернет 5
8%10 вернет 8
Это удобно использовать, например, для вычисления окончания
Но есть исключения - от 12 до 14, когда деление на 100 дает соответствующее число, а не на 10
12%100 вернет 12

() - оператор группировки. То, что в скобках, разбирается сначала. Заходит и разбирает внутренности, а потом идет далее
Это используется с функцией. Она становится самоисполняемой
(function(п){})(парам);
В эту функцию можно спрятать любой код. Аналог пространства имен, обертка

String - строка
Это то, что в одинарных или двойных кавычках (разницы нет)
\n перевод на новую строку
\t табуляция
Слэш нужен для экранирования, т.к. n было бы воспринято как буква, если \ приставить к просто букве, то не прореагирует, просто выдаст букву, слэш исчезает
\\ - слэш одинарный
'\u2014' означает, что юникод и код символа 2014, пишется без кавычек

"Hello, " + "World" слепление двух строк (как точка в php) - конкатенация
Внимание!
При выводе в console.log() или в print() можно писать через зпт, он преобразует зпт в пробел
print(i, ":", book[i]); то же, что и print(i+" : "+book[i]);

Строки так же сравниваться могут. То, что п алфавиту идет раньше, то считается меньше, что позже - то больше.
'a' < 'b'; тру
'abcdef'<'abdcef'; тру

'', 0, NaN, undefined, null - это все при приведении к булевому типу дает false, остальное - true

Булев тип - true/false
Операторы сравнения:
< меньше, ответ true false
> больше
== равно, нельзя сравнивать два разных типа, например строку с числом, иначе он приводит второй тип к первому. Тут строка приоритетнее числа и он число перевел в строку и увидит равенство 1=="1" даст true
=== строгое равенство, только однотипные, разные типы дают false
!= не равно
!== жесткое не равно, типы учитываются
<= меньше или равно
>= больше или равно

Операторы инкремента-декремента, унарные
i++ увеличить на 1 
i-- уменьшить на 1
Засада в том, что операторы исполняются последовательно, поэтому var x = i++ даст 1, (если i=1, сначала присвоил, а потом отдельно i прибавил 1)
++i даст приоритет этому увеличению, сперва увеличение на 1, потом остальное
--1

Страховка от ошибок
В циклах иногда пишется наоборот 0==i вместо i==0, это делается для того, чтобы если по ошибке написать 0=i, то присваивания не произойдет, выйдет ошибка

Тривиальные типы данных

undefined
Неопределенный тип

Тип null


О смешивании типов
строка + число - в приоритете строка и он будет число приводить к строке
строка * число - в приоритете аррифметический знак, он будет пытаться привести строку к числу. Если строка была не числом, то возвращает NaN

typeof 7 - функция для проверки типов, вернет number, string, boolean
(typeof 'Hello') == 'string' вернет true
Запомнить, NaN не равно NaN
NaN - Not a Number

Логические операторы:
&&  логическое и, левая и правая часть приводится к булеву типу (тру, фолс). Из чисел 0 - фолс, остальное - тру, строки - пустая строка - фолс, остальное - тру. 1 && 2 результат 2, т.е. возвращает последнее трувовое значение. 1 && 0 вернет 0, 0 && 2 вернет 0
|| или, возвращает тру, первый или второй 1 || 2 вернет 1, 0 || 2 вернет 2
! логическое отрицание, меняет знак. !true вернет false
Приоритет: ! && ||

; означает окончание инструкции
Позволительно не ставить тчк с зпт в конце инструкции, но лучше ставить!

Переменные
Могут в составе иметь буквы, цифры, подчеркивание, но с цифр не должны начинаться. Регистрозависимы.
var x; объявление переменной x
x = 10; присвоить переменной число 10
var y = 20;
var a, b=50, c; сразу три переменные объявляем, тогда var можно один раз написать
var d=f=g=50; объявляем 3 переменные, все =50
x = x + 2; прибавили и сразу в переременую, кратко это оператор +=, *=

Функции
isNaN("x"*10) проверка на NaN, вернет тру/фолс
typeof 7 - функция для проверки типов, вернет number, string, boolean
isFinite() - конечно ли число, возвращает тру фолс

Можно строку к числу привести быстро, умножив ее на 1
Еще вариант = поставить перед строкой +, она приведется к числу
parseInt() - функция приведения к числу будет останавливать расчет как только дойдет последовательно до не цифры. Возвращает целочисленное
parseFloat() - функция приведения к числу ищет не только цифры, но хоть одно вхождение точки и как предыдущая - до не числа, числа с точкой норм превращает
Number() - функция приведения к числу

Есть народный метод и для приведения к строке - сконкатенировать со строкой 8+"", true+""
String() - функция приведения к строке
Boolean() - функция приведения к булеву типу
Но быстрее вот так приводить, через восскл !!5, вернет тру, !5 будет false

<script></script> - то, что в этих тегах браузер дает интерпретатору, если не в отдельном файле
Ну а отдельный подключается через
<script type="text/javascript" src=""></script>

Комментарии для JS
//
/**/

Интерпретаторы
Можно с ECMAScript-ом работать через разные интерпретаторы. У них своя специфика, у каждого, вывода и т.д. Например, у интерпретатора Хрома специфика вывода такая -
console.log('hello'); - вывести строку в консоль (внизу в хроме)

Есть еще интерпретатор на движке SpiderMonkey, на этом движке был написан сам экма-скрипт. Командная строка ConEmu
Там стандарт вывода print();
putstr(""); - вывод как принт, но без перевода на новую строку
readline(); - функция принятия переменной, запрашивает и ждет введения значения и интера
Внимание! readline делает из введенного значения СТРОКУ, поэтому если ожидается число, то надо привести переменную, принявшую - к числу, например, умножить на 1
x = readline();
x = x*1;

Вообще же, сам console.log() - это не что иное, как метод .log() объекта console
Почему же нет такого объекта в SpiderMonkey, например, там print 
Дело в том, что в JS есть Bild in объекты и Host объекты
Bild in объекты - это встроенные объекты, как Object Array, Math и т.д.
Host объекты - это объекты, которые представляет та или иная среда, интерпретатор. А у них свои собственные объекты. 
В console.log() можно передать сколь угодно параметров через зпт и они выведутся через пробел, так же и с print()
console.log(1,2,3,4,5,6,7); // 1 2 3 4 5 6 7
print(1,2,3,4,5,6,7); // 1 2 3 4 5 6 7

Циклы

Итерация - прохождение цикла
цикл while
- инициализация счетчика
- проверка условия
- выполнение инструкции
- изменение счетчика

var i = 0; заводим счетчик
while(i<10) {
	console.log(i); задача, если одна строка, то без {} можно
	i++;
}
Можно писать внутри i++
	var i = 0;
while(i<10) {
	console.log(i++); дает от 0 до 9, если тут ++i, то результат другой, от 1 до 10
}
	
цикл for

for (var i=1; тру; i++) {}

Внимание! Можно части в круглых скобках опускать, но главное, чтобы сохранялись ; (;;)
внутри инструкции можно разделять запятой

Цикл do-while (while с постусловием еще называется)
Сначала делает, потом проверяет.
do {}
while(); тчк с зпт обязательно


оператор if(){}else{}
оператор else if
сокращение - тернарный оператор ?:

(условие) ? если true : если false
Например
return (num<10) ? -num : num;
означает - вернуть -num при num<10, иначе вернуть num

break(выкидывает из цикла)
continue (прерывает текущую итерацию и идет к условию)

for (var i=25; i<100; i++) {
	if (i%3!=0) continue; перекидывается снова на условие и заново
	console.log(i + 'делится на три');
	break; выкинет из цикла после первого совпадения условий
};
Если циклы вложенные и надо выкинуться из всех их, то используются метки
Пишется имя и двоеточие
outher: for (var i = .length - 1; i >= 0; i--) {
	inner: while(){
		break outher
	}
}


switch для проверки значения
var x=2; надо узнать, что в переменной
switch(x){
	case 0: если 0
	console.log("Ноль");break; пишем это и выбрасывает
	case 1:
	console.log("Один");break; пишем это и выбрасывает
	case 2:
	console.log("Два");break; пишем это и выбрасывает
	default: console.log("Ни одно из"); что-то типа отстойника else
}

Функции
Если кусок кода используется больше одного раза - под него надо писать функцию

Сначала ее надо продекларировать
function function_name (argument) {
	// body...
}
Значение по умолчанию можно задать функции внутри на тот случай, если в нее ничего не передали, чтобы не выводилось undefined
function function_name (argument) {
	argument = argument || "Guest";
	print("Hello, "+argument+"!");
}
Здесь по умолчанию она будет выводить "Hello, Guest!"
Тут используются приоритеты логического или ||, то бишь если пустоту передать, то это будет фолс, в сравнении выиграет "Guest", т.к. он тру


Если несколько аргументов, то через зпт передаем.

Можно описание функции писать после ее объявления, разницы нет, он анализирует перед прочтением
НО! Если это безымянная функция, переданная в переменную, то не проканает, т.к она не была продекларирована, а передана переменной, а переменными он занимается лишь при исполнении кода

Есть return для возврата и выхода из функции. Ретерн должен быть последним, после него ничего не исполняется.
Даже если нет return-а, то функция всегда возвращает undefined в таком случае. Встроено так, что функция всегда чего-то возвращает. Либо то, что прописано, либо undefined

console.log() - функция для вывода в консоли. Можно сделать функцию адаптации:
function echo (data) {
	console.log(data);
}
сохранить это в файл js и присоединить к доку

Области видимости
локальная и глобальная, если внутри функции не объявлена переменная, то БЕРЕТ глобальную
var y = "lol";
function function_name (argument) {
	var z = y + " you";
	print(z);
}
function_name();
print(y);
Результатом будет "lol you" и "lol"

Поэтому важно писать var. Где написан var, там и объявлена переменная. Если внутри функции объявлена - то она локальная, если вне - глобальная
var y = "lol";
function function_name (argument) {
	var y = "trueee"
	var z = y + " you";
	print(z);
}
function_name();
print(y);
Результатом будет "trueee you" и "lol", а глобальная y так и останется = "lol", а локальная - "trueee"

Он ищет именно то, что объяВлено var-ом, даже если оно вне функции. НО. Если присвоить внутри функции глобально переменной что-то другое, без var, он перезаписывает ее
var y = "lol";
function function_name (argument) {
	y = "trueee"
	var z = y + " you";
	print(z);
}
function_name();
print(y);
Результатом будет "trueee you" и "trueee", "lol" перезаписался на "trueee"

Глобальных переменных должно быть как можно менее, т.к при загрузке сразу память под них, даже если пустые. Поэтому глобальные заводить только если видно, что и тут, и там будет использоваться

ТАкже JS достраивает var локальный сам, если она употребляется внутри функции в цикле. Он выносит объявление ее мысленно в начало тела функции и таким образом он НЕ БЕРЕТ значение это переменной снаружи, ее значение становится undefined
var y = 0;
function function_name (argument) {
	if (argument)
		print(y);
	else{
		y=2;
		print(y);
	}
}
function_name(true);
Результатом будет undefined, т.к. y он мысленно объявил внутри функции, но он пустой.

Функции в JS - это тип данных, с ними можно делать разные манипуляции как с др типами
Внимание! Функция в js всегда что-то возвращает. Это либо то, что под return написать, либо undefined
Сама функция может вызываться - для этого после нее пишутся (); или просто к ней можно обращаться по имени
foo - просто обращение к функции foo, вернет ее полностью
foo(); - означает исполнить функцию foo
 
function foo (data) {
	console.log(data);
}
var p = foo;
p(10) даст то же самое, что echo(10);
p вернет function foo(data){console.log(data);}

Поэтому становится логично писать анонимную функцию, это функция, присвоенная переменной и вызывается по имени той переменной, ей не нужно отдельное имя
p = function () {};
Это НЕ декларация (declaration) функции, это ее присваивание (expression)
поэтому Внимание! Присваивание надо писать только ПОСЛЕ объявления функции, иначе он ее не видит

возвращать тоже можно функцию внутри функции - тоже без круглых скобок

function foo () {
	function bar (){}
	return bar;
}
var x = foo(); вернет function bar(){}

можно и безымянной вернуть - 
function foo () {
	return function(){};
}
var x = foo(); вернет function(){}

Замыкание функций
Способность функции захватывать значения из родительского контекста, как матрешки в матрешках
Внутренняя функция сохраняет как бы ссылку из родительской функции, не копию, а ссылку
function sayHello(word){
	return function (name) {
		return name+" say "+word;
	};
}
var en = sayHello("hello"); // вернется function(name){return name+"say "+hello}
var ru = sayHello("privet"); // вернется function(name){return name+"say "+privet}
en("Jonh"); // вернет строку John say hello
ru("Petya"); // вернет строку Petya say privet
print(en("Jonh")); // напечатает строку John say hello
print(ru("Vasya")); // напечатает строку Vasya say privet
Можно сразу написать print(sayHello("Hello")("John")); это называется разименование функции, тоже будет работать

Если нужно не задавать определенное действие типа print, а само действие-это функция, которая будет определена позже, то ее тоже можно передать:
function function_name(base, count, action) {
	for (var i=base; i<count; i++) {
		action(i);
	}
}
function_name(5, 10, print);
function_name(5, 10, function(){});


Рекурсия
Ресурсозатратная, так что ее редко используют
Используется тогда, когда неизвестно, сколько циклов должно пройти

Это когда функция вызывает сама себя. Главное ее остановить, чтоб не зацикл, условие чтоб стояло, например
function power(base, exp) {
	if (exp == 0)
		return 1; //это стопор, чтобы не зацикл
	return base * power(base, exp-1);
}
Это действующая функция для вычисления степени exp числа base

Для крайних случаев, т.к. она ресурсоемкая, лучше использовать циклы.

Cвойства и операторы:
.length - длина
'tytyt'.length;
trtrtr.length;
'\u1552'.length; выдаст 1, т.к. это символ юникода один



.charAt() - выборка какого-то символа в строке, отсчет с нуля
"abcdef".charAt(2); вернет "с"
"abcdef".charAt(200); вернет ""
"abcdef".charAt(-1); вернет ""

.toString() - перевод в строку
var a=42;
a.toString(); вернет "42"

Объекты
Это все, кроме чисел, строк, булева, null-a и undefined
Это функции, массивы, объекты

var obj = {}; пустой объект
либо так написать var obj = new Object(); (экземпляр глобального объекта)
var person = {
	'name' : 'Ass',
	'age' : '45'
};

Обращение к объекту - через точку (dote notation)
person.name; даст Ass
person.age; даст 45

Ключи внутри объекта можно называть именами, совпадающими с командами, они могут начинаться с цифры (т.к. все ключи - строки) и иметь пробелы. Только в случае с пробелом ключ обязательно должен находиться в кавычках
var obj = {"user name":"John", 2:true, var:"baby"}

С такими именами (и с другими) обратиться к свойству можно через breacket notation
o['user name']; вернет John
o[2]; вернет true

Через breacket notation и через dote notation можно задавать новые ключи и значения объекту и считывать содержимое ящичка. Не забываем про синтаксис breacket notation - кавычки у строковых нужны

Может быть объект в объекте, значением свойства объекта может быть что угодно
var person = {
	name : 'Ass',
	wife : {
		name : 'Loli',
		age : 34
	},
	age : 22
};
person.wife.age; даст 34

Меняются объекты обычным присвоением:
person.name = 'Ann'; и он его затирает

in - проверка, на наличие определенного свойства в объекте, есть или нет - вернет true или false
'name' in person; вернет тру
Это хорошо использовать для перебора объекта

Перебрать объект по ключам
цикл for in - это усеченная версия цикла for
var o = {
	'a' : 1,
	'b' : 2,
	'c' : 3
};
for (var cur in o) { название каждого свойства будет попадать в cur
	console.log(cur+' : ' + o[cur]);
};
Если известно, что у объекта ключи все числовые и в прямом порядке, то можно перебор делать просто for-ом с использованием in-а
for (var cur=0; cur in person; cur++) {
	console.log(cur + ": " + o[cur]);
};

delete - оператор удаления.
delete person.name; удаляет полностью строчку со значением из объекта

Присваивание объекта
В сравнении с переменными в присваиваемую идет ссылка, а не сам объект, поэтому при изменении переменной, которой присвоили объект с другим именем, будет меняться изначальный объект
var j = {x: 10};
var j1 = j; // сюда пойдет ссылка на j, а не его содержимое
j меняем, меняется и j1

Сравнение объектов, равны только две ссылки на один объект, а содержимое не причем
var obj1 = {x: 10};
var obj2 = obj1;
var obj3 = {x: 10};
obj1 == obj2; тру
obj1 == obj3; фолс

Методы
Это свойство (ящичек) объекта, в которорм функция
var obj = {
	method1: function(lol) {console.log('hello')}
};
Вызывается так же через тчк (dote notation)
obj.method1(po);
Можно передать параметр в такую функцию 


this
Ссылка на сам объект, где оно находится.
this.name - ссылка на свойство name внутри объекта

var user = {
	name: 'Gosha',
	getName: function() {
		console.log(this.name);
	}
};
user.getName(); вернет Gosha

Внимание! Но управлять объектом изнутри его метода нельзя. Например, не прокатит вызвать свойство объекта, переданное как переменная в функцию, потому что внутри все и так как переменные
var user = {
	name: 'Gosha',
	getName: function(i) {
	print(this.i);
}
};
user.getName(name); не сработает

Можно выдергивать функции из одного объекта и присваивать их другому, this беспрестрастен
var john = {
	"name":"John",
	"say": function(word) {print(word+" from "+this.name);}
}
var mike = {
	"name":"Mike"
}
mike.sing = john.say; // в новосозданный метод mike.sing пойдет функция целиком
Можно и через : внутри объекта добавить, т.к. объекты прозрачные в js
var mike = {
	"name":"Mike",
	"sing" = john.say
}
mike.sing("Hello"); // напечатает "Hello from Mike"

this работает и вне объекта. Только это глобальный контекст. Если this не найден, то вернется undefined
function some() {print(this.age);}
var age=10;
some(); // сработает и отпечатает 10, т.к. this берется у глобального объекта, внутри которого все находится

Функция - это не что иное, как метод глобального объекта. Глобальный объект не требует названия при вызове метода. Да и нет этого имени (object global и все)
По этой же логике - функция может быть продекларирована где угодно, если она вызваа в глобальном контексте, то она будет искать параметры из глобального контекста
var o = {
	"param":10,
	"mt":function(){
	function test(){print(this.param);}
	test();
	}
}
var param = 100;
o.mt();
Напечатает 100, т.к. o.mt(); запускает функцию, он ее как бы разворачивает и на место o.mt(); встает test(); Описание функции test берется оттуда, а соответственно param берется глобальный 

Для сохранения контекста в переменную внутри метода mt кидаем сам объект через this. Такую переменную принято называть self
"mt":function(){
	var self = this;
	function test(){print(self.param);}
	test();
	}
Получается своего рода кэширование объекта и в итоге при вызове o.mt(); выполняется функция, к которой прицеплен объект с его параметрами

Функция - есть объект. Соответственно, она имеет встроенные методы

Метод .call()

Можно функцию лепить на лету к объекту
function foo() {
	print("Hello, "+this.name);
}
foo.call(obj); вызвать функцию foo как метод объекта obj (соответственно, берутся свойства метода obj - name)
foo.call(obj, 10, 20); вызвать функцию foo как метод объекта obj и передать параметры 10, 20

Метод .apply()
Работает точно так же, как call, только параметры в виде массива передаются
foo.apply(obj, [10, 20]);
var arr = [3,4,5,5];
foo.apply(obj, arr);

Метод .length

Возвращает, сколько параметров ожидает функция
foo.length; вернет 2
Это можно использовать даже внутри функции
function foo (x,y) {
	console.log(foo.length); вернет 2
}
НО! Всегда можно передать больше параметров, чем ожидает функция, и она их примет. Внутри функции есть объект arguments, в который попадают все переданные данные

arguments.length; вернет количество фактически переданных аргументов

Обратиться к переданным аргументам можно по порядковым номерам (от 0 считает)
arguments[2]; вернет 3й аргумент
function foo (x,y) {
	print(arguments[5]);
}

Объект arguments - это не просто объект, он как массив, то бишь - коллекция.


Массивы
arr = ['a',10,true,function() {}];
Можно задать через объекты с предопределением количества ячеек, пишется так:
var f = new Array(6); массив с 6 undefined-ами
Он там нумерует за кадром ячейки от 0
arr[0]; даст a
arr[3]; даст function() {}
arr[3](); undefined

Массив - тоже объектный тип, у него есть свойство - length. Соответственно, как свойство, он и на чтение, и на запись
Массив из объектов называется dictionary - словарь

arr.length; // вернет количество элементов массива
arr.length = 6; // удлинит массив до 6 ячеек

Всегда ячейка с номером количества будет следующей, т.к. от нуля счет. Это используется, чтоб докапаться до номеров можно последовательно, чтобы добавлять новые элементы:
arr[arr.length] = 'z';

arr; выдаст просто все содержимое ['a',10,true,function() {},'z'];
Если присвоить что-то номеру ячейки больше длины массива, то он добавит перед ним пустых undefined-ов столько, сколько надо и вставит значение.
arr[10] = 8;
arr; даст ['a',10,true,function() {},'z', undefined, undefined, undefined, undefined, 8] и массив удлинится
arr.length = 4; меняет длину, с конца обрезает и оставляет 4 первые ячейки

Перебрать массив можно как объект. For in
for (var cur=0; cur<arr.length; cur++) {
	console.log(cur+' : '+arr[cur]); выберет все вместе с undefined-ами
}
for(var i in arr) {
	console.log(i+' : '+arr[i]); разница в том, что он игнорирует undefined-ы
}

делаются из массива элементы с помощью delete так же, как из объекта, но в отличие от удаления из объекта он его просто стирает, а на месте его пустой ящик - undefined, длина массива не меняется от удаления.
если просто присвоить undefined, то это другой undefined, второй undefined - это понятное значение, а первый - типа он не знает, что там

Методы массивов
Получение строки из массива
.join() там можно задать разделитель
var a = [1,2,3];
var s = a.join("---"); // 1---2---3

.toString() через зпт выдает в строке содержимое
var s = a.toString(); // 1,2,3

.slice(6,8); получить часть массива
Указать нужно координаты от какого по какой элемент (с 0) вычленять элементы массива, хоть одну координату.
Внимание! Конечная позиция в выборку не входит, начальная - входит.
var a = [1,5,7,44,8];
var arr = a.slice(2); // [7,44,8]
var arr = a.slice(1,3); // [5,7]
var arr = a.slice(-3,-1); // [7,44]
var arr = a.slice(2,1); //[]
var arr = a.slice();//[1,5,7,44,8]

Пустой slice используется для копирования массива

.concat() прилепить значения или массив к массиву
var a = [1,2,3];
var b = [6,7,8];
var arr = a.concat(8, b); // [1,2,3,8,6,7,8]

Внимание! Если пытаться складывать массивы, то он переводит их в строки и складывает как строки, в итоге строка получается
var s = [1,5] + [11,8]; // 1,511,8

.reverse(); переворачивает задом наперед массив ((меняется сам массив при этом))
var a = [1,5,7,44,8];
a.reverse(); // [8,44,7,5,1];

.sort(); сортирует массив (меняется сам массив при этом)
Внимание! Сортировка происходит по алфавиту, то бишь цифры сортирует криво
для сортировки по возрастанию нужно описать функцию
function mySort (a,b) {return a-b;}
a.sort(mySort); тогда отсортирует норм
или кратко a.sort(function(a,b) {return a-b;});

.pop(); вырезает последний элемент массива (совсем вырезает, массив остается без него)
var v = arr.pop(); в массиве arr удалится последний элемент и запишется в переменную v

.push(); противоположный, наращивает на конец массива переданные значения
var v = arr.push(12,3); вставит в конец массива ячейки 12 и 3, возвращает новую длину массива в переменную v

.shift(); аналог .pop(), только для начального элемента, вырезает его и возвращает.

.unshift(); аналог .push() для начала массива, возвращает то же самое.

.splice(1,2); вырезает и возвращает любые указанные элементы массива
Внимание! Изменяется сам массив.

Вариант1: Передается номер позиции начала (от 0) и длина в шагах, захвата
var a = [1,"lol",7,"true",8];
a.splice(1,2); // ["lol",7], массив a станет [1,"true",8]

Вариант2: Передается номер позиции начала (от 0), длина вырезки в шагах и значение, что надо вставить (можно много - через зпт)
.splice(1,0,3); вставить перед первым элементом, ничего не вырезать и вставить значение 3, или если не 0, то вырежи с первой позиции длину такую-то и вставить значение 3 на их место.
var a = [1,"lol",7,"true",8];
a.splice(1,0,3); // вернет [], массив a станет [1, 3,"lol",7,"true",8]

Методы массивов от ECMAScript 5
typeof[] дает object вместо array
Есть специальная для этого вещь у объекта Array для проверки
Array.isArray(25); 25 проверяем на массив, тру фолс
Array.isArray([]); true вернет

.forEach()
Ничего не возвращает, просто перебирает значения
[1,2,3].forEach(function(v) {
	console.log(v);
});
возвращает все элементы, по очереди пропущенные через функцию

.map()
В отличие от forEach, возвращает значения во вновь созданный массив
var arr = [1,2,3].map(function(v) {
	return v*10;
});

"     uiui   ".trim(); обрезалка строк, возвращает строку без лишних пробелов


Встроенный объект Math 
Для математических рассчетов
Свойства:
PI
Math.PI вернет число пи

Методы:

Math.pow(3,4); даст 3 в 4 степени
.sin();
.asin();
.cos();
.acos();
.tan();
.atan();
.abs();

.max(); вернет максимальное число из массива
Math.max(4,8,5,9); // 9
Внимание! .max() и .min() работают с числами через зпт, а не с массивом. Поэтому нужно прогнать через apply
var arr = [4,8,5,9];
Math.max.apply(Math, arr);
Что в переводе означает - возьми функцию max (а метод это и есть функция) и используй ее как метод Math с атрибутами из массива arr

.min(); вернет минимальное число из массива
Math.(4,8,5,9); // 4

.random(); рандомное число возвращает длинное
.exp();
.log();
.sqrt();
 и др методы

Есть глобальный объект, который даже не имеет имени - global object, его не называют в суе.
Все переменные, что создаются - это его свойства
Все функции - это его методы
У него есть встроенные свойства
Внимание! Так как это самый главный объектище, то никакого имени и точек при обращении к свойствам и методам нет.

Встроенные свойства глоб объекта:
Infinity // возвращает Infinity (бесконечность)
-Infinity // возвращает -Infinity (минус бесконечность)
5/0 вернет Infinity
NaN
Внимание! NaN не равен NaN
Но есть способ проверить от обратного. Неравенство самому себе - есть NaN
x != x дает тру

И в глоб объекте нем другие глобальные объекты -  Number, String, Boolean, Array с его свойствами и методами, они наследуют и некоторые перегружают.

Number
Статические свойства (общие для всех):
Number.NEGATIVE_INFINITY;
Number.POSITIVE_INFINITY;
Number.NaN; с ним можно сравнивать вместо isNaN
Number.MIN_VALUE; минимальное
Number.MAX_VALUE; максимальное число, которое на этой опер системе мы можем положить в переменную

.toString(); преобразование числа в строку. Он тоже унаследован, но перегружен. Для массивов он один, для чисел - другой.

.toFixed(2); сокращение чисел с остатком, пишем сколько хотим чисел оставить после запятой

.toPrecision(4); указываем, сколько вообще оставить знаков, а он сам ставит запятую и как хочет

isNaN(); - это метод глобального объекта, а не функция. Без тчк потому что к методам глобального объекта можно обратиться без тчк
Можно обратиться к нему через window.isNaN(); Но для универсальности без тчк
И вообще, все, что вызывается без тчк - все обращение к методу глобального объекта, включая функции!
foo();

parseFloat(str); преобразование строки в число вместе с точкой, NaN вернет, если строка начиналась не числом

parseInt(str); преобразование строки в число без точек, NaN вернет, если строка начиналась не числом

toString(16); если указать в скобках, в какой системе преобразовать число в строку, то вернет соответственно например var n = 255; var s = n.toString(16); даст ff
var n = parseInt(s, 16); и наоборот, даст 255, то бишь мы указали систему счисления вторым параметром

Методы объекта String
.length(); длина строки. В отличие от массивов, присвоить ему нельзя произвольное. Это перегруженный метод, для массива свой, для строки - свой, а по сути - один.

s1.concat(s2,s3); по аналогии с массивами, соединить строки s1,s2,s3 то же самое, что + на лету, но не сохраняет в строку саму

.toLowerCase(); привести к нижнему регистру на лету, фактически строка так и остается как была, пока не присвоить результат. ТАк он его просто вернет, но не перезаписывает на место прошлой строки.

.toUpperCase(); к верхнему

.charAt(4); вернуть символ из строки под таким-то номером (от 0 как в массиве все буквы в строке), если больше число, чем длина строки, вернет пустую строку

.charCodeAt(4); возвращает юникод заданного по счету (от 0) символа, NaN если число указанного символа больше строки

String.fromCharCode(1051, 1091, 1085, 1072); вернет Луна через юникодовские символы. Используется глобальный метод

.slice(3,6); часть строки получить так же как и часть массива, по символам так же как по ячейкам, если не указывать параметр, вернет всю строку. Может принимать отрицательные значение так же

.substring(3,6); аналог слайса полный, только если передать первое число больше чем второе - он их поменяет местами и вернет результат, а slice вернет пустую строку. Отрицательные значения принимать не может

.indexOf('gh'); поиск по строке. Вернет позицию, которая начинается на 'gh', вернет число, номер "ячейки с началом" - 6, например. Если не нашел, возвращает -1

.indexOf('gh',9); вторым параметром можно точку отсчета поиска прописать, искать с 9 символа

.lastIndexOf('io'); тот же поиск, но сзади, справа налево, возвращает положительное то же самое число по той же логике

var arr = [];
arr.indexOf();
Можно применять и к массиву

.replace('одно', 'другое'); поиск и замена

.split(' '); из строки делает массив, передаем разделитель, по которому делит на ячейки, можно и по буквам, если указать '', вторым параметром можно передать ограничение длины - до третьего символа, например

Callback функция
Для того, чтобы свести воедино два похожих цикла
Например
var aIdx = 97;
var alfavit = "";
for (var i=0; i<26; i++) {
	alfavit += String.fromCharCode(aIdx+i);
}
print(alfavit);

var digits = "";
for (var i=0; i<10; i++) {
	digits += i;
}
print(digits);

function buildString(n, callback) {
	var result;
	for (var i=0; i<n; i++) {
		result += callback(i);
	}
	return result;
}
Теперь
alfavit = buildString(26, function(i){
	var aIdx = 97;
	return String.fromCharCode(aIdx+i);
});

digits = buildString(10, function(i){
	return i;
});

Регулярные выражения
Встроенный объект RegExp
Регулярное выражение можно создать через обращение к объекту RegExp
Например, если надо из массива составить регуляр выражение на лету
var emails = ['gmail', 'hotmail', 'yandex', 'mail'];
var re = new RegExp(emails.join('|'), i); вторым параметром флаг

Просто же синтаксис регулярного выражения - в палках - /выраж/
Для этого есть встроенный объект RegExp

Методы объекта RegExp

regexp.test(string); протестировать строку на регулярное выражение. Возвращает тру или фолс - есть нет совпадение
/gh|ki|ya|jk/.test(vasya@vrn.ru); // false

Методы объекта String с использованием регулярных выражений:
.search(regexp); применить к заданной строке регулярное выражение, вернет номер символа, где нашлось совпадение
"vasya@vrn.ru".search(/@/); найти символ @ в строке и вернуть ее позицию

replace(regexp, string); найти нечто, соответствующее регулярному выражению и заменить на string

split(regexp); разбить строку под нечто, подходящее под шаблон


match(regexp); (см ниже)

var re = /@/; продекларировали выражение
var str = 'as@ki.uo';
str.search(re); вернет 2 - положение найденного
var re = /gh|ki|ya|jk/; палка означает или
str.search(re); вернет 3

Служебные символы регулярных выражений
Внимание! В синтаксисе регулярных выражений не должно быть никаких пробелов, и после зпт тоже - будет ошибка
\/ - / экранированный
\0 символ null
\t горизонтальная табуляция
\n перевод строки
\r возврат каретки
\\ обратная косая черта
\w любой символ ASCII [a-zA-Z0-9_]
\W противоположное \w [^a-zA-Z0-9_]
\d любая цифра ASCII [0-9]
\D противоположное \d [^0-9]
\s любой символ-разделитель unicode
\S противоположное \s
[^ отрицание - не должно быть [^fg] - не должно быть f или g
^ позиция начала строки /^abc/ должна начинаться либо с a, либо с b, либо с c
$ позиция конца строки /abc$/ чем она должна заканчиваться
\b позиция на границе слова
\B позиция между двумя символами ASCII (не граница слова)
. любой символ, кроме перевода строки. Если имеется в виду точка, то ее надо экранировать
* эквивалентно {0,}, чтобы он не продолжал искать бесконечно, ограничитель вопрос /a*?/;
+ эквивалентно {1,}, минимум 1 шт, максимум бескон
? эквивалентно {0,1} - либо есть, либо нет, то бишь от 0 до 1
= 
! 
: 
|  или
() группа для вытаскивания, вытаскивает в свою переменную, типа ссылок, внутри выражения обращение к ссылке просто как к экранированной цифре, за границей рег выражения - через $

[] группа символов либо [sdf] - или s, или d, или f
{} в количестве от ... до... повторений. повторение /j{2}/ j 2 раза подряд, {2,} - повторяется от двух и более раз, {3,6} - от 3 до 6 раз повторяется
- диапазон [a-g] от и до, [1-7], пробелы не нужны при объединении [a-zA-Z0-9], но под такие есть замены - буквы (см выше)
пробел - указывается просто как пробел


Флаги
Это то, что ставится за слэшем
Флаг i (ignoreCase) игнорирование регистра
var re = /a/i; и большие a, и маленькие

Флаг g (global) ищутся все вхождения,  то бишь нашел, не останавливается и ищет далее
var re = /a/g; вернет все вхождения

Флаг m (multiline) многострочность, в такой строке есть \n и она воспринимается как перевод строки и начало новой строки воспринимается как начало новой строки. Без этого \n как часть строки читается
var str = 'ABC\nDEF\nikikik';
/^DEF/m.test(str); найдет, без m - нет

Флаги можно использовать вместе, просто без пробелов
/^DEF/im.test(str);

Ссылки в регулярных выражениях

Внутренние ссылки - это ссылки из (), на которые мы ссылаемся внутри выражения
Ссылаться на них надо через \ (экранирование)

Встретив в коде регулярки () он ставит на нее невидимую внутреннюю ссылку, когда нашел соответствие (номерные ссылки, от 1)
И эту ссылку можно вставить в другом месте регулярного выражения как цифру экранированную

var r = /(['"])[^'"]*\1/; выбираем то, что в любых кавычках, "" или '', но не пройдет смешанная

Внешние ссылки - это ссылки из (), на которые мы ссылаемся вне выражения
В методах объекта String - .replace() и .split() можно использовать регулярные выражения с внешними ссылками
Ссылаться на них надо через $

Например, из 1А сделать А-1
'1A'.replace(/(\d+)([a-z]+)/i, '$2-$1');

.match(); разбивка по переменным, учитывая скобки ()
var re = /(ab)(cd)(vvv)/; // Типа схема
var res = 'abcdvvv'.match(re); вернет эти куски в массиве
[
'abcdvvv', тут индекс 0 - первым лежит то, что совпало полностью
'ab',
'cd',
'vvv'
]
При несовпадении вернет null
Обратиться к ссылкам такого типа можно как к массивным - 
res[1]; // 'ab'
res[2]; // 'cd'
res[3]; // 'vvv'


.exec(); работает точно так же, возвращает то же самое

Сайт по регуляркам regexlib.com, например. В разделе rows expressions всякие готовые выражения, что пропускает, что не пропускает. Можно их тут же протестировать

Конструкторы

Это функции для создания нового объекта. Принято именовать с большой буквы, для удобства отличия от просто функции
Она - как чертеж для объектов, чтобы свойства наследовались у них у всех, кого она создала.
Свойства можно присвоить те, которые будут передаваться функции, а можно задать по умолчанию значения
function User (name) {
	this.name = name;
	this.age = null;
	this.say = function(word) {
		console.log('Hello, '+word+" from "+this.name);
	};
}
var user1 = new User('John'); создали экземпляр объекта User

new - это оператор, который создает новый объект по конструктору (чертежу) User с переданным параметром 'John'

user1; станет объектом, у которого {name: 'John', age: null, say: function}, наследующий user
user1.say('world'); даст 'Hello, world from John'
Наследованные свойства от конструктора можно перегружать
user1.age = 22; // а наследовано было null

По одному конструктору может быть много объектов создано с перегруженными свойствами и методами

.constructor - метод объекта, который возвращает функцию- его конструктор
user1.constructor; вернет текст функции User

По аналогии - встроенные функции, которые с большой буквы, например Number() для перевода строки в число - это не что иное как конструкторы.

Соответственно, и другие объекты можно создавать через конструкторы. Всегда ли это целесообразно?
var n = new Number(5);
var s = new String("John");
var b = new Boolean(true);
НО! Тогда это будет все типа object
.valueOf метод для получения содержимого объекта
var n = new Number(56);
n.valueOf();
Особой необходимости не возникает создавать объекты String, Number, Boolean, если только требуется с ними работать как с объектами, что редко

var a = new Array(); // аналог [], можно только пустой создать
удобно будет использовать написание new, если надо указать сразу количество ячеек будущего массива. Передается число Array(5);
В остальном тоже не используется
var o = new Object(); // аналог {}

Чаще конструктор используется для регулярок:
Когда нам надо в регулярное выражение впихнуть данные из массива (см выше).

Кроме наследования придуманных свойств и методов созданного нами конструктора есть еще наследование от глобального объекта, от Array, от глобальнейшего Object

instanceof проверка на наследование у глобального
myObj instanceof Array; является ли объект наследником глобального объекта Array - true false
ТАк, массив [] будет наследником глобального Array и глобального Object тоже

Прототип
Это свойство объекта
.prototype через него добавляется новое какое-то свойство объекту без затрагивания самого глобальнейшего объекта

User.prototype.role = 'admin'; добавит во все объекты конструктора User свойство role: 'admin'

Если имя конструктора неизвестно, то можно через объект - 
john.constructor.prototype.role = 'admin';
Внимание! Если удалить заданное через .prototype свойство/метод из объекта, то оно не удалится, а только вернется к значению по умолчанию, заданное в конструкторе. Значение можно перегружать, но не удалить.
Поэтому рекомендуется новые методы в конструктор добавлять именно через .prototype, чтобы их случайно не затереть и не удалить

Через прототипы можно достучаться до глобальных конструкторов
Можно .prototype добавлять и в глобальные объекты, они так же будут изменены только на лету, в нашем скрипте
Например
function foo() {
	return Array.prototype.slice.call(arguments);
}
foo(1,2,3,4,5,6,8); // вернет массив [1,2,3,4,5,6,8]
Чтобы вернуть массив из переданных значений, обращаемся к глобальному объекту Array
У него есть .prototype, в нем есть .slice
Вызываем функцию .slice как метод объекта arguments, атрибуты не передаем никакие, чтобы slice вернул весь массив полностью.

Например, залезть в объект Number и добавить туда метод pow()
Number.prototype.pow = function(x){
	return Math.pow(this.valueOf(), x);
};
Теперь
var n = 3;
n.pow(2); // 9

.hasOwnProperty(); чтобы новые свойства глобального объекта не использовались
if (user1.hasOwnProperty(i)){
	print(i, ":", user1[i])
}
Выведет объект без использования сторонних прототипов, только по конструктору

Объект Date
Для работы с датой, время в нем хранится в милисекундах
Точка отсчета - от 1 янв 1970
UTC - время без всяких смещений

Работа с датой идет через создание экз объекта Date
var d = new Date(); вернет объект с инфой по текущему дате и времени

Date(1234567890000); передать временную метку количество милисекунд и получить инфу по этой точке

Date(2001,6); год и номер месяца обязательно в определенном порядке - год, месяц, день, часы, мин, сек, миллисек
Вниманиие! Месяцы с нуля, январь - 0, поэтому 5 - июнь. Берет минимально возможное

Date(2011, 10, 40); можно ставить какие угодно цифры - все пересчитает, 32 декабря, например = 1 янв
Время берется с машины, на которой скрипт запущен

Методы:
.getFullYear(); возвращает год
.getMonth(); возвращает мес
.getDate(); возвращает год
.getHours(); возвращает часы
.getMinutes(); возвращает мин
.getSeconds(); возвращает сек
.getMilliseconds(); возвращает миллисек
.getDay(); возвращает номер дня недели. Внимание! 0 - воскресение
.getTimezoneOffset(); смещение GMT мирового времени в мин.
.getTime(); valueOf(); вернет количество миллисек на данный момент с 01.01.1970
по аналогии с ним через экземпляр объекта Date можно вернуть количество миллисек на данный момент
var d = new Date();
d.valueOf(); вернет количество миллисек на данный момент

.toString(); строчное представление даты, возвращает GMT
.toTimeString(); строка с только временем
.toDateString(); строка с только датой

Через set можно формировать даты, те же методы, что выше с get
.setDate(10); вернет дату, все текущее, но число будет заменено на 10
НО! НЕт set-аналога метода .getDay(), т.к. день недели зависит он числа и привязан к дате

Объект Error
Для ошибок
При ошибках весь код останавливается. Замена ошибок
try {
	блок с предполагаемой возможной ошибкой
} catch(e) {
	console.log('!!!'); он при ошибке перескакивает сюда и исполняет это вместо сообщения об ошибке
}
e в данном случае - самосоздающийся экземпляр объекта new Error, у которого свои свойства - 
e.name; возвращает имя ошибки
e.message; возвращает текст ошибки

В некоторых случаях нужно принудительно перекинуть в catch и его задать
try {
	var x = 10;
	var y = 0;
	if (y == 0) {
		throw new Error('На 0 делить нельзя');
	}
	var z = x/y;
} catch(e){
	console.log(e.name);
	console.log(e.message);
}
Это из разряда Exception - исключения, ошибки, которые не останавливают код

Вместо клика
используется только там, где адрес такое псевдо - 
<a href='javascript:func()'>Ссылка</a> исполнит функцию func, описанную выше

BOM - объектная модель браузера

Объект window
Когда просто создаем переменные, то мы создаем их в объекте window. В нем куча других объектов (они для него - свойства)

Свойство - объект navigator 
Содержит инфу о браузере, версия, название, сборка и т.д.

Свойство - объект screen инфа об экране, длина, ширина, разрешение и т.д.
Свойства:
width - ширина монитора с учетом тулбаров
height - высота монитора с учетом тулбаров
availWidth ширина без учета панели задач
availHeight высота без  учета панели задач
colorDepth разрешение битовое

Объект history инфа о кнопках назад и вперед
Имеет свойство .length
history.length - вернет кол-во посещенных страниц

Методы:
.back(); перейти на шаг назад
.forward(); перейти на шаг вперед
.go(); на сколько-то шагов вперед, передается число, с минусом можно - назад шагаем

Свойство - объект location за адресную строку
адрес открытого окна в браузере
"http://www.lol.ru:84/about/index.html?x=10#metka"
C помощью свойств этого объекта можно отловить любую часть адреса

Свойства:
.pathname адрес без учета имени хоста "/about/index.html"
.protocol - вернет "http:"
.hostname - вернет имя хоста "www.lol.ru"
.port - вернет номер порта, по умолчанию если, то пусто (80-й), здесь "84"
.host хост - имя хоста вместе с номером порта - "www.lol.ru:84"
.href адрес весь целиком, с протоколом, хостнэймом, портом, пафом, вопросами, решетками - "http://www.lol.ru:84/about/index.html?x=10#metka"
.search - если в стандартной строке есть ?option=9, к примеру, то сюда попадает то, что после ? вместе с вопросом и до решетки или до конца, если #, то, что с ней, попадает отдельно в hash
.hash то, что после решетки в адресной строке "#main"

Методы location
.reload(false); перезагружает текущую страницу, если тру, то берет из сервера, если фолс - то с кэша (по умолчанию)
.assign('http://ya.ru'); то же, что replace, переход по указанному адресу. Разница в том, что assign заносится в историю, можно нажать назад и попадем на предыдущую страницу
.replace('http://google.com'); подменяет в истории страницу на эту и если нажмем назад, то попадем на ту, что до этой была, до страницы с перенаправлением
.toString(); обращение к href то же самое что location.href

Свойство - объект document сам объект документ, который загружен в окно, dom
Открытый в браузере документ. Свойства:

document.lastModified дата последнего изменения
document.title заголовок документа, можно присваивать новое значение
document.domain происхождение окна, задается, чтобы не блокировался переход с одного на другой, document.domain = 'domainnnname' прописывается в каждом доке, что участвует, он смотрит сюда, а не на адресную строку тогда
document.cookie

Методы объекта document
.open(); открывает поток документа на запись. Но поток и так открыт в момент загрузки в браузере

.write(); запись на лету, после загрузки если вызывается, то перезаписывает
document.write("<style type='text/css'>html{background:#ffc;}</style>");
document.write("<div>Содержимое добавлено из скрипта</div>");
document.write("<div>Содержимое добавлено "+lol+" раз</div>");
Внимание! Если добавляем через write тег script, то закрывающий тег надо обязательно экранировать, иначе криво распознает - <\/script>
Внимание! во write надо писать только строкой, всякие интеры вызывают ошибку.

.close(); аналогично с open, сам делается. Редко используется, например, для перезаписи типа
document.open();
document.write("<html>");
document.write("<h1>Hello!</h1>");
document.write("</html>");
document.close();
НО и здесь document.open(); и document.close(); можно опустить, результат перезаписи будет тот же


Методы объекта window - диалоги. Это по сути window.alert(), но можно писать кратко, тчк не нужны, т.к. window - глобальный объект

alert('Hello'); окно сообщения с ок. Это модальное окно, что означает, что ничего не нажать, пока оно открыто

confirm('ok?'); вопросительное сообщение с ответами "да" "нет"
var x = confirm('ok?'); в переменную х придет ответ - тру или фолс

var x = prompt('Введите возраст', '20'); вторым параметром предлагаемое по умолчанию, а вводить должен пользователь. В переменную х идет набранный ответ пользователя или пустая строка, null в случае нажатия на Отмену.

Методы window - таймеры для интервала, задержки в исполнении чего-то

window.setTimeout(code,1000); отсроченное исполнение какого-то кода после загрузки всей страницы
window.setTimeout("showOnLineUsers()", 3000);
window.setTimeout(function () {}, 50);

x = window.setTimeout(code,1000); код исполняется через 1000 милисекунд, секунды отсчитываются после исполнения всего кода

Обвязка функции
Это упаковывание функции в анонимную функцию, чтобы избавить ее от глобального контекста, в который ее пытается кинуть интерпретатор

Можно писать просто в виде ссылки на функцию foo, если не надо ничего передавать этой функции, если надо что-то передавать, то - функция упаковывается в анонимную функцию
function foo(name) {
	console.log(name);
}
function Timeout() {
	timer = window.setTimeout(function(){foo("John")}, 3000);
}
function Timeout() {
	timer = window.setTimeout(foo, 3000);
}

НО! Обвязка нужна и когда мы работаем с объектом. Его метод может вызываться криво, т.к. он будет пытаться его брать из глобального контекста, где нет его, а он в глобальный выносит только функцию с this-ом, выдрав его из контекста. И под this теперь понимается глобальный объект, а у него нет требуемого метода (.say в данном случае), поэтому он возвращает пустоту
Это же касается и метода .setInterval() тоже
function User(word) {
	this.word = word;
	this.say = function(){
		console.log(this.name);
	};
}
var john = new User("Hello");
function Timeout() {
	timer = window.setTimeout(john.say, 3000);
}
не будет работать, делается обвязка
function Timeout() {
	timer = window.setTimeout(function(){john.say();}, 3000);
}

window.clearTimeout(x); - отмена таймера, заданного в переменной х

x = window.setInterval(code, 1000); исполнение кода, с определенным интервалом в милисек. Каждую сек, например

window.clearInterval(x); отмена таймера, заданного в переменной х, для того, чтобы бесконечно не исполнял

Методы window - окна
Теперь вкладки используются, так что не повлиять и новое окно зачастую - новая вкладка открывается
Свойства

closed - открытое оно или закрытое - для проверки

Методы:
window.open('url', 'name', 'params', history); открывает новое окно, параметры не обязательны, но порядок их соблюдать надо
Но можно передать - адрес, имя окна, ширина окна, высота, добавлять в историю или нет - тру/фолс
var w = window.open('url', 'name', 'width=300, height=300', history); в переменную w пойдет окно, это получается ссылка на объект window того окна, которое открыть

Параметры открываемого окна, которые можно задать:
width ширина окна
height высота окна
left положение слева, если это не вкладка, мало управляемо
top положение сверху, от экрана отсчитывает
location - видна ли адресная строка - да нет
menubar - показывать меню бар файлб правка и т.п. или нет
scroolbars - полосу прокрутки да нет
toolbar - показывать тулбар или нет
status - показывать или нет статус строку
resizable - можно ли менять размер - шире, уже или нет
Пишутся параметры в одних кавычках, через зпт
w = window.open("", 'name','width=200, height=100, location=no');
Внимание! параметры в метод .open принимаются только в виде строки, поэтому если у нас параметры в переменных, то отдельно надо формировать строку, и потом ее сюда передавать
var w = 300, h = 200;
	var left = (screen.availWidth - w) / 2;
	var top = (screen.availHeight - h) / 2;
	var p = "width="+w+",height="+h+",left="+left+",top="+top;
	win = window.open("", 'Новшество', p);

Внимание! По причинам безопасности, в современных браузерах не все параметры будут работать.

.close(); закрытие открытого окна
w.close(); закрыть открытое окно w
window.close(); закрыть само окно, в котором мы находимся

Методы:
.focus(); - то, что активное на переднем плане
.blur(); - на задний план
window.print(); открывает окно печати браузера

Методы манипуляции окном
.moveTo(x,y); передвигать окно по абсолютным единицам х и у, перескакивает
.moveBy(x,y); передвигать относительно позиции самого окна
.resizeTo(x,y); менять ширину - высоту
.resizeBy(x,y); относительное
.scroolTo(x,y); скроллинг на определенную точку
.scroolBy(x,y); меняем ширину и высоту относительно первоначального размера

Отношения между окнами
У новооткрытого окна есть свой объект window, у которого есть свойства:
window.opener; вернет ссылку на то окно, которое его открыло
window.self; ссылка на само себя, текущее окно

Фреймы
Это то же самое, что окна, только встроенные в родительское окно. Далее - встроенные окна называем окошки, родительское окно называем окно

Вспомним свойства объекта window (см выше)
.document();
.location();
.history();
.navigator();
.screen();
.status();

есть еще
window.frames(); это ссылка на специальный объект - Коллекция окошек, связанных с данным окном
По аналогии с коллекцией arguments,
html-коллекция frames - что-то наподобие массива, у которого одно только свойство - length. 

В коде окна iframe подключается так:
<iframe name='top' src='top.php'></iframe>
<iframe name='bottom' src='bottom.php'></iframe>

window.frames[0]; обращение к первому iframe как к элементу массива
window.frames['top']; можно по имени
window.frames.top; обращение как к свойству объекта коллекции

var x = window.frames[0]; обращение в главном окне к подключенному сюда окошку, в котором объявлена переменная sin
x.sin;

Из окошка можно обратиться к родительскому окну
Для этого свойства объекта window у окошка:

window.parent - родительское окно, для окошка родитель - то окно, в котором оно показано
window.parent.g(); внутри окошка мы вызвали функцию g(), которая объявлена в родительском окне
window.parent.parent.g(); родитель родителя, например, если фрейм во фрейме

window.top - обращение к родителю всех родителей, самому верхнему окну
window.top.g(); внутри окошка мы вызвали функцию g(), которая объявлена в самом верхнем окне, родителе всех родителей

name - если у окна есть это свойство в iframe, через него можно обратиться

Объект Document

Тоже содержит HTML-коллекции
Внимание! Помним, что у массивоподобного объекта коллекции есть только одно свойство - length, возвращает количество элементов коллекции
Есть древние коллекции, которые уже не используются - 
document.applets
document.embeds

Но другие используются - 

Коллекция links - ссылки
document.links; вернет коллекцию ссылок
var x = document.links[0]; вернет первую ссылку из коллекции целиком <a href="lol.rru">войти</a>
x.href; вернет href первой ссылки, так и другие атрибуты можно выдернуть

Коллекция images - изображения
document.images; вернет коллекцию картинок
document.images[0]; вернет первую картинку из коллекции целиком <img src="lll.jpg" alt="foooo">
По аналогии с ссылкой, можно любой атрибут выдергивать через тчк.

Объект, который возвращает коллекция images, называется HTMLImageElement
А все атрибуты - его свойства
Свойства:
То же самое - можно возвращать, можно менять
.src
.alt
.width
.height
.border

Есть также специальный конструктор для создания изображений - Image
var img = new Image(300,200); создать картинку, передается ширина, высота
img.src = "tyyy.jpg";
Фишка в том, что он картинку сразу загружает, когда ей передан данный адрес, а не потом

Коллекция forms - формы
document.forms; возвращает содержимое форм
document.forms[0]; вернет первую форму из коллекции целиком код
document.forms['name']; можно по имени обратиться
document.forms.name; можно через дот нотэйшн по имени обратиться
По аналогии, можно любой атрибут выдергивать через тчк.
var x = document.forms.name;
x.action; вернет атрибут формы action

Атрибуты можно менять и задавать!!!
Внимание! Если атрибуты многомерные, как например, <a style="background: #000;">, то обращение к свойствам атрибута будет так же через тчк - .style.background;
НО! Если стилевое свойство имеет дефис, то оно пишется слитно, а слова за дефисом - с большой буквы
.style.backgroundColor;
x.action = "lol.ru"; установит в атрибуте action соответственную запись
document.links[0].style.color = "red";

Конфликт имен
НО! Есть слова, которые могут конфликтовать с названиями команд js, поэтому для них написание другое - приплюсовывается приставка html (если оно html-ное) или css (если из css) и пишутся с большой буквы:
<label for="lll">
label.htmlFor;

<a style="float: left;">
style.cssFloat;

Также зарезервировано слово class, вместо него нужно использовать className
<a class="lol">
document.links[0].className;

Объект, который возвращает коллекция forms, называется HTMLFormElement
А все атрибуты - его свойства
Свойства:
.name
.action
.enctype
.method
.target

Специфические свойства, их 2:
.elements; коллекция элементов формы - инпуты и т.д., которые в форме. В коллекции они, помним, в массиве, виде кода, целиком со всеми атрибутами и т.д.
document.forms[0].length; вернет количество элементов данной формы, это все равно что запись document.forms[0].elements.length;
Внимание! Если у инпутов несколько одинаковых имен, а надо обратиться к какому-то одному, то можно использовать порядковый номер
var f = document.forms[0];
f.elements.name[1]

Методы объекта HTMLFormElement:
var f = document.forms[0];
f.submit(); посылает форму программно, аналог нажатия кнопки submit
f.reset(); очищает форму

Вместо простых кнопок <button type="submit">Отправить</button><button type="reset">Сбросить</button>
Просто ставим ссылки на функцию js, которые это выполняют через методы
<a href="javascript:r()">Ресет</a>
function r() {
	var f = document.search;
	f.submit();
}

Объект, который возвращает коллекция elements, называется HTMLInputElement
Свойства:
По аналогии - это любые атрибуты input-ов, которые можно менять + специфические
.form вернет форму, в которой он находится
.defaultValue значение по умолчанию вэлью есть или нет

.defaultChecked чекнутое значение по умолчанию
f.defaultChecked = true; 

.checked текущее значение флажка или радио-кнопки.
f.checked = true; установит флажок

.maxLength
.type
.value текущее значение, если его менять и потом делать резет, то оно вернется к значению по умолчанию. Значение по умолчанию меняется через .defaultValue
.size
.name
и др атрибуты

Методы объекта HTMLInputElement:
.select(); выделить
.click(); кликнуть
f.elements.name.click(); - кликнет по указанному элементу
.focus(); фокус
.blur(); антифокус

Еще объект, который возвращает коллекция elements, называется HTMLTextAreaElement
Свойства:
По аналогии - это любые атрибуты input-ов, которые можно менять + специфические
.defaultValue
.form
.value
.type
.cols
.rows
.readOnly
.tabIndex
.disabled тру фолс

Методы:
.select();
.focus();
.blur();

var frm = document.getElementById('frmLogin');
frm.style.display = 'block';

Еще объект, который возвращает коллекция elements, называется HTMLSelectElement

Свойства:
По аналогии - это любые атрибуты input-ов, которые можно менять + специфические
.options коллекция элементов .options
.length количество элементов коллекции .options (по аналогии с коллекцией .elements)
.type тип, стандартный select-one или select-multiple
.selectedIndex возвращает номер выделенного option-а в селекте если ни один не выделен, то минус 1 вернет (индексы считаются c 0)
Внимание! Если множественный селект с multiple, то .selectedIndex вернет первый из выбранных опшнов

.value
.form ссылка на родительскую форму, как и у инпута
.disabled
.multiple - многомерный, тру или фолс возвращает
.name
.size
.tabIndex

var categ = document.getElementById('id'); выбрали элемент select по id
var catSel = categ.options[categ.selectedIndex].value; выборка выделеного пункта

Методы:
.add(); - добавлять пункты
.remove(); - удалять пункты
.focus();
.blur();
select.add(newO, curO);  используется в IE

Внутри селекта есть коллекция options
Свойства:
.form
.text; вернет текст между <option></option>
.defaultSelected; вернет тру-фолс, по умолчанию выбран элемент или нет
.index; вернет индекс элемента в общем списке опшнов 
.value; вернет значение value, если оно есть
.selected; вернет тру-фолс, выбран элемент или нет
.disabled
.label
var o = new Option('php5','php'); передали текст и значение

Конструктор Option
Сделан для добавления пунктов <option></option>
Option(text,value,defaultSelected,selected);
параметры не обязательные все, их можно потом передать, через свойства
text - см выше
value - см выше
defaultSelected - см выше
selected - см выше

var op = new Option('PHP5', 'php');
НО! После создания новый option еще непонятно где летает, его надо прикрепить к селекту через метод add

select.add(op, f.options[0]); вставить нулевым элементом

Внимание! Для кроссбраузерности используется try-catch
try {
	select.add(op, null);
} catch(e){
	select.add(op);
}

Фишка блокировки до полной загрузки
Для защиты принято делать desabled у инпутов и ссылок в коде html и в конце згрузки всех параметров программно его снимать
<label for="selURL" disabled>Выберите адрес</label>
a{visibility:hidden}
var f = document.myForm; // или s.form
		for (var i=0; i < f.elements.length; i++){
			f.elements[i].disabled = false;
		}
document.links[0].style.visibility = "visible";

Еще табличный объект, который возвращает коллекция elements, называется HTMLTableElement

Свойства:
По аналогии - это любые атрибуты таблицы, которые можно возвращать, а можно менять + специфические
.tHead вернет хедер таблицы кодом, с тегами и содержимым - тр, тд-шки
.tFoot вернет футер таблицы кодом, с тегами и содержимым - тр, тд-шки
.tBodies[] возвращает коллекцию из tbody кодом, с тегами и содержимым - тр, тд-шки
.rows[] коллекция tr-ов кодом, с содержимым
.caption вернет заголовок таблицы <caption>Заголовок</caption>
.width
.border
.cellPadding
.cellSpacing

Методы:
.createCaption(); создать элемент caption - заголовок
.deleteCaption(); удалить элемент caption
.createTHead(); создать tHead
.deleteTHead(); удалить tHead
.createTFoot(); создать tFoot
.deleteTFoot(); удалить tFoot
.insertRow(2); создать tr вторым по счету среди tr-ов
.deleteRow(2); удалить tr второй

Для .tHead, .tFoot, .tBodies[] есть специальный
HTMLTableSectionElement
Свойства:
.rows - коллекция tr-ов
.align
.vAlign

 Методы:
.insertRow(index); вставить элемент tr по счету каким-то
.deleteRow(index); удалить элемент tr

var tr = tableBooks.insertRow(tableBooks.rows.length);
var tdAuthor = tr.insertCell(tr.cells.length);

У tr есть HTMLTableRowElement
Свойства:
.cells это td
.rowIndex 
.selectionRowIndex индекс в массиве Rows секции
.vAlign
.bgColor

Методы:
insertCell(index); добавлять td
deleteCell(index); удалять td

Специально для TD - HTMLTableCellElement
Свойства:
.cellIndex
.colSpan
.rowSpan
.align
.vAlign
.width
.height
.textContent - выборка значения всех текстовых узлов внутри на любой глубине узла
.innerHTML


Объектная модель документа DOM2
Document Object Model
Межъязыковой стандарт
Все есть узлы (ноды)
Типы узлов с кодами:
1 ELEMENT - элемент - тег с содержимым <p>...</p>
2 ATTRIBUTE - атрибут - атрибут тега align="center"
Внимание! К атрибутам доступ осуществляется особым образом, не напрямую, а через элемент, у коготоро эти атрибуты
3 TEXT - текст - текстовый узел
8 COMMENT - комментарий <!-- comm -->
9 DOCUMENT - документ - document
10 DocumentType декларация типа документа <!Doctype...>

Node - абстрактный узел для универсальности везде, где есть поддержка DOM

Эти узлы - все объекты и у них есть свои методы и свойства
Свойства всех узлов:
.parentNode - родитель, узел, в который вложен данный узел 
<div><p></p></div>
var d = p.parentNode, вернет div

.childNodes вернется коллекция всех детей.
Внимание! Если множественное число написано в названии команды - то коллекция возвращается
Внимание! Внимание! В ноды он записывает и невидимые пробелы вайт-спейсы, которые непечатанные символы табуляции. Он оформляет это как #text с параметрами. И считает каждый отступ ребенком

.firstChild первый дочерний
.lastChild последний дочерний
.nextSibling следующий среди братьев-сетер
.previousSibling предыдущий среди братьев-сетер
.ownerDocument редко используется. Ссылка на сам документ

.nodeName возвращает абстрактное имя, имя тега - p,div
.nodeType возвращается номер - тип узла (см выше коды типов)
.nodeValue только для текстового узла. Возвращает содержимое его. МОжно присваивать свое значение. У остальных узлов возвращает null
.textContent - выборка значения всех текстовых узлов сразу из элемента, на любой глубине

Методы Нодов:
hasChildNodes(); узнать, есть дети или нет - фолс тру
while(tableBooks.hasChildNodes())
	tableBooks.removeChild(tableBooks.lastChild); очистка таблицы от всех ее детей, если она не пуста


Интерфейс Element
Это элемент узла
Свойства, плюс к свойствам Node:
.tagName - то же самое, что и nodeName

Методы + к методам Node:
getElementsByTagName('t'); имя тега передается, возвращает все с теги с таким именем - коллекцию любого уровня
Если надо один конкретный, то в [] нужно указать номер
hasAttribute(a); имеет ли элемент такой атрибут - тру фолс
getAttribute(a); возвращает атрибут
setAttribute("атр","значен"); изменяет атрибут, если его нет, то создаст
removeAttribute(a); удаление атрибута

перебрать коллекцию, например, все p, в цикле можно, он их нумерует в коллекции
allP = document.getElementsByTagName('p');
for (var i = 0; i < allP.length; i++) {
	var p = allP[i];
	действия с р
}

Проще перемещаться по дереву DOM через интерфейс Document
Документ - это тоже узел.
Свойства, включая все свойства узла
.defaultView - parentView(IE)
document.documentElement выборка корневого элемента document.documentElement вернет <html> c содержимым
document.body непосредственно выбирает боди
document.styleSheets доступ к коллекции стилей
document.doctype

Коллекция стилей

Методы document, плюс ко всем методам Node:
.getElementsByTagName(t); выборка всех по имени тега
.getElementById(i); выборка по id
.createComment(s); создание на лету
.createElement(t); создание элемента
.createTextNode(s); 
.createDocumentFragment(); создание фрагмента, чтобы добавлять большой код отдельно созданный
var i = document.createElement('em');
i.appendChild(document.createTextNode("текстик"));
var b = document.createElement('strong');
b.appendChild(document.createTextNode("bold"));
var f = document.createDocumentFragment();
f.appendChild('i');
f.appendChild('b');
В итоге получается фрагмент, в который мы можем подбавлять детей и который мы можем вставлять куда угодно
di.insertBefore('f');
Внимание! Когда фрагмент нужно вставить в несколько мест сразу, надо использовать клонирование
var d = document.getElementsByTagName('div');
for (var i=0; i<d.length; i++) {
	div[i].appendChild(f.cloneNode(true));
}

Создание:
создаем текстовый узел 
var p = document.createElement('p'); вернул новый узел в воздухе 
var txt = document.createTextNode('text'); создал еще один узел текст в воздухе 
p.appendChild(txt); вложим одно в другое на лету, все еще в воздухе 
document.body.appendChild(p); теперь не в воздухе, а вставится в указанном месте

Внимание! Можно писать это все слитно - 
var t = d.appendChild(document.createElement('table'));

.cloneNode(b); клонирование, передаем тру, чтобы он взял содержимое вместе с тегом, фолс, чтоб пустые теги
.appendChild(e); для вставки, вставить последним элементом, если надо вырезать, то без клона можно что-то вставить, переместит его
.insertBefore(e,p);  для вставки перед чем-то, вставить е перед р

.replaceChild(e,p); поменять ребенка, на место е поставить р
var y = d.replaceChild(e,p); на место е поставить р, при этом е не удалить, а вернуть в переменную у

.removeChild(e); удаление ребенка
var io = d.removeChild(e); удаляет ребенка, и при этом возвращает в переменную io
var ul = getElementById('IdUl');
while(ul.hasChildNodes())
	ul.removeChild(ul.lastChild);
Здесь покуда есть дети, их удалять изнутри ul-а


Нестандартные свойства и методы
Это те, которые не в спецификации, но все браузеры поддерживают все равно

.innerHTML 
Его можно использовать как аналог .createElement()
Возвращает внутренность, код в виде текста, позволяет вставить/получить внутренность элемента d.innerHTML вернет все, что внутри тега d, без огранки дива. 

d.innerHTML = ''; пустоту вставить в элемент d

И через innerHTML можно создавать так же элементы из любого места, не только от document, как createElement
var red = 8;
var d = document.getElementById('lol');
d.innerHTML = "<p>Текст</p>"+rad; заполнит текстом элемент "Текст8", в тегах, распарсит сам текстовую ноду, как надо

Это тот же createElement со всей цепочкой создания на лету, поэтому медленнее работает. Но не всегда, иногда работает быстрее

Псевдопротоколы
javascript:код 
можно писать прям в адресной строке браузера, он его исполнит. 
На этом основаны bookmarclets, это типа проги на лету из адресной строки

offsetWidth
offsetHeight
offsetParent
scrollWidth
scrollHeight
scrollLeft
scrollTop
clientWidth
clientHeight

Методы:
scrollIntoView(b);

iframe
Чтоб к нему обратиться, вместо document нужно использовать contentDocument
В остальном все то же самое

События
Можно вешать их на любые элементы
Пишутся:
<p id="b" onclick="f()">Кликни</p>
или
tr.onmouseover = new Function("trHighLight(this, '#fcc')");

Некоторые события можно отменять (убирать умолчание, например, у <a> есть встроенное событие onclick)
onclick - клик мышкой (можно отменить)

onmousedown - нажали клавишу мышки
onmouseup - отпустили клавишу мышки
onmousemove - двигает мышкой
onmouseover - мышь заходит на какой-то элемент
tr.onmouseover = new Function("trHighLight(this, '#fcc')"); при попадании на тр подсветка
tr.onmouseout = new Function("trHighLight(this, '')"); при уходе с тр подсветка исчезает, в виде объекта сделано чтобы передавать параметры

onmouseout мышь уходит с элемента

События, которые работают на <body>, <input>, <textarea>
onkeydown - клавиша нажата (можно отменить)
onkeypress - оба - нажал и отпустил (можно отменить)
onkeyup - клавиша отпущена

Для <body>, <input>, <textarea>, <a>, <area>, <button>, <label>, <select>
onfocus в фокусе
onblur в антифокусе

Для <body>, <frameset>,<iframe>,<img>,<object>
onload событие срабатывает когда полностью загружено и выстроено

Для <body>, <frameset>
onunload - при уходе со страницы

Для <img>,<object>
onabort - при загрузке чего-то если чел нажал "отмена"

Для <body>, <frameset>,<img>,<object>
onerror - при загрузке, если недогрузилось что-то

Для <body>, <frameset>,<iframe>
onresize - при изменении размера окна

Для <form>
onsubmit - перед отправкой после нажатия сабмит (можно отменить)
onreset - при нажатии на сабмит (можно отменить)

Для <input>,<textarea>
onselect

Для <input>,<textarea>,<select>
onchange - при изменении значения
В инпуте и текстарее onchange срабатывает при потере фокуса, типа написал и кликнуть по воздуху, тогда сработает событие onchange

Для <body> и элементов с прокруткой
obscroll - при прокрутке

Можно события привязывать и к самому окну, а не к элементам, к window и к document
События:
onfocus
onblur
onload
onunload
onerror
onresize
onscroll

document:
onkeydown
onkeypress
onkeyup

Типы моделей событий бывают разные - 
Базовая (исходная) модель
Фишка в том, что каждое событие при назначении становится свойством элемента.
<p id="b" onclick="f()">Кликни</p>
Чтоб отменить действие по умолчанию, вставляем return false
<form action="" onsubmit="f(); return false">
или <form action="" onsubmit="return f();">, а внутри функции f проверка и фолс ретерн.
Здесь отменяется действие отправки формы, прилепленное пo умолчанию на submit

this
Если вставить this, то передается конкретный элемент, по которому кликаем
<p id="p1" onclick="foo(this)">Кликни</p>
<p id="p2" onclick="foo(this)">Кликни</p>
<p id="p3" onclick="foo(this)">Кликни</p>
function foo(at) {
	console.log(at);
}
Вернет данный текущий кликнутый элемент полностью

Если по другому привязываем событие, то через него можно выйти на элемент так:
function aClick(e){
console.log(e.target);
}
Вернет кликнутый элемент из объекта события

Можно событие писать через точку, тогда функцию пишем без круглых скобок, т.к. фактически мы присваиваем тело функции, а не просим ее вызвать

document.forms[0].onsubmit = f;
Все равно, что
document.forms[0].onsubmit = function() {
	alert('hello');
};
Как же быть с параметрами?
Присваиваем не напрямую, а косвенно
document.forms[0].onsubmit = test;
new Function('test(this, 'param')');

Если надо приделать несколько функций, то запаковать их надо в безымянную функцию
d.onclick = function() {
	bar1.call(d);
	bar2.call(d);
}

Всплытие пузырьков

Всплытие - это когда клик на ребенка - это же и клик на родителя, поэтому могут сработать несколько одноименных событий один за другим
.stopPropagation();
.cancelBubble = true; для IE
Конструкция пишется к самому событию в функции после действия
function foo(e) {
	e = e || event;
	console.log(e.target);
	e.stopPropagation();
}

W3C DOM модель
Через метод .addEventListener("click", foo, false);
d.addEventListener("click", foo, false); первым параметром - событие без on, вторым - функция, которая исполняется и третьим - защита от всплытия - фолс
У IE другой - метод .attachEvent("onclick",foo);
Поэтому для кроссбраузерности (иначе может ошибка быть) используется трай-кэтч
try {
	d.addEventListener("click", foo, false);
} catch(e){
	d.attachEvent("onclick",foo);
}

Часто используется трай и кэч в этом, поэтому принято пистаь обертку для удобства - универсальную функцию
function addHandler(el,ev, fo) {
	try {
	el.addEventListener(ev, fo, false);
} catch(e){
	el.attachEvent("on"+ev,fo);
}
}
И используем, без проблем привязываются несколько функций на одно событие
addHandler(d, "click", foo);
addHandler(d, "click", bar);

.removeEventListener(); метод для отмены события
.detachEvent(); метод для отмены события в IE
Соответственно, снова используется универсальная функция
function removeHandler(el,ev, fo) {
	try {
	el.removeEventListener(ev, fo);
} catch(e){
	el.detachEvent("on"+ev,fo);
}
}
Внимание! Можно в создании события использовать анонимную функцию, но при отмене надо вместо функции писать ссылку, иначе не отменит.

Как вернуть событие с его свойствами

function foo(e) {}
Если в функцию передать какой-нибудь просто параметр, то современные браузеры автоматом в нее кидают объект с информацией
Но для IE есть специальный объект для событий - window.event и нужен костыль:
function foo(e) {
	e = e || event;
}

Отменить действие по умолчанию
Например я хочу, чтобы что-то было по ссылке <a>, но чтобы переход за этим не происходил
В навешиваемой функции на <a>, например, пишем
function foo(e) {
	e = e || event;
	try {
		e.preventDefault();
	} catch(){
		e.returnValue = false;
	}
}


Свойства событий. Свойства Объекта Event
Любой источник:
type - вернет тип события в виде строки
target (у дом) и srcElement у IE вернет ссылку на элемент, в котором произошло событие (по которому событие кликнули, например)
currentTarget (у дом) и srcElement у IE - возвращает текущий элемент,  в котором сейчас конкретно происходит событие, это м.б. родитель этого элемента, на который кликнули, если эффект всплытия происходит

Источник - мышь:
.button - какая кнопка нажата, 1 - левая, но число может быть разным в зависимости от браузера или ноута или компа
.altKey, ctrlKey, shiftKey тру-фолс возвращает, если при клике мыши были зажаты alt, ctrl или shift
.clientX, clientY - точки, куда было кликнуто, координаты курсора, когда клик произошел

Клава:
.keyCode - если источник кликов - клава

Поэтому можно прописать вверху
window.onload = function(){}
и он после загрузки будет исполнять только

Фишка - Вставка по шаблону
Иногда бывает нужно спрятать код скрипта, например, если сного слайдов, переносим их код в массив объектов, который либо в конце документа, либо в отдельном файле js, который мы подключаем
Изначально код html
<ul>
	<li><img src="img/red.jpg" alt=""></li>
	<li><img src="img/green.jpg" alt=""></li>
	<li><img src="img/yellow.jpg" alt=""></li>
	<li><img src="img/blue.jpg" alt=""></li>
</ul>

делаем следующее:
создаем где-нибудь внизу этого html-документа <script>, а котором будет массив объектов (dictionary), каждый объект отвечает за каждую картинку
var aImgs = [
	{src: 'img/red.gif', alt: 'red'},
	{src: 'img/green.gif', alt: 'green'},
	{src: 'img/yellow.gif', alt: 'yellow'},
	{src: 'img/blue.gif', alt: 'blue'}
];

Выше, тоже в <script> пишем шаблон вставки. Скрываем этот шаблон посредством неизвестного браузеру тайпа <script id="myTpl" type="jquery/template"> и внутри пишем шаблон:
<li><img src="{{src}}" alt="{{alt}}"></li>
Используем шаблонизаторы, спец переменные, придуманные нами {{src}} и {{alt}}

Далее, в конце этого же документа, в <script> пишем на ойгукн (на js тоже можно) фишку лепки из этого шаблона тегов html и их вставка
var tpl = $("#myTpl").html();
var text = "";
$.each(aImgs, function(key, val) {
	text += tpl.replace(/{{src}}/ig, val.src).replace(/{{alt}}/ig, val.alt);
});
$("div.view ul").append(text);

Это был велоспед, для подобных целей существуют шаблонизаторы, которые позволяют делать большее. Например handlerbars
сайт handlerbars.js.com
handlerbars - шаблонизатор для ойгукн и js, популярный

Качаем файл handlerbars.js, подключаем его к файлу
Фишка в том, что мы снова создаем нераспознаваемый скрипт:
<script id="myTemplate" type="text/x-handlebars-template">
</script>

внутри скрипта можно написать любой шаблон cо специальными переменными:
{{#each this}}
<li><img src='{{src}}' alt='{{alt}}'></li>
{{/each}}
Ключевое слово each для того, чтобы handlerbars делал присваивание деталей шаблона в цикле, каждому объекту, если мы передаем массив объектов. Если объект один, то без each

Сами li-шки мы размещаем в отдельном файле, там они убраны объектами в массив aImgs, файл подключен к документу

Для вставки пишем
<script>
	var tmp = Handlebars.compile($.trim($('#myTemplate').html()));
	$('div.view').append(tmp(aImgs));
</script>
В tpl будет функция, в нее передаем массив и он возвращает заполненный шаблон, где уже все подставлено



NODE JS
Это хромовский движок с модулями нодами
Модулей огромное кол-во

Поддерживает ECMA 5

Чтоб запустить скрипт через командную строку, надо в ней перейти сперва к папке
cd F:\openserv\js
И потом имя файа с расширением
ctrl+c дважды для выхода, когда под собственным сервером сидим, то один раз

require('fs'); подключение определенного модуля fs, который работает с файловой системы, некий объект

fs.readFileSync('file.txt'); зачитать файл файловой системы синхронно
fs.readFile('file.txt', function (err, content) {
	console.log(decodeURIComponent(content));
}); асинхронно читать файл из ФС, то есть отмечает и идет дальше по коду, вторым параметром передается функция обратного вызова, что с этим файлом делать. В этом случае он сперва исполняет код, который далее, а потом этот

decodeURIComponent(content) перекодировка
encodeURIComponent(lol) перестраховка от несоответствия кодировок, перекодирует в проценты всякие


var app = http.createServer(function (request, response) {
	response.writeHead(200);
	response.write('Hello, world!');
	response.end();
}).listen(8080); - для создания сервера, передана должна быть функция передачи и возвращения начальных значений и сразу ставим на чтение порт 8080
На сервер выход через браузер адрес localhost:8080

Документация Node.js 'http://nodejs.org/api/http.html#http_response_writehead_statuscode_reasonphrase_headers'
Потому что дофига модулей, надо знать, куда чего искать и все не упомнить

Передача заголовков
оформляется в виде объекта - заголовок: значение
res.writeHead(200, 
		{'Content-type':'text/html;charset=utf-8'});














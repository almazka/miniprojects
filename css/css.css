********************************
************ Ссылки ************
********************************
css3pie.com - для кроссбраузерности

csszengarden.com - интересные примеры стилей и фишечек
http://jscrollpane.kelvinluck.com/ - стилизованные полосы прокрутки
lesscss.ru - LESS
sass-lang.com - SAS

http://matthewjamestaylor.com/blog/equal-height-columns-cross-browser-css-no-hacks - блог Тейлора, много фич по верстке

http://xhtml.ru/instr/3col_creator/ - генератор колонок, за 5 сек все делает и выдает готовый код

Для прописывания ускорения-замедления вручную есть специальный сайт http://matthewlein.com/ceaser/
Есть коллекция готовых анимаций Animate.css: http://daneden.me/animate/

favicon-generator.org/editor - рисовка фавиконки онлайн, рисуем и готовую ссылку формирует и сохраняем картинку

google.com/fonts - шрифты, которые удобно использовать онлайн

jqueryui.com - там куча всяких кнопок, можно стили брать чекбоксов, инпутов

********************************
********* Комбинаторы *********
********************************
Это всякие > в селекторах.
h4 > span - дочерние
h4 + li - элемент li, идущий после h4
h4 ~ li - все элементы li, идущие после h4

********************************
********* Псевдоклассы *********
********************************
:link {
	не нажатые ссылки
} 
:hover
:active
:focus

Структурные псевдоклассы
:nth-child()
:nth-last-child() - нумерация с конца
:first-child
:last-child
::before
::after

********************************
*********** Атрибуты ***********
********************************
Выбрать по атрибутам
a[title] - все <a>, у которых есть title
a[title="my"]
a[title~="my"] у этого элемента есть пробелы и указанное знаечние
a[title|="my"] у элемента title начинается на "my", и дальше либо ничего, либо продолжение через тире
a[title^="my"] стрибут title начинается с "my"
a[title*="my"] ваще встречается в любом месте атрибута тайтл
a[title$="my"] заканчивается на


********************************
********* whitespaces **********
********************************
	Проявляются в li тем, что меж ними появляются пробелы, которые нигде не прописаны. Это тебуляция из кода
	Пробелы убираются так:
	ul {
	font-size: 0;
	}
	ul li {
	font-size: 12px; или сколько надо
	}

********************************
******** Разные display ********
********************************

{
	display: block; блок отличен тем, что 100 проц ширину занимает
	
	display: inline; занимает ширину только по текстовому содержимому внутри
	
	display: inline-block; один за другим, но блоки
	
	display: list-item; задает параграфам пункты
	display: table; будет вести себя как таблица
}

Внимание! Если задавать нумерованный список, то Firefox его не умеет нумеровать корректно

Внмание! Пункты появляются, но для их отображения нужен падинг слева.

********************************
********** Для текста **********
********************************
{
	white-space: nowrap; убрать перенос текста, если он не влазит, должен влезть
}


********************************
************ margin ************
********************************
Коллапсы мэрджинов:

Схлопывание вертикальных margin-ов - collapse. 
Это значит, что если margin один над другим находит на другой, то они как тени, входят др в др и расстояние не увеличивается
Правило 1: если пересекаются два мэрджина с одинаковым знаком, побеждает тот, который больше по модулю
Например, 100 и 50, 100 все "съедает" и расстояние 100.

Правило 2: если знаки разные, то происходит сложение этих величин.
Например, 50 и -100 дает -50

Горизонтальные не схлопываются, а суммируются

Утекание margin-а
Если у дочернего элемента задан мэрджин, а у родительского не задан, то от дочернего маргин перетекает к родительскому, ЕСЛИ у родителя не задан ограничитель margin-а, если задан - то margin нормально применится к дочернему. Если нет, то от родительского он перетекает к его родителю и так по цепочке
Ограничители (у родителя):
{
border (можно сделать transparent)
padding (символически можно 1px)
overflow: hidden;
}

Внимание! При float-е не работает коллапс мэрджинов!

Значение auto {
margin: 0 auto;
}
делает 0 сверху-снизу и авто по бокам. Он выравнивается (при условии, что он блок) относительно родительского элемента.

********************************
****** Строчные элементы ******
********************************
Особенности:
Внимание! У строчных элементов margin работает только горизонтальный, а вертикальный - нет.

У строчных элементов даже padding не отодвигает сам элемент, даже с бордюром, он будет спокойно заходить на другие элементы, пока его не сделаем блочным

Строчным элементам бесполезно задавать ширину и высоту, т.к. она у них все равно определяется содержимым

Внимание! Задание любого position, кроме static делает элемент блочным

********************************
************ Текст ************
********************************
Желательно указывать несколько шрифтов через зпт, т.к. не везде есть первый шрифт, например, в Убунту нет шифта Tahoma, и пользователь будет видеть текст по-умолчанию (Таймс нью роман)
font-family: Tahoma, Sans Serif, Arial;

Размер текста в em
Это относительная единица. Размер шрифта устанавливается в рависимости от размера шрифта родительского элемента. Это равносильно процентам
{
	font-size: 0.5em; это все равно что 50%
}

Регистр
{
	text-transform: uppercase; все заглавными
	text-transform: lowercase; все маленькими
	text-transform: capitalize; каждое слово с заглавной
}

Выравнивание
Выполняется аналогично выравниванию в текстовом редакторе
{
	text-align: center; по центру
	text-align: justify; по ширине, последняя строчка слева
	text-indent: 9px; абзацный отступ
	letter-spacing: 3px; расстояние меж буквами. С отрицательным значением можно обратить текст
}

Тень текста
{
	text-shadow: 0 1px 0 #eee; дает такую белую обводку тексту
}

Использование нестандартных шрифтов
@font-face {
	font-family: PTSans, Arial; надо обязательно писать дополнительный, т.к. не везде это работает
	src: url(font.ttf);
	font-weight: normal;
}
@font-face {
	font-family: PTSans, Arial;
	src: url(fontb.ttf);
	font-weight: bold;
}
Более кроссбраузерный вариант:
@font-face {
	font-family: PTSans, Arial;
	src: url(fontb.eot);
	src: local('imya'), 
	url(fontb.woff) format('woff'),
	url(fontb.ttf) format('truetype'),
	url(fontb.swg) format('swg');
	font-style: normal;
	font-weight: normal;
}

********************************
****** Кроссбраузерность ******
********************************
Условные комментарии
Пишутся в коде html

Применяются для кроссбраузерной верстки. В них залазит только IE
<!--[if lte IE 7]>
<style type="text/css">
#st {
	
}
</style>
<![endif]-->
Стили, прописанные в нем сработают только в IE 6-7
Можно и ссылу на файл разместить в <style>, или текст
<!--[if lte IE 7]>
<h1>Обновите браузер!</h1>
<![endif]-->
Конбинация в emmet - cc:ie

hasLayout

Только для IE
Элементы взаимодействуют др с др только когда у них есть свойство hasLayout. Оно явно никак не задается.
Оно появляется, если у элемента есть хоть одни из этих параметров:
{
	width (кроме auto)
	height (кроме auto)
	float (кроме none)
	zoom (кроме normal)
	zoom: 1; используется для этого, не увеличивает масштаб, но hasLayout появляется
}
<!--[if lte IE 7]>
<style type="text/css">
#st {
zoom: 1;
}
</style>
<![endif]-->

Через PIE
Папку PIE скачиваем с сайта css3pie.com и засовываем в корневую папку сайта рядом со всякими папками images 
При прописывании pie надо правильно прописывать путь, на локале работает некорректно, путь должен быть абсолютным

В место после кода, который в IE не работает, после каждого надо прописать:
behavior: url(path/to/PIE.htc);

#style {
	bottom: 1px;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;
	behavior: url(http://alio.ru/to/pie/PIE.htc);
}
********************************
************ border ************
********************************
{
	border-radius: 20px/10px; значит, что борма будет эллипс и радиусы его будут 20 (горизонт) и 10 (вертикал)
	-webkit-border-bottom-right-radius: 10px 40px;
	        border-bottom-right-radius: 10px 40px; если надо создать неравномерное скругление какого-то угла
	-webkit-border-radius: 50%; получаем круг
	        border-radius: 50%; получаем круг
}

********************************
*********** overflow ***********
********************************
{
	overflow: scroll; прокрутка, но она страшная по-умолчанию
	overflow-x: scroll; прокрутка только горизональная, а
	overflow-y: hidden; прятать вертикальную полосу прокрутки
	overflow: auto; делает прокрутку, если содержимое не умещается
}
Красивую полосу прокрутки можно сделать вручную, но в инете полно готовых, например на сайте http://jscrollpane.kelvinluck.com/

********************************
***** min-max-width-height *****
********************************
При сжатии не уменьшает меньше, чем задано, или больше при увеличении
{
min-width: 500px;
}
Минимальная ширина 500 пикс, при растягивании занимает 500 пикс, при сжатии отнка - уменьшается вместе с ним.

В IE не работает min,max, там через комментарии пишется просто ширина
<!--[if lte IE 7]>
<style type="text/css">
#st {
width: 600px;
}
</style>
<![endif]-->

********************************
********** background **********
********************************
{
	background-origin: padding-box; это по умолчанию стоит, фон под пэдингом
	background-origin: border-box; фон захватывает область под бордюром
	background-origin: content-box; фон только под содержимым, текстом
	background-size: cover; покрыть все пространство фоном, растягивает
	background-size: 100% 100%; фон подстраивается под
	background: url(img1.png) 0 0 no-repeat, url(img2.png) 0 0 repeat-y; несколько фонов через зпт можно размещать
}
	Внимание! background-size и множественность фонов не работает в старых браузерах
{
	background-attachment: fixed;
	-webkit-background-size: contain; заполняет без обрезки
	     -o-background-size: contain; заполняет без обрезки
	        background-size: contain; заполняет без обрезки
	-webkit-background-size: cover; заполняет все полностью, обрезается
	     -o-background-size: cover; заполняет все полностью, обрезается
	        background-size: cover; заполняет все полностью, обрезается
}
Фоны можно писать через зпт и свойства к ним тоже через зпт соответственно
{
	backgroud-image: lil/ki.jpg, fone/true.png, первый будет спереди
	background-repeat: no-repeat, repeat; повторяться будет только второй фон, он сзади первого получится
	background-position: center, top bottom;
	И другие свойства применяются индивидуально к каждому фону через зпт, сколько угодно штук
}
Написание единого свойства background 
{
	background: *attachment if need* #777 url() center no-repeat;
	background: *attachment if need* url() center no-repeat, url() center top repeat; несколько фонов, тогда без указания цвета пишем также через зпт.
}

********************************
******* Динамический css *******
********************************
LES и SAS
С подключением библиотеки работает
Там можно стили писать вложенные др в др
Находится на lesscss.ru, sass-lang.com

body {
	width: 900px;
	color: #FFF;
	#firm {
		...
		.ds {
			...
		}
	}
	.fr{
		...
	}
}

И там можно использовать переменные
@color:#677;
h1 {
	color: @color;
}
h2 {
	color: @color + #333; пробел между + обязателен!
}

А также примеси, просто названия классов используются как ярлык к свойствам, чтобы их не дублировать
.db {
	color: #FFF;
	border: 1px solid;
	font-family: Arial;
}
#rat {
	.db;
}

Примеси с аргументами, как функции, можно ставить умолчание через двоеточие

.db(@color,@size:1px) {
	color: @color;
	border: @size solid;
	font-family: Arial;
}
#ghgh {
	.db(#455,6px);
}
#rerere {
	.db(red,0px);
}

Внимание! В хроме подключаемый файд .less не работает на локале, в инете будет

Есть и функции, много, описаны на сайте less - 
h1 {
	background: #080808;
	color: darken(@color, 20%); затемнение на 20% указанного цвета
}

********************************
******** Высота, ширина ********
********************************
Внимание! 
Высота, ширина, если указывается в процентах, то он ориентируется тоже на родительский элемент, 100 процентов от чего.
Если у родителя не задано ничего конкретного, то у его родителя - и так до упора
Поэтому желательно задавать html,body{height: 100%;}

********************************
********* Футер снизу *********
********************************
Чтобы сделать прижатый футер к низу, надо задать
Фишка в том, что при большом увеличении на этот футер ничего не залазит

Допустим:
<div id="wrapper">
	<div id="main">
		<div id="all">
			текст
		</div>
	</div>
	<div id="footer"></div>
</div>

html,body, #wrapper, #main{
	height: 100%;
}
#main {
	min-height: 100%;
	margin-bottom: -250px;
}
#all {
	padding-bottom: 250px; фишка, чтобы не наезжал текст на футер при увеличении масштаба
}
#footer {
	height: 250px;
	background: #086;
}

********************************
************ float ************
********************************
Элемент, которому задается float становится блочным
Поэтому излишне писать
{
	display: block;
	float: left;
}
достаточно одного float: left;

Элементы с флоатом никак не влияют на размеры блока, внутри которого они находятся, поэтому он будет как будто пустой, если в нем нет ни одного элемента без флоата
Поэтому создается пустой блочный элемент со свойством clear и тогда контейнер растягивается на все элементы
Вместо этого можно использовать overflow hidden

Но удобнее использовать так называемый clearfix в after к общему контейнеру
.container::after {
	content: ".";
	display: block;
	clear: both;
	height: 0;
} 

Внимание! При float-е не работает коллапс мэрджинов!

Если у дочернего стоит float, а у родительского нет никакой отмены обтекания, то дочерний вылезет из родительского
Допустим:
	<div class="out">
		<div class="left"></div>
	</div>
.out {
	background: #444;
	padding: 20px;
}
.left {
	float: left;
	background: #234;
}
Решается обычно включением пустого элемента с clear:both

Но более крутой способ - 
clear:both задать у after у родителя

	<div class="out">
		<div class="left"></div>
		<div class="clear"></div>
	</div>
.clear {
	clear: both;
}
или:
.out:after {
	content: "";
	display: block;
	clear: both;
}

Внимание! IE не умеет высчитывать правильно проценты в float-ящихся дивах, допустим 2 дива float right и left, шириной по 50%, при уменьшении экрана в IE все съедет. Все из-за одного пикселя, его надо прописать в комментарии в виде отрицательного margin
<!--[if lte IE 7]>
<style type="text/css">
#left {
margin-right: -1px;
}
</style>
<![endif]-->

********************************
******* Верстка колонок *******
********************************
Ровное расположение 3 колонок

Фишка, как расположить 3 колонки, чтобы средняя была всегда по центру, а две остальные - по краям. Боковым задаем float, а центральной - боковые margin размером в ширину боковых.
Внимание! Главная фишка в том, что самый большой див, в которого нет флоатов - должен располагаться в документе последним, а встанет - в центре.

Допустим:
<div class="all">
	<div class="left">left text</div>
	<div class="center">right text</div>
	<div class="right">center text</div>
</div>

.all {
	margin: 0 auto;
	width: 600px;
}
.all .left, .all .right {
	width: 200px;
}
.left {
	float: left;
}
.right {
	float: right;
}
.center {
	margin: 0 200px 0;
}

Если нельзя в html-коде ставить вторым элементом третий, то тогда можно 2 и 3 засунуть в отдельный див, уоторый будет с margin-left = ширине одной колонки, а 1 элемент float:left
И тогда последовательность сохраняется - 1,2,3
3 - можно сделать float right, а 2 - задать margin, опять же


Одинаковая высота у колонок
Задача, чтобы при наполнении колонок они были равной длины, то есть если они залиты цветом, чтобы цвет растягивался, когда наполняется соседняя колонка

Решение 1.
Через полоски фона. Пример см в файлк colomns.html
Фон задается не самим дивам колонкам, а под ними

Решение 2. Метод Тейлора.
Тоже через закрашивание фона родительских элементов колонок

http://matthewjamestaylor.com/blog/equal-height-columns-cross-browser-css-no-hacks

Внимание! Есть онлайн-конструктор колонок
http://xhtml.ru/instr/3col_creator/
Выдает готовый макет вместе с готовыми футерами и хедером даже можно

********************************
***** Всплывашка по центру *****
********************************
Чтобы всплывашка вылетала четко по центру, ей надо задать следующие праметры:
<div id="popup">
	<div id="intro"></div>
</div>

.popup {
	background: #090;
	position: absolute;
	width: 300px;
	height: 300px;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	margin: auto;
}
Внимание! В IE не работает. Нужен комментарий
<!--[if lte IE 7]>
<style type="text/css">
#intro {
	background: #090; как у popup
	width: 300px; как у popup
	height: 300px; как у popup
	position: relative;
	top: -50%;
	left: -50%;
}
#popup {
	background: transparent;
	left: 50%;
	right: 50%;
}
</style>
<![endif]-->

********************************
********** Переменные **********
********************************
Задаются свойством counter-increment, counter-reset

********************************
*********** Таблица ***********
********************************
{
	border-collapse: separate; по умолчанию
	border-collapse: collapse; соединение рамок в единую
	
	Внимание! Старые браузеры не понимают collapse
	border-spacing: 10px 20px; зазоры м/у ячейками
}
Покраска четных или нечетных tr у таблицы без js
tr:nth-of-type(2n) td{
	background: #778;
}

Из списка делаем таблицу:
ul {
	display: table;
	list-style-type: none;
	border-collapse: collapse;
}
li {
	display: table-cell;
	padding: 10px;
	border: 2px solid;
	background: #897;
}

********************************
********** UL-списки **********
********************************
По умолчанию в ul задан padding слева, под которым стоят маркеры.
{
	padding: 0; убирает маркеры, закрывает просто
	list-style-position: inside; сделает маркеры видимыми даже при 0 padding, по умолчанию outside
	list-style-image: url(); задает картинку маркеру
}
Это все можно писать в сокращенном варианте, просто list-style и комбинировать их
{
	list-style: inside;
	list-style: square;
	list-style: inside square;
	
}


********************************
*********** Анимация ***********
********************************
Плавный переход - transition
пишутся сначала свойства, которые будут в итоге, и потом transition задает плавность их наступления

Например, для плавного изменения цвета с полутонами при наведении на объект
{
	transition-property: all; указываем, к какому конкретно элементу будет применен эффект
	transition-duration: .2; указываем продолжительность перехода
	transition-timing-function: ease-in-out; что за анимация конкретно, вид - линейная, быстро-медленно, медленно-быстро и т.д. 
	transition-delay: 1s; задержка перед началом выполнения анимации
}
Все эти свойства можно прописать коротко:
{
	transition: all .2s ease-in-out; в том же порядке все пишется.
}
Можно также указывать несколько эффектов через зпт
Внимание! Нужны префиксы все.

animate
Опять же, везде префиксы!
Сосотоит из двух частей:
1. Делается набор ключевых кадров анимации. Кадры записываются как группа с определенным именем
@keyframes name{
	0% {
		transform: rotate(0deg);
	}
	5%, 20% {}
	100% {
		transform: rotate(0deg);
	}
}
Есть ключевые слова, которые заменяют 0 и 100%, вместо них можно писать - from и to
Одинаковые значения можно писать через зпт
Перед @keyframes нужно допиывать префиксы

2. В свойствах самого объекта прописываются параметры и запуск анимации. И по имени привязывается вышеописанная группа кадров к элементу
.element {
	width: 50px;
	height: 40px;
	...
	animation-name: name;
	animation-duration: 2s; длительность одного цикла анимации
	animation-iteration-count: 3; количество циклов или infinite
	animation-timing-function: linear; анимация становится линейной, равномерной по времени и без остановки. По умочанию ease; Другое значение ease-in - начинается медленно, заканчивается - быстро, ease-out - наоборот, заканчивается медленно, ease-in-out - начало и конец замедляются.
	animation-timing-function: cubic-dezier(0,0,0,0); можно прописывать вручную
	animation-delay: 1s; задержка перед началом анимации
	animation-direction: reverse; в обратную сторону запустить анимацию, alternate, чтобы циклы чередовались - один цикл туда, один цикл - в обратку.
	animation: name 2s linear 1s infitite alternate; совмещеение всего и краткая запись
	animation-play-state: paused; приостанавливает анимацию
}
Для прописывания ускорения-замедления вручную есть специальный сайт http://matthewlein.com/ceaser/
Есть коллекция готовых анимаций Animate.css: http://daneden.me/animate/

Трансформации transform
Внимание! Нужны префиксы для браузеров!
{
	transform: translate(30px) rotate(30deg) scale(); перемещение (по оси х и по оси у) и наклон объекта. scale - изменение масштаба. 
	transform: skewX(30deg); скос по оси Х или Y (skewY);
	transform-origin: 50px 50px; то же, что и rotate, только мы наклоняем не относительно центральной точки (как в ротате), а точка задана любая нами
	transform-origin: top left; можно таким образом задавать
}
Трехмерное трансформирование:
{
	transform: rotateY(30deg); поворот относительно оси Y, можно указать и X, Z
	perspective: 500px; так трехверность эффект будет достигаться
	transform: rotate3d(1,1,1,40deg); вращение с указанными осями
	transform-style:
	backface-vizibility: hidden; скрывает стороны, например, трехмерного куба, которые с той стороны, и он - не прозрачный становится
	
}

********************************
********* Верстка меню *********
********************************
Чтобы меню выравнивалось по ширине и было центрировано (чтобы универсально пункты можно было добавлять и не париться с выравниванием)
Например ul с li
ul {
	padding: 0;
	list-style: none;
	width: 100%; благодаря этому растягивается по ширине все равномерно
	display: table;
	height: 50px;
}
li {
	line-height: 50; для центровки вместо middle указываем значение равное высоте
	display: table-cell;
	text-align: center;
}
li a {
	height: 50px;
	width: 100%; благодаря этому цветом зальет промежутки
	display: inline-block;
}

********************************
************ Формы ************
********************************
Новые виды и атрибуты Input-ов
<input type="color"> - инпут для выбора цвета
Внимание! Нельзя использовать, т.к. в мозилле не работает. Лучше реализовать это плагинами

required - Обязательность заполнения поля
<input type="text" required>
Если не заполнить, то форма не отправится, и выведется сообщение от браузера, что надо заполнить поле
НО! Это не работает в IE, еще минус в том, что стиль всплывашки от браузера никак не поменять, у каждого браузера свой

autofocus - Автофокус
<input type="text" autofocus> - сразу там курсор

pattern - шаблон, регулярное выражение
<input type="text" pattern="\d+">
Если не совпадает, то форма не отправляется и браузер выдает сообщение, опять же, в своем стиле, "Введите данные в указанном формате"

placeholder - типа временное value, исчезает при клике
<input type="text" placeholder="name">
НО! Перекрасить его нельзя, браузеры не понимают, особенно старые

Подсвечивание ошибок и правильного заполнения:
input:invalid {
	background: red;
}
input:valid {
	background: green;
}

Но! Все это не надежно, можно удалить все эти свойства прямо из отладчика браузера, оно все сразу отправится, даже ничего себе сохранять не надо

При фокусе что-то делать:
input:focus {
	border: 1px solid;
}

Убрать обводку от браузера у инпута
input {
	outline: 0;
}

Вообще, outline - хорошая штука, когда надо без подскакиваний окружающего задать border

Различие button-ов
<button></button> - отправляет
<input type="button"> - просто нажимается, для js

********************************
******* Работа с макетом *******
********************************
Вырезка кусочков из макета Photoshop
Вырезать инструментом Slice Tool

Slice select tool - 2 клика для выбора каждого нарезанного куска. Можно задать ему название, если оно не дано

Сохранение сразу всех нарезок
Сохранить для веб -> выбрать формат, сохранить жмем. Далее выбираем формат HTML and Images
Сохраняет файл и папку. В папке images - все нарезанные картинки готовые уже!!!
Кроме того, файл html из этого макета с автоматической версткой (табличной)

Картинки с стандартными  именами из папки удаляем, для этого надо задавать свои имена картинкам

И потом можно в макете снова кликать на них и смотреть название, если забыли при верстке. Это быстрый способ найти

Линейки
Отступы надо смотреть по линейке. сверху видно, какие отступы с краев и размер центрального блока. 
Внимание! Обращаем внимание на все блоки, не выходят ли они за границу
Сразу задаем это wrapper-у, центральному блоку:

Типичная конструкция
<body>
	<div id="wrapper">...</div>
</body>
Где wrapper - центральная часть

#wrapper {
	width: 940px;
	border: 1px solid #000;
}

По линейкам можно смотреть и другие размеры, подогнать под линейку изображение и вычесть из конечного значения начальное.

********************************
********* Треугольники *********
********************************

Например, такой код даст треугольник высотой 100 пикс
.tiangle {
	width: 0;
	height: 0;
	border-bottom: 100px solid transparent;
	border-right: 50px solid transparent;
} 
С этими параметрами можно играться по-всякому

********************************
************* Тени *************
********************************
Можно писать несколько теней через зпт.
{
	-webkit-box-shadow: 0 3px 20px rgb(0,0,0), inset 0 2px 0;
	        box-shadow: 0 3px 20px rgb(0,0,0), inset 0 2px 0;
	box-shadow: 0 3px 20px rgba(0,0,0,.25), inset 0 2px 0 rgba(255,255,255,.4); создает эффект освещения сверху
}
********************************
*********** Спрайты ***********
********************************
Можно их прописывать через ::before
.lol::before {
	content: "";
	position: absolute;
	display: block;
	width: 30px;
	height: 30px;
	background: url();
	background-position: 6px 6px;
}

********************************
********** Градиенты **********
********************************
С помощью градиента можно сделать затемнение углов, если на изображение сделать :after, которому задать полупрозрачный круглый градиент.
.container {
	width: 200px;
	height: 200px;
	background: url(...);
	overflow: hidden;
	position: relative;
}
.container::after {
	content: "";
	width: 200px;
	height: 200px;
	display: block;
	position: absolute;
	top: 0;
	left: 0;
	background: radial-gradient(transparent, rgba(0,0,0,.7));
}
Градиентов мб много, пишутся они все через зпт.

Градиенты мб повторяющимися, для этого специальное свойство repeating
{
	repeating-linear-gradient(-45deg, rgba(0,0,0,.3) 8px, transparent 8px, transparent 12px); такое даст полосатую полупрозрачную текстуру
	repeating-linear-gradient(-45deg, rgba(0,0,0,.3) 8px, transparent 8px, transparent 12px), repeating-linear-gradient(45deg, rgba(0,0,0,.3) 8px, transparent 8px, transparent 12px); даст сеточную текстуру
}
Есть готовые коды подобных красивостей. которые сделаны на CSS. Нужно искать по слову паттерны CSS и куча готовых кодов выйдет, какие там только текстуры не рисуют
Но надо не забывать, что не все браузеры поддерживают это дело и лучше не перебарщивать

********************************
******** media запросы ********
********************************
Нужны для адаптивной верстки
@media only screen and (max-width:950px) {
	.block {
		width: 600px;
		background: #888;
	} 
}
Есть уже прописанные css-сетки для адаптивного дизайна


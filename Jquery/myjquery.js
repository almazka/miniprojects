Когда Ойгукн подключается, то у объекта window появляется объект jQuery. И по сути, когда мы делаем выборку, мы просим у этого объекта jQuery что-то выбрать и применить какое-то действие.

Через консоль можно писать его напрямую, как и js

jQuery("li"); выборка всех li
По аналогии с js, только возвращается не коллекция, а объект jQuery, внутри которого лишки. Не массив, а объект с перечнем html-ных объектов

Сокращенно вместо jQuery пишется $
$("li");

Можно использовать console.log(); изнутри документа, в <script></script>
НО! Тогда загвоздка - если код выборки написать до того, как весь документ построится, то он ничего не вернет.
Поэтому надо, чтобы сперва весь документ загрузился. Используется конструкция
$(document).ready(function() {
	...
});
Если вспомнить js, то это аналог window.onload = foo;
Более короткая запись - 
$(function() {
	...
});

Проверка на наличие объекта возможна только с помощью .length, бесполезняк if-ами проверять, т.к. объект всегда есть, он всегда объект возвращает, даже если р нет, там служебные записи всякие в объекте
if($("p").length>0)

&& и логический, в случае тру слева перекидывается направо, если слева фолс, то не переходит. Как иф
$.isFunction(fn) && fn.call(this);
|| или 
+ присоединение
+= увеличить текущее значение
ry.css('font-size', '+=5'); увеличить текущее значение размера на 5


Разница между HTML и jQuery объектом
HTML-объект вернется как часть коллекции HTML при обычной выборке через js
var divd = document.body.childNodes[3];
Вернется HTML-объект <div>lol</div>

А объектом jQuery он вернется, когда его пропускаем через выборку jQuery
$(.divd);
Вернется jQuery-объект [<div>lol</div>] (скобки квадратные ставит консоль, но это не массив, а объект! По сути, скобки фигурные)

Теоретически, получив jQuery-объект, мы можем к его элементам обратиться через [], по аналогии с выборкой элемента коллекции HTML
НО! Вернется HTML-объект, выдранный из контекста, с ним не будут работать никакие методы jQuery
var lis = $(.divd);
var li = lis[3];
li.html(); выдаст ошибку

С ним как с объектом HTML надо, через методы соответствующие
li.innerHTML; будет работать, вернет содержимое

Можно обратно обернуть этот HTML-объект через выборку, он превратится в jQuery-объект
$(li);
li.html(); будет работать, вернет код

Выборка по DOM элементу можно использовать везде, но пропускать через $(), чтобы возвращался ойгукн объект, или работать с хтмл объектом
var x = $(document.body.children[0]); 
$('li', x); выбрать все li в  контексте этого элемента, будут выбраны все li внутри х
$('p:contains(document.body.name)');

Разные this
Если this не пропустить через $(), то вернется HTML-объект! И работать с ним надо будет как с HTML-объектом
Чтобы this вернул ойгукн объект, упаковываем его в $(this)

$('button').click(function() {
	console.log(this); вернет хтмл элемент <a class="button"></a>
};); 
console.log($(this)); вернет этот же, но ойгукн объект
Часто для удобства конструкцию $(this) засовывают в переменную, чтобы сто раз не писать
var _this = $(this);
console.log(_this);
В переменной будет ойгукн объект
_this.text(); будет работать, вернет содержимое this-a




Выборка по селекторам, все как в css
$(".fru li");
$("#fru li");
$('img[width=123], a[href*=jju]').fadeOut(); выбор нескольких разнотипных
$('img[alt]').fadeOut(); выбор просто по наличию атрибута
$('img[width=200]'); выбрать все картинки с шириной 200px

$('a[href^=http]'); выбрать все ссылки, у которых атрибут хттп начинается с http
$('img[scr$=.jpg]'); выбрать все имг, у которых разрешение заканчивается на .jpg
$('img[src*=moto]'); выбрать все имг, у которых в любом месте стрибута src присутствует moto



Выборка в контексте
Пишется через зпт
var x = $('div');
$('li', x); выборка в контексте другой выборки



Функция обратного вызова
Это функция, вызываемая прям внутри метода.
Имеет два параметра, в первый автоматически кидается индекс текущего элемента выборки, второй параметр - чаще всего значение, возвращаемое методом, в котором находится функция. Но у разных методов по разному

$("form").attr("acion", function(idx, val) {
	return val+"?param=true"
}); добавялет к имеющемуся адресу в атрибуте какой-то текст

$('li').html(function(idx, old) {
	return old + '!!!';
}); функция добавляет li-шкам в код в конце воскл знаки

$('input').each(function(idx, element) {
	console.log(idx, $('element').val, element.value);
}); в idx передастся порядковый номер, а в element - сам каждый элемент. Внимание - в element возвращается не ойгукн объект, а хтмл объект, к хтмл обращаемся просто (element.value), а к ойгукну можно будет достучаться через выборку $('element');




Методы jQuery:
Через тчк можно их применять как к самим конструкциям $(""), так и к переменным, в которые переданны эти выборки
var lis = $("ul li");
lis.css("color");

Метод .width() - ширина
$('img').width(); вернет ширину
Фишка для подсчета координат центра
var winW = $(window).width() / 2 - content.outerWidth() / 2; ширину берем внешнюю, без учета паддингов, чтобы по центру точнее стало, есть и outerHeight
content.css('left', winW); способ выровнять по центру выбранный див

Метод .outerWidth()
Ширина внешняя, без учета паддингов
$('.kok').outerWidth();

Метод height()
$('img').height(); вернет высоту
Фишка для подсчета координат центра
var winW = $(window).height() / 2 - content.outerHeight() / 2; высоту берем внешнюю, без учета паддингов, чтобы по центру точнее стало, есть и outerHeight
content.css('left', winН); способ выровнять по центру выбранный див

Метод .outerHeight()
Высота внешняя, без учета паддингов
$('.kok').outerHeight();


Метод .each() - прохождение по КАЖДОМУ элементу выборки
$('img').each(function(){ 
	if ($(this).width() > 400) {
		$(this).fadeOut(3000);
	}
}); Выбрать все картинки, и для каждого выполнить функцию (проверить ширину и скрыть все картинки, ширина которых больше 400)

Использование с функцией обратного вызова
$('input').each(function(idx, element) {
	// body...
}); в idx передастся порядковый номер, а в element - сам каждый элемент. Внимание - element - не ойгукн объект, а хтмл объект, к нему можно будет достучаться через выборку $('element');

Это был each от элемента выборки

Глобальный метод $.each()
Есть метод each как метод глобального объекта jQuery
Он принимает первым параметром массив или объект, по которому он должен пробежаться
$.each([52,97],function(idx, val) {
	console.log(idx+" "+val);
});
Если работаем с массивом, то в функцию первым параметром кидается индекс, вторым - значение.
Если работаем с объектом, то  в функцию первым параметром кидается ключ, вторым - значение.
var ob = {
	"name":"john",
	"age":25
};
$.each(ob,function(idx, val) {
	console.log(idx+" "+val);
});

Метод .map()
То же самое, что метод each(), но в отличие от него .map() возвращает новый массив
Внимание! В отличие от each(), сначала передается индекс, а вторым - элемент, а там наоборот
$("h3").map(function(idx, val) {...});

Глобальный метод $.map()
Передается сначала элемент, потом индекс, а внутри функции наоборот, в первом параметре значение, а во втором - индекс
$.map(myarr,function(val, idx) {...});

Метод .clone() - клонирование
Аналог .cloneNode
var myClone = $('#drty').clone(); Клонировать элемент и внести его в переменную
$('#foto').after(myClone);Вставить клон элемента после блока с id=foto


Метод .remove() - удаление
var myremoveForm = $('.form').remove(); удалить элемент с классом form и записывание ее в переменную на всякий случай (из переменной ее можно вернуть потом)
Внимание!
В отличие от .remove(), если, например, удалить и вернуть элемент, .detach() сохраняет за вырезанным элементом привязанное к нему событие
Поэтому если удалить remove-ом и вернуть элемент, он событие не сохраняет, а если его вырезать .detach-ем и вернуть, то сохраняет

Метод .detach() - вырезать
$(ul li).first().detach(); вырезать первый li
Внимание!
В отличие от .remove(), если, например, удалить и вернуть элемент, .detach() сохраняет за вырезанным элементом привязанное к нему событие
Поэтому если удалить remove-ом и вернуть элемент, он событие не сохраняет, а если его вырезать .detach-ем и вернуть, то сохраняет

НО! Свежедобавленные элементы тоже не привязаны к событию, как быть? Использовать делегирование события (см.ниже) 

Метод .replaceWidth() - замена
$(ul li).first().replaceWidth("terra"); первый элемент заменить на строку "terra"



Метод .css()
Возвращает либо меняет css свойства
$("ul li").css("color"); вернет значение свойства color для этой выборки "red"
Писать надо полное свойство, не margin, а конкретный - нижний, верхний и т.п.
$("ul li").css("color","green"); задать новое значение
Внимание! Возвращает отрендеренные свойства, то бишь те, которые в браузере принялись в данный момент, а не в css документе
Несколько свойств можно задавать цепочкой
$("ul li").css("color","green").css("bgcolor","orange");

НО! Удобнее в таком случае в качестве параметра в css передать объект:
$('#mail h1').css({
	'color':'red',
	'border':'1px solid #cc0000',
	'font-size':'12px'
});

Метод .addClass()
Если свойств много, удобнее, чтобы не громоздилось в коде, просто присвоить класс, который может быть где-то описан
$('#tyty p').addClass('news'); Применить новый созданный класс news к объекту
$('#tyty p').addClass('news try ttt'); Применить несколько созданных классов к объекту - через пробел

Метод .removeClass()
$('#tyty p').removeClass('new'); Удалить класс у элемента

Метод .toggleClass()
$('#tyty p').toggleClass('news'); Удалить класс news у элемента, если он есть, создать его - если нет

Метод .toggle() - переключатель на появиться/исчезнуть
$('#tyty').toggle(); при клике если оно блок - сделать none, если оно none - сделать блок
.toggle(slow); скорость 600
.toggle(fast); скорость 200

Метод .trigger() - исполнить событие
$('img.logo]').on('click',function() {
$('.button').trigger('click');}); при клике на .logo исполнить событие click по .button, имитировать

Метод .attr()
$('#logo img').attr('height'); вернет значение высоты картинки
$('#logo img').attr('height',50); изменит атрибут высоты на 50
$('#logo img').removeAttr('alt'); удалит атрибут alt у картинки

Использование функции обратного вызова
$("form").attr("acion", function(idx, val) {
	return val+"?param=true"
}); добавили к строке в acion-е продолжение


Метод .animate()
Динамическое изменение свойств
.animate работает со всеми css свойствами, кроме изменения цвета. Фактически css заменить на слово animate и будет то же самое изменение свойств, только плавное
НО! Свойства animate не могут указываться через зпт, они всегда передаются в виде объекта. Это называется объект свойств. В виде еще одного объекта передаются и другие свойства типа duration - это объект настроек
$('#divs').animate({'width':'+=100'}, {'duration':5000,
complete: function(){console.log('stop');}
Внимание! Если передать duration:0, то это все равно, что css вместо animate, резко поставит свойство

$('#div-for-img').animate({'height':'599px'});
Динамическое изменение высоты элемента
Внимание! Записи параметров, которые пишутся обычно через дефис, в Анимэйт надо писать через большую букву.
$('#div-for-img').animate({'paddingTop':'6px'}, 5000); 

.animate() понимает относительные значения и ключевые слова 

+=, -=, *=
$('#divs').animate({'width':'+=100'});

Ключевое слово toggle
Работает с height и opasity
.animate({'height':'toggle'}); height может принимать значение тогл, тогда будет меняться переменно от 0 до актуальной. То же доступно для прозрачности opasity
Оно умное, если даже актуальная - none, будет делать наоборот

Помимо главного параметра - конечной точки css-свойств, можно передавать другие параметры:

Скорость
Через зпт, вторым параметром можно передавать скорость
$('#div-for-img').animate({'paddingTop':'6px'}, 5000);

Продолжительность duration
Можно продолжительность указывать с помощью указания свойства duration
$('#divs').animate({'width':'+=100'}, {'duration':5000});

Характер анимации
Третьим параметром можно передать ключевые слова linear и swing. Это не заметно, но это придание эффекту характера линейного исполнения или резко вначале и медленно в конце
$('#div-for-img').animate({'paddingTop':'6px'}, 5000, "swing");

Функция
Можно передавать функцию с ее описанием или имя функции без скобок, которая где-то описана
$('#div-for-img').animate({'width':'540px'}, 4000,function(){
alert('Готово!');
}); Изменить свойство ширины за 4 секунды и потом вывести сообщение, что готово.

Просчет шагов анимации
Методы complete, step, stop
Функция step вызывается на каждое изменение (кучу раз)
Функция complete вызывается на стопе изменений, на конце (один раз)
$('#divs').animate({'width':'+=100'}, {
	'duration':5000,
	complete: function(){console.log('stop'),
	step: function() {console.log('here');}
	}
});
step: function() {console.log('Текущий размер: ',$(this).css("width"));} прям будет пошагово расписывать изменение ширины 

Очередь исполнения queue (читается кью)
Если пишем два анимейта один за другим, то по умолчанию они будут исполняться по очереди. За очередность отвечает свойство queue. false задает одновременность исполнения, true - по очереди

$('#divs').animate({'width':'+=100'}).animate({'width':'+=5'});
$('#divs').animate({'width':'+=100'}, {'duration':5000, queue: false}).animate({'width':'+=5'});


Метод .siblings() - соседи
$('li').eq(2).siblings(); выбрать всех соседей li на одном уровне, выборка соседей, без учета самого li второго
$(this).attr("disabled":"disabled");
$(this).siblings("button").removeAttr("disabled"); ставим самому элементу disabled, а его соседу - конкретному button-y удаляем disabled

Метод .descendant() - потомок

Метод .parent() - родитель
$('li').parent(); вернет родителя li
$('li').parent(ul); c конкретным указанием родителя

Метод .parents() - предки
$('li').parents(); вернет родителей, предков, вплоть до body, html - всех
$('li').parents("div"); все предки, но только дивы

Метод .closest() - ближайший предок
$('li').closest(); ближайший из предков
$('li').closest("div");  ближайший из предков, но только чтоб див

Метод .andSelf() - подключить self в предыдущую выборку после некоторых действий
$('li').eq(2).siblings().css('color':'green').andSelf().css('background':"white"); выбрать всех соседей li на одном уровне, выборка соседей, без учета самого li второго, их сделать зел, а потом включить в выборку сам li и всем им задать фон белый

Метод .end() - шаг на этаж выше
$obj.siblings('.button').removeAttr('disabled').end().attr('disabled', 'disabled'); после end() происходит выход из контекста на уровень выше и .attr применяется уже к $obj, а не к $obj.siblings('button');


Метод .children() - ребенок
$('ul').children(); вернет всех детей одного уровня
$('ul').children('li'); выбрать дочерних li в ul

Внимание! Чтобы возвращать детей всех уровней, используется метод .find()

Метод .find()
$('ul').find('li'); найти все li в ul на любом уровне вложенности

Метод .eq() - выбор по номеру, читается Иквел (ударение на и)
Внимание! Считает с нуля.
$('ul').children('li').eq(1); выборка первого ребенка li, считает с нуля

Метод .index()
Обратный методу eq, возвращает индекс

Метод .next()
$('ul').children('li').eq(1).next(); следующий по счету от первого ребенка - второй

Метод .prev()
$('ul').children('li').eq(1).prev(); предыдущий ребенок от первого - нулевой

Метод .add() - добавление в выборку, присоединение выборки
var ul = $('ul');
var x = ul.add('div'); включили в ранее произведенную выборку $('ul') выборку div
Внимание! Можно привязать несколько в массиве
$('*').add([document, window]); выборка всего, включая документ и окно

Метод .text() - аналог innerText, теги воспринимает как текст
$('#main-h1').text(); вернет текст из элемента с id="main-h1"
$('#main-h1').text("Труляля"); текст в элементе с id="main-h1" заменяем на "Труляля"
Внимание! Возвращается текстова строка и мы, соответственно, можем пользоваься методами js с ней. Например, .slice()
var txt = $('#main-h1').text();
txt = txt.slice(0, txt.indexOf(" "));

Метод .html() - аналог innerHTML, теги воспринимает как теги
$('#moto').html(); вернет html код элемента с id moto
alert($('#moto').html()); вывести в сообщении код элемента с id moto
$('#moto').html('<h3><a href="#">Honda DN-01 (19000$)</a></h3>'); заменить код внутренностей элемента с id moto на введенный код

Использование функции обратного вызова
$('li').html(function(idx, old) {
	return old + '!!!';
}); функция добавляет li-шкам в код в конце воскл знаки

Метод .is()
$('li').is('.clss'); возвращает тру фолс - имеет ли li стиль clss

Метод .filter()
$('li').filter('.clss'); возвращает все li со стилем clss

Метод .not()
$('img').not('.xy'); выбрать все картинки на странице, КРОМЕ тех, которые имеют класс ху
$('li').not(':has(a.classsy)'); выбрать все li, КРОМЕ тех, внутри которых а с классом classsy

Метод .has()
$('li').has('strong'); выбор li, которые имеют внутри себя тег strong

Метод .on() - событие включить
$('img.logo]').on('click',function() {
	$('.button').click(); 
}); 
эмулируем клик по кнопке .button в то время, когда кликаем по картинке .logo

Метод .off() - снимается событие, выкл
$('img.logo]').on('click',function() {
	$('.button').trigger('click'); 
	$('.button').off('click');
}); та же эмуляция, что выше, после чего снять событие клик

Метод .hide() - скрыть
Скрывает через display="none"
$('#helps').hide();
$('#tyty img').hide(3000); выбрать все картинки внутри дива #tyty и исчезнуть их за 3 сек

Метод .show() - показать
Показывает через display="block"
$('#helps').show();
$('img[src*=.logo.jpg]').show(3000); выбрать все картинки с определенным src и они появляются за 3 секунды

Метод .append() - вставить после
Аналог DOM-овского .appendChild()
$('#img-hy').append('<p>Труляля</p>'); Вставить код внутрь элемента ПОСЛЕ всех дочерних эл-тов ВНУТРЬ элемента
Если передаем написанные теги, срабатывает innerHTML внутри и он нормально воспринимает, ставит элемент
$('#img-hy').append('Труляля'); можно и текст

Метод .appendTo() - аналог .append-а
$("<h2>Hello</h2>").appendTo(".article"); то же самое, только пишем первее то, что вставляем

Метод .prepend() - вставить перед
$('#img-hy').prepend('<p>Труляля</p>'); Вставить код внутрь элемента ПЕРЕД всеми дочерними
Если передаем написанные теги, срабатывает innerHTML внутри и он нормально воспринимает, ставит элемент
$('#img-hy').prepend('Труляля'); можно и текст

Метод .prependTo() - аналог .prepend-а
$("<h2>Hello</h2>").prependTo(".article"); то же самое, только пишем первее то, что вставляем

Метод .before() - вставить до
Аналог DOM-овского .previousSibling
$('#img-hy').before('<p>Труляля</p>'); Вставить код ДО элемента, соседним элементом, не внутри
Если передаем написанные теги, срабатывает innerHTML внутри и он нормально воспринимает, ставит элемент
$('#img-hy').before('Tруляля'); можно и текст

Метод insertBefore() - аналог .before()
$("<h2>Hello</h2>").insertBefore(".article"); то же самое, только пишем первее то, что вставляем

Метод .after() - вставить после
Аналог DOM-овского .nextSibling
$('#img-hy').after('<p>Труляля</p>'); Вставить код ПОСЛЕ элемента, вернет в данном случае #img-hy без вставленного текста, он после, не внутри
Если передаем написанные теги, срабатывает innerHTML внутри и он нормально воспринимает, ставит элемент
$('#img-hy').after('Труляля'); можно и текст

Метод insertAfter() - аналог .after-а
$("<h2>Hello</h2>").insertAfter(".article"); то же самое, только пишем первее то, что вставляем

Внимание! Зеркальные методы типа prependTo (аналоги всяких befor-ов) можно использовать как  аналог createElement с заданием сразу свойств элементу
$("<h2></h2>", {
	text: "Давай!",
	class: "myClass"
}).prependTo(".article");
$("p").eq(0).after(function() {
	return $(this).prev();
});
Можно с этим использовать и функцию

Метод .slideUp() - свернуть
Через уменьшение высоты до 0 и после display: none
$('img[src*=logo]').slideUp(4000); элемент исчезает уходом вверх за 4 сек
$('img[src*=logo]').slideUp(slow);
$('img[src*=logo]').slideUp(fast);

Метод .slideDown() - развернуть
$('img[src*=logo]').slideDown(4000); элемент появляется сверху вниз за 4 сек

Метод .slideToggle()
$('img[src*=logo]').slideToggle(); переключатель на slideUp/slideDown

Метод .fadeIn() - появиться
Работает через opasity и display
$('#gogo img').fadeIn(4000); появление через проявление картинки за 4 сек

Метод .fadeOut() - исчезнуть
$('#gogo img').fadeOut(4000); исчезновение-растворение картинки за 4 сек

Метод .fadeToggle() - переключить
Переключатель на fadeOut/fadeIn
$('#gogo img').fadeToggle();

Внимание! 
Можно обратиться к объекту jquery и узнать, и задать значения по умолчанию
Они хранятся в свойствах. Например, за скорости slow,fast отвечает свойство speeds
Значение по умолчанию там _default

Возвращать и менять через объект fx, который объект главного объекта jQuery
console.log($.fx.speeds); вернет скорости, задаваемые словами fast, slow и значение по умолчанию
$.fx.speeds._default = 2000; Можно установить свое значение по-умолчанию, мы перегрузим параметр без залазинья в саму библиотеку
$.fx.speeds.veryFast = 5000; можно задать свою переменную, которой не было, и использовать это значение

$.fn.myMethod = function() {}; можно задать и метод и потом писать его через тчк
Внимание! Если функция ничего не возвращает, то она выполнится, но вернется undefined
$.fn.myMethod = function() {
	return $(this).animate({"opasity":"toggle"},500);
};
$('.button').on('click', function() {
	$(.divz).myMethod();
});
Без return-а объект не возвращается и после использования мы можем дольше через тчк применять к нему другие методы
Можно в такую функцию передавать параметры. И, можно перегрузить параметр по умолчанию, на примере скорости - через ||
$.fn.myMethod = function(s) {
	return $(this).animate({"opasity":"toggle"},s || 300);
};
$(.divz).myMethod(400);

Можно расширить новоиспеченную функцию, чтобы можно было передавать функцию обратного вызова
$.fn.myMethod = function(s,fn) {
	return $(this).animate({"opasity":"toggle"},s || 300, function() {fn();}
	});
Или написать просто имя функции без обертки и скобок, то же самое - 
$.fn.myMethod = function(s,fn) {
	return $(this).animate({"opasity":"toggle"},s || 300, fn
	);
};
$(.divz).myMethod(400, function() {
		console.log("lolita true")});
Но. Если ожидаемый параметр функция не будет передан, то передастся undefined
В коде ойгукн есть isFunction, он определяет, функция или нет. Это можно использовать, обращаемся к нему через глобальный объект
$.fn.myMethod = function(s,fn) {
	return $(this).animate({"opasity":"toggle"},s || 300, function() {
		$.isFunction(fn) && fn.call(this);
	}
	);
};



Метод .delay() - задержка
$("#box").slideUp().delay(1000).slideUp(); задержка между двумя действиями в 1 сек

Метод grep() - перебирает массив
var myArray = [1,2,3,4,5];
$.grep(myArray, function(val, key) {
	return val>3; // [4,6]
});
В функцию бросаются значенния и ключи.
grep бегает по массиву, принимает ключи и значения, создает массив и туда результат функции, если передать третьим параметром тру, то наоборот будет делать, то бишь val<3

var arr = [{first:'John', last:'Smith'},{first:'Mike', last:'Doe'}];
var res = $.grep(arr, function(val,key) {
	return val.last === 'Smith'; // {first:'John', last:'Smith'}
});
можно использовать и для объектов, вернет объект, в котором присутствует в ячейке last Smith



Псевдоселекторы
НАписание то же самое - можно к выборке вида $(''), а можно к переменной

:has
$('div:has(select)'); выбор дивов, которые СОДЕРЖАТ внутри себя тег select
var lol = $('li');
lol.not(":has(select.x)"); выбор дивов, которые не имеют селектов с классами х

:even - четные
$('#moto-table tr:even'); выбрать все ЧЕТНЫЕ строки таблицы с id=moto-table

:odd - нечетные
$('#moto-table tr:odd'); выбрать все НЕЧЕТНЫЕ строки таблицы с id=moto-table

:first и :first-сhild - первый
$('#forimg img:first'); выбрать ПЕРВУЮ картинку из блока с id=forimg
$('li:first-сhild'); первый из лишек

:last и :last-сhild - последний
$('li:last-сhild'); последний из лишек
$('#forimg img:last'); выбрать ПОСЛЕДНЮЮ картинку из блока с id=forimg

:visible
$('li').is(':visible'); визибл у li стоит или нет
$('div:visible'); выбрать все дивы, у которых visibility не hidden или opasity > 0

:hidden
$('div:hidden'); выбрать все дивы, у которых display none или type=hidden или width и height = 0 или если эти параметры у родителя

:visibility
$('div:visibility'); выбрать все дивы, которые ВИДИМЫЕ

:contains
$('li').is(':contains("первый")'); содержит ли li текст "первый"
$('p:contains("мотоцикл")'); выбрать абзацы, которые СОДЕРЖАТ в себе слово "мотоцикл"

События
.mouseover() - наведение мыши на элемент
.mouseenter - наведение мышки
.mouseout() - увод курсора с элемента
.mouseleave - увод мышки
.click() - клик по элементу
.dblclick() - двойной клик
.mousemove() - движения мышкой
.mousedown() - нажимается мышь, но еще не отпустили
.mouseup() - сам момент отпускания кнопки мыши
.hover() - двойное наведение мышкой
.submit() - событие сабмит происходит при нажатии кнопки сабмит
.focus() - когда щелкнули по строке или эл. фокус, активное
.blur() - уводится фокус с поля
.change() - изменение поля
.reset() - сброс
.keypress() - нажатие кнопки мыши
.keyup() - отпустили кнопку после нажатия
.keydown() - нажали и еще не отпустили

.load() - после загрузки всего происходит это событие
.resize() - изменение размера, когда тянем за стрелки
.scroll() - прокрутка страницы
.scrollTop() - функция задания начала прокрутки, для стрелки вверх
.unload() - выгрузка, уход с данной страницы

С событиями ииспользуются методы
.on() - событие включить
.off() - снимается событие, выкл
.trigger() - вызвать событие

Пространство имен событий
Каждому событию можно задать свое имя условно, через тчк и управлять ими в отдельности
.on('click.foo',...);
.on('click.bar',...);
.trigger('click.foo');
.off('click.foo');
$('#box').on('click',function(){
	$('.button').trigger('click.action'); 
	$('.button').off('click.temp');
}); выключаем не все события click, а конкретный temp, эмулируем при этом click action

.on('click mousup mousover',...); несколько событий пишется через пробел, подчиняются одному и тому же
.on('click.lol mousup.lili mousover',...);

Примеры событий
$('img.logo]').on('click',function() {
	$('.button').click(); 
}); эмулируем клик по кнопке в то время, когда кликаем по картинке .logo

$('img.logo]').on('click',function() {
	$('.button').trigger('click'); 
	$('.button').off('click');
}); та же эмуляция, что выше, после чего снять событие клик

$('img[src^=logo]').click(function(){ При клике выводить сообщение
	alert('Клик по шапке');
});
$('li').on('click', function() {};); можно вместо .click использовать .on('click', ...) - этот способ более универсален

$(window).scroll(function(){ При прокрутке выводить сообщение
	alert('Прокруточка');
});

$(window).on('scroll', function() {
	console.log('here');
});
$(window).scroll(function(){
	if ($(this).scrollTop() > 500) {
		$('.to-top').fadeIn();
	} else {
		$('.to-top').fadeOut();
	}
});
Функция для появления стрелки вверх. Задаем начало прокрутки от 500 px

$content = $('div.lol');

Объект Event
Можно через объект Event напрямую
$(document).on("click",function(e) {
	console.log(e.type);
});
Как только мы указали параметр для функции, в него бросается объект Event и можно с ним работать через его методы.Тут вернет "click"

Методы объекта Event
.type вернет тип текущего события
.which вернет, какая клавиша или кнопка мыши была нажата
.target вернет по какому элементу было произведено событие, хтмл элемент возвращает, оригинал
.currentTarget пузырьковое всплытие событий, текущее
.pageX координаты по Х, где произошло событие
.pageY координаты по У, где произошло событие
.namespace
.timeStamp возвращает временную метку события
.preventDefault() - отмена действия по умолчанию
.stopPropagation(); - отмена баблинга (пузырьков)
$('a').on('click', function(e) {
	e.preventDefault();
}); убираем действие по умолчанию, то бишь переход по ссылке a
$('a').on('click', function(e) {
	e.stopPropagation();
	Останавливаем баблинг
Фишка - сразу все баблинги убрать у всех элементов
$('*').add([document, window]).on("click", function(e) {
	e.stopPropagation();
});

$(document).on('click',function(e){
	console.log(e.type);
});

НО! Что если надо передавать параметры в функцию другие. Тогда передаем их в виде объекта вторым параметром. Они передадутся в объект Event и теперь к ним обращение через его свойство .data

$(document).on('click',{val:'x', param:25},function(e){
	console.log(e.data.param);
});

Также можно задавать свои собственные параметры в html, НО - имена параметров, чтобы валидные были, надо писать через data-
<img ... data-myparam="">
И потом в jquery к новому атрибуту можно обратиться через .data()
var dir = $(this).data("myparam");

Делегирование событий
В случаях если к выборке с уже привязанным событием со стороны добавляются еще элементы, то эти элементы не связаны с событием и оно на них не работает.
$("ul li").on("click",function() {
	console.log($(this).text());
});
$("<li>Дополнительный пункт</li>").appendTo("ul");
У последнего элемента событие "click" не работает.

Просто если ожидается добавления, то переносим кликабельное li вторым параметром в вызов функции и событие будет применяться для новоприсоединенных li
$("ul").on("click","li",function() {
	console.log($(this).text());
});





Внимание! Защита от тех ситуаций, когда у пользователя js отключен вообще. 
Правило такое, то, что должно быть скрыто должно быть скрыто изначально через js, а не в css, чтобы оно было, если js отключен

ОПтимизация кода. Удобно повторяющиеся события и действия засовывать в функции. Например:
	$("table#courses tbody tr").on("mouseenter",  function() {
    $(this).css("background-color", "yellow").children().eq(3).css("font-weight", "bold");
    });
    $("table#courses tbody tr").on("mouseleave",  function() {
    $(this).css("background-color", "").children().eq(3).css("font-weight", "");
    });
Здесь при наведении на строку таблицы она становится желтой, а текст в одной из ячеек становится жирным
    // Оптмизируем это действие в функцию
	function changeTableColor(eType, obj) {
    var bg = "";
    var fw = "";
    if (eType === "mouseenter") {
      bg = "yellow"; fw = "bold";
    }
    obj.css("background", bg).children().eq(3).css("font-weight", fw);
  }
  $("tr").on("mouseenter mouseleave", function(e) {
    changeTableColor(e.type, $(this));
  });











.hover() - объединенные mousover & mouseup
$('#sortable li').hover(function(){ 
	$(this).css({
		'color':'white',
		'background':'#cc0000'
	})}, function(){
	$(this).css({
		'color':'',
		'background':''
	});
}); Две функции пишутся через зпт, это значит, что при наведении одна функция, при уводе - второе








$('.open_modal').hover(function(e){
	var showntext = $(this).attr('showntext');
	$('#helps').text(showntext).css('top', e.pageY + 10).css('left', e.pageX - 100).show();
}, function(){
	$('#helps').hide();
});



}); отмена всплытия пузырька (когда клик относится к родительским, дочерним)






Выборка набора разнотипных элементов

$('#tyty').append('<tr><td>'+ peremennaya + '</td></tr>'); Когда надо и код, и переменную, пишем через +

alert($('textarea').val()); вывела в виде сообщения содержимое текстовой области textarea
$('input').css('border','3px solid #cecece'); ко всем инпутам применила стиль серая рамка 3 пикселя
alert($('input').length); вывести количество инпутов
$(':text').css('background','#ccc'); применили фон к текстовому элементу инпута
alert($(':checked').length);  вывести количество чекнутых любого вида
alert($(':disabled').length);  вывести количество заблокированных инпутов

Выбор эл-тов
$(window); элемент - все окно, пишется без кавычек
$(document); элемент - документ, пишется без кавычек
$('#tyty + p'); выбрать р, который следует сразу за классом id="tyty"
$('#tyty > p'); выбрать дочерние р у объекта с id="tyty"



фильтрация


$('img:not(#div-fort img)'); выбрать все картинки на странице, КРОМЕ тех, которые внутри дива с id=div-fort





Текст, показать, скрыть
var texth1 = $('#main-h1').text(); вводим переменную, в которой текст из элемента с id="main-h1"
alert(texth1); выводим значение введенной переменной в сообщении
var texth1 = $('#main-h1').text(Труляля); вводим переменную, в которой текст из элемента с id="main-h1", причем текст заменяется на "Труляля"
$('img[src*=.logo.jpg]').nide(3000); выбрать все картинки с определенным src и исчезнуть ее за 3 секунды



Ширина и высота
var shirinka = $('#int').width(); задаем переменную для ширины и выводим ее в окне
alert (shirinka);
var shirinka = $('#int').width(130).height(300); изменить ширину и высоту


Изменение прозрачности элемента
$('img[src*=logo]').fadeTo(5000,0.5); элемент должен поменять прозрачность за 5 сек












Количество элементов
$('div').size(); Кол-во дивов на странице вернет
$('div').get(0); возвращает код первого элемента из массива (или не первого)






Вставка по шаблону
Иногда бывает нужно спрятать код скрипта, например, если сного слайдов, переносим их код в массив объектов, который либо в конце документа, либо в отдельном файле js, который мы подключаем
Изначально код html
<ul>
	<li><img src="img/red.jpg" alt=""></li>
	<li><img src="img/green.jpg" alt=""></li>
	<li><img src="img/yellow.jpg" alt=""></li>
	<li><img src="img/blue.jpg" alt=""></li>
</ul>

делаем следующее:
создаем где-нибудь внизу этого html-документа <script>, а котором будет массив объектов (dictionary), каждый объект отвечает за каждую картинку
var aImgs = [
	{src: 'img/red.gif', alt: 'red'},
	{src: 'img/green.gif', alt: 'green'},
	{src: 'img/yellow.gif', alt: 'yellow'},
	{src: 'img/blue.gif', alt: 'blue'}
];

Выше, тоже в <script> пишем шаблон вставки. Скрываем этот шаблон посредством неизвестного браузеру тайпа <script id="myTpl" type="jquery/template"> и внутри пишем шаблон:
<li><img src="{{src}}" alt="{{alt}}"></li>
Используем шаблонизаторы, спец переменные, придуманные нами {{src}} и {{alt}}

Далее, в конце этого же документа, в <script> пишем на ойгукн (на js тоже можно) фишку лепки из этого шаблона тегов html и их вставка
var tpl = $("#myTpl").html();
var text = "";
$.each(aImgs, function(key, val) {
	text += tpl.replace(/{{src}}/ig, val.src).replace(/{{alt}}/ig, val.alt);
});
$("div.view ul").append(text);

Это был велоспед, для подобных целей существуют шаблонизаторы, которые позволяют делать большее. Например handlerbars
сайт handlerbars.js.com
handlerbars - шаблонизатор для ойгукн и js, популярный

Качаем файл handlerbars.js, подключаем его к файлу
Фишка в том, что мы снова создаем нераспознаваемый скрипт:
<script id="myTemplate" type="text/x-handlebars-template">
</script>

внутри скрипта можно написать любой шаблон cо специальными переменными:
{{#each this}}
<li><img src='{{src}}' alt='{{alt}}'></li>
{{/each}}
Ключевое слово each для того, чтобы handlerbars делал присваивание деталей шаблона в цикле, каждому объекту, если мы передаем массив объектов. Если объект один, то без each

Сами li-шки мы размещаем в отдельном файле, там они убраны объектами в массив aImgs, файл подключен к документу

Для вставки пишем
<script>
	var tmp = Handlebars.compile($.trim($('#myTemplate').html()));
	$('div.view').append(tmp(aImgs));
</script>
В tpl будет функция, в нее передаем массив и он возвращает заполненный шаблон, где уже все подставлено


Дополнительная библиотека jquery ui (юай читается) находится на jquery.ui.com, там куча разных фишек

Сама документация ойгукн понятная и с примерами





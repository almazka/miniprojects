<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 5 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">
<html>
<head>
<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">
<title>Open Server</title>
</head>
<body>
    
<?php 
echo 'Hello World'; 
/*<?='Hello, World!'?> - то же самое, но сокращенный вариант echo (работает, если включен short open tag) Тут перед закрытием не надо тчк с зпт */

echo '<h1>Hello, World!</h1>'; /* Идентичный результат, что и:
<h1><?php echo 'Hello World';?></h1>
или echo '<h1>', 'Hello, World!', '</h1>'; */

print 'Hello, World!'; // почти то же, что и echo

$peremen_2; // так пишутся переменные, должна начинаться только либо с буквы, либо с _, но не с цифр, цифры внутри можно. Чувствительна к регистру.

$per = 5; // присваивается переменной значение 5
$sau = 'JOhn'; // присваивается переменной значение строковое (в кавычках писать)
$per = 28; // присваивается переменной значение 28? если до этого ее же используем, то прошлое значение ЗАМЕНЯЕТСЯ
$perper = 2 + 2; // присваивается переменной результат сложения - 4 присвоит
echo $per; // выведет значение переменной per
$pser = $col; // присваивает переменной pser значение переменной col
unset($col); // удаляет переменную

// ТИПЫ ДАННЫХ
boolean // это да/нетошный тип. Имеет значение true - false Эти надписи регистронезависимы.
$lol = true; // присваиваем переменной lol значение true
echo $lol; // если выводить через echo, он выводит когда true - 1, когда false - пустоту

integer // это числовой тип
$orft = 1234; //присвоили переменной десятичное число
$ot = -123; //присвоили переменной отрицательное число
$oret = 0123; //присвоили переменной восьмеричное число
$ogdt = 0x1A; //присвоили переменной шестнадцатеричное число

float // тип с плавающей точкой

// О кавычках - Разница есть между одинарными и двойными
echo "Hello, $col" // в двойных можно писать сочетание с переменными и не надо никаких плюсов писать там
echo "Hello, \n$ctol" // в двойных можно писать знаки табуляции (браузер их не видит, т-ко для кода)        
echo "Hello, \"hellops\" $ctol" // кавычки внутри кавычек отобразятся с слэшами
//в двойных кавычках работают спецсимволы.
спец-символы: 
\n  //новая строка
\r  //возврат строки
\t  //горизонтальная табуляция
\\  //обратная косая черта
\$  //знак доллара
/* \" - двойная кавычка */

 В одинарных ковычках выводится все как есть, не распознаются эти спец-символы и переменные

heredoc // аналог тега pre, когда много надо писать и чтобы не громоздить кучу слешей и кавычек. Выводит не как есть, теги заменяет
/* Конструкция label
<<<label // вместо label любое имя, главное, чтоб после имени не было ничего - даже пробела!
        <p>Меня зовут "лялка"</p>
        <p>Мне $age лет</p>
label; // тут тоже ничего не должно быть после! И до него тоже НЕЛЬЗЯ! */
        
null // тип данных типа ноль. Если переменной нет - то она null, если ей присвоено null, то она null, если она удаленная, то тоже null

echo "He drink some ${beer}s"; // экранирование переменной
echo "He frend some {$beer}s"; // экранирование переменной, чтоб она не смешивалась с текстом и была распознана

$srt = 'Yellow, World!';
$first = $srt{0};// выборка первого символа - Y из строки по его номеру (считает с нуля)
$first = $srt[0]; // то же самое, см выше

чтоб выбрать последний символ, надо высчитать сперва кол-во их
 $len = strlen($srt); // strlen подсчитывает количество символов
 $pos = $len - 1; // принимаем переменную с вычетом одного, т.к. считает с нуля
 $last = $srt{$pos}; 
сокращенно $dlin = $len{strlen($len) - 1}; // сокращенно вычислить последний символ
        
ОПЕРАТОРЫ **********************
+ // сумма
- // разность
* // произведение
/ // частное
% // целочисленный остаток
. // оператор присоединения

$a += $b; // работает со всеми операторами. То же, что и $a = $a + $b. Это часто надо когда надо переменную сложить с другой и результат добавить в эту же переменную

> если используются эти арифметические операторы, то все, с чем они используются приведется к числу
> если использовать со строковыми переменными, то они будут приведены к 0, если в них нет цифр. Или берет эти цифры, те, что в середине не берет

$eru .="World";// точка - оператор присоединения. К переменной eru, в которой уже что-то есть, добавляем слово world

// немного встроенных функций
isset(imya); // сообщает, есть ли такая переменная. True или false дает.
empty(imya); // сообщает true если переменная существует и она пустая. Пустая - это если ей присвоен ноль, строка ноль, значение false или пустота в кавычках
gettype($imya); // возвращает тип переменной. float возвращает словом double
settype($eru, "integer") // конвертирует тип, присваивает тот тип, что в кавычках укажешь, только если совпадает. Числу - integer, он тога отсекает число и убирает буквы из значения этой переменной
$a = '10peas';
echo (integer)$a; // временная конвертация типа, т.е. выводить он будет только число из значения этой переменной
is_null($item) //встроенная функция is_... означающая null true той переменной, имя которой в скобках, можно is_ этот использовать со всеми остальными типами для экономия места

== сравнение
$a == $b // отправляет TRUE если $a равно $b. Тут он тип притягивает за уши
$a === $b // если и по типам совпадает, тогда TRUE
$a != $b // TRUE если $a не равно $b
$a !== $b // TRUE если $a не равно $b и по типу тоже
$a > $b // TRUE если $a больше $b
$a < $b // TRUE если $a меньше $b
$a >= $b // TRUE если $a больше или равно $b
$a <= $b // TRUE если $a меньше или равно $b
   
НЕ ПУТАТЬ = и == !!!!
  
Логческие операторы
$a and $b // дает TRUE если и $a, и $b TRUE
$a or $b // дает TRUE если или $a, или $b TRUE
$a && $b // дает TRUE если и $a, и $b TRUE - но приоритет выше
$a || $b // дает TRUE если или $a, или $b TRUE - но приоритет выше
!$a // дает TRUE если $a не TRUE


        
// Условия **********************
$shop = true;
if($shop){ // переводится как если то, что в скобках - тру, тогда...
echo 'Иду';
} // скобки фигурные ставить если много условий к if более одного, без - если одно
echo 'Не иду';

// TRUE и FALSE в PHP
Рассматривает как FALSE
 целое 0
 0.0
 пусая строка и строка 0
 пустой массив
 установленный null


else - тоже фгурные скобки надо, если несколько
echo ($a==1) ? 'One' : 'Zero'; // сокращенная запись if-else. Пишется сначала действие, потом условие, можно без скобок после знака вопрос то, когда условие true, через двоеточие то, что else 
$b = ($a==1) ? 'One' : 'Zero';

elseif - соединение else и if
в больших цепочках. И в конце пишется else.

// альтернативный синтаксис, когда вместо фигурных скобок после каждого if, else, elseif ставится : а в конце ставится endif.
        if($age>17 && $age<60):
        echo 'Вам еще работать и работать';
        elseif($age>=1 && $age<18):
        echo 'Вам еще рано работать';
        else:
        echo 'Неизвестный возраст';
        endif;
        
// switch для проверки переменных, чтобы не писать 10 if-ов        
$age = 1;
        switch ($age) {
    case 0:
        echo 'Ноль';
                break; // брейк нужен, чтобы выкидываться из счета и заново подставлять
    case 1:
        echo 'Один';
                break;
    case 2:
        echo 'Два';
                break;
    case 3:
        echo 'Три';
        break;

    default: echo 'Много';
        break;
}   
ini_get('имя_директивы') //дает значение деректив любых, как например максимальное количество символов формы у разных хостеров
    
// тип массив - array
$user[] = 'lol'; // массив обозначается квадратными скобками. Они значат - ячейка
$user[] = 'root';
$user[] = '1234';
$user[] = 25;
$user[] = TRUE;

echo count($user); // функция count возвращает числом количество ячеек массива $user

echo $user[0]; // выборка конкретного элемента массива. Нумерует их он от нуля. Первая - нулевая

print_r($user); // функция для просмотра элементов массива

var_dump($user); // функция просмотра всех элементов массива

$user1 = array('lol', 'root', '1234', 25, true); // создали массив, внутри перечислены, идентичен тому массиву, что сверху

$user2 = array(10=>'lol', 'root'); //стрелка означает что мы даем номер-имя ячейке 10. Идентично $user2[10]
    
$user['name'] = 'lol'; // имя ячейки можно задавать словом. Можно имя писать без кавычек, если несколько массивов в двойных кавычках используется. Тогда ей уже число не присваивается. С ними также можно указать краткую версию, см выше. Но не надо без кавычек просто писать, тк без кавычек и знака доллара пишутся у нас константы!

// многомерный массив

$cars['user'] = array (
    'name' => 'Sergey',
    'e-m' => 'fire@lol.lo',
    'tel' => '8908908908',
    'age' => 25 
);
$cars['nouser'] = array (
    'noname' => 'Sergey',
    'noe-m' => 'fire@lol.lo',
    'notel' => '8908908908',
    'noage' => 65
);

// Константы
define('имя константы', значение); // имя констаны принято писать большими буквами ей нельзя присваивать, удалить, ничего сделать
defined ('имя'); // проверка существования константы. Возвращает true и false, false - если константа существует, true - если отсутствует
// Константы регистрозависимы!

define('имя константы', значение,true); // true добавляем, чтобы константа была регистронезависимой. Но это не особо надо делать

// Циклы
// Операторы инкремента и декремента:
++ // Увеличивает значение переменной на 1
-- // Уменьшает значение на 1
+=2 // Увеличивает на 2
-= // уменьшает на 2

++$a // PRE инкремент/декремент, увеличивает $a на единицу и возвращает значение а
--$a // PRE инкремент/декремент, уменьшает $a на единицу и возвращает значение а
$a++ // POST инкремент/декремент, возвращает значение а и увеличивает $a на единицу 
$a-- // POST инкремент/декремент, возвращает значение а и уменьшает $a на единицу

$a = 1
echo 'Вывод числа: '. $a++; // вывод числа 1
echo 'Вывод числа: '. $a; // вывод числа 2
echo 'Вывод числа: '. ++$a; // вывод числа 2
echo 'Вывод числа: '. $a // вывод числа 2
        
// for
for (часть1; часть2; часть3){
    инструкция 1;
    инструкция 2;
    ...
}
часть 1 - там нечто, что он тупо делает. можно несколько значений писать через зпт. часто счетчик
часть 2 - как бы if, когда true - он что-то делает из тела цикла
часть 3 - так же, как и первая, счетчик прибавляется
И он снова возвращается в часть 2, если true, то снова делаем, false - заканчиваем        

for ($i=1; $i<=30; $i++) {
    ...
}

// while
while (условие проверяется на true) {
    инструкция 1;
    инструкция 2;
    ...
}

$r = 1;
while ($r<50){
echo $r . '<br>';
$r+=2;
if ($i == 5)
break; // оператор break для выброса из цикла
}
while ($r<56){
$r+=2;
if ($i == 5)
    continue; // оператор continue для возврата в условие вайла из цикла. Так он там только раз бывает
    echo $r . '<br>';
}
// break и continue выбрасывает только на одном уровне. Если цикл внутри цикла, то его брейк и будет уровня. Поэтому чтобы брейк действовал на следующем уровне тоже - надо писать его с цифрой и континуе тоже break 2, continue 2

do {
    инструкция 1;
    инструкция 2;
} while (условие) // это используется чтоб он сначала выполнил, а потом уже смотрел условие

    //foreach - цикл работы с массивами
    foreach ($cars as $v) { // имя массива и имя переменной, в которую загоняется каждый элемент 
    echo $v.'<br>'; // выведет все ячейки массива в столбик
}
foreach ($array as $key => $value) {
// $key - это ключ ячейки, в него будут записываться ключи
}

// перемещение по массиву шагами
echo current($user); // значение текущей ячейки, что стоит первая, если мы на нее не переходили
echo next($user); // следующая
echo current($user); // теперь ужеследующая будет текущей, если так и писть после некста
echo prev($user); // предыдущая
echo end($user); // последняя
echo reset($user); // первая
echo key($user); // возвращает ключ текушей ячейки

// Функции
function imyaF () {// имя функции регистронезависимо. Действует только по вызову по имени - это объявление функции
echo "<h1>Hello, World!</h1>";
} 
imyaF(); //вызвали функцию, можно много раз вызвать подряд и не подряд, а объявить несколько раз ее нельзя

// есть куча встроенных функций, можно проверить
function_exists($function_name); // возвращает true или false есть ли функция или нет с этим именем

function functionName($param, $n) {
echo "<h$n>Hello, $param!</h$n>"; // в функцию можно передать параметры, тогда при вызове функции надо будет все аргументы указывать - 
} // а чтобы не указывать, можно установить умолчание для аргументов, пишется оно через равно:
function functionName($param, $n=3){ } // теперь даже если вызвать функцию с одним параметром, второй будет по умолчанию и ошибки не возникнет! НО сначала перечисляются обязательные, потом - не обязательные
functionname ('John', 1); // передали параметры

$sttr = 'functionname';// если переменной присвоить имя функции, то можно вызывать по имени переменной
$sttr('Guest', 3);//вызов функции functionname через переменную sttr с передачей параметров

global $ant;
$ant = 'Vasya'// глобальная переменная. Если ее задать внутри функции, то она будет действовать и вне ее тела, а так все переменные внутри функции отдельные, даже если имена у них совпадают с какими-то вне. НО он локальную удаляет и заменяет этой, если она там где-то была 
$GLOBALS['Vasya'] // вот так выглядит любая глобальная переменная,заданная в php, он ее запсывает в свой массив ГЛОБАЛС и ее можно оттуда вызвать без слова global и не перезаписывать другие такого же имени переменные...
        
function trolls(){
static $a = 0; // делаем переменную почти глобальной, после выхода из описания функции php ее запоминает, не забывает. Поэтому при следующем входе в функцию ей уже присвоено какое-то значение
echo $a++;
}
trolls(); // выведет 0
trolls(); // выведет 1
trolls(); // выведет 2

function getSum($n1,$n2) {
return $n1+$n2; // когда функция должна что-то вернуть используется слово return, внимание! return заканчивает функцию, как break, после него уже не исполняется, что бы ни было написано внури функции
}
echo getSum(2,3); // напечатается вернутое значение функции

// Рекурсивная функция - ф-ция. которая вызывает сама себя
function factorial($n)
{
    if($n == 0) return 1;
    return $n * factorial($n-1); // функция внутри функции, пока не наступило 0
}
$resiult = factorial(5)
        echo "5!".$result;

function foo(){
echo func_num_args();// выведет 3 - возвращает количество переданных в функцию данных
$args = func_get_args();
print_r($args); // выведет аргументы как они есть
echo func_get_arg(1); // выведет второй переданный по счету (с нуля) аргумент,в данном случае 35

$a = 10;
$b = &$a; // это типа ярлык на переменную а, b означает а. Ссылка, а не копия

}
foo('a',35,true);

foreach ($array as $val){
    $val = 10; // эта запись улетает в воздух, т.к. за основу берется уже извесная переменная и ей не присвоится, т.к. foreach работает со ссылками (ярлыками)
}
foreach ($array as &$val){
    $val = 10; // тут получается, foreach работает не с ссылками, а наоборот, т.е изменит в итоге массив, перезапишет глобальную переменную
}

print_r(get_defined_functions()); // возвращает список функций, доступных для установленной версии php

// Описане функций есть в документации, в удобном виде. Их очень много

// Часто используемые функции работы с переменными. Возвращают true или false по соответствию указанному типу
is_array($var)
is_bool($var)
is_float($var)
is_integer($var)
is_numeric($var)
is_string($var)
is_null($var)
intval($var [, int $base]) //возвращает целочисленное значение аргумента
floatval($var) //возвращает вещественное значение аргумента
        
// Функции математические

max($values) // возвращает наибольшее число из заданных
acos(arg) // возвращает значение арккосинуса
cos(arg) // возвращает косинус числа в радианах
min(values) // возвращает наименьшее число из заданных
decbin(number) // возвращает двоичное представление целого числа
log(arg) // возвращает натур логарифм значения
pi(oid) // возвращает приблизительное число пи
rad2deg(number) // возвращает в градусах значение аргумента, заданного в радианах
round(val) // возвращает округленное до ближайшего целого числа значение заданное аргументом
sqrt(arg) // извлечение квадратного коорня из числа
rand(oid) // возвращает число, лежащее между двумя необязательными аргумертами включительно

// Функции обработки строк

addslashes(str) // экранирует спецсимволы в строке
stripslashes(str) // реэкранирует спецсимволы в строке
explode(delimiter, string) // разбивает строку на подстроки
htmlentities(string) // преобразует символы в соответствующие html сущности
trim(str) // удаляем пробелы из начала и конца строки
str_replace(search, replace, subject) // заменяет строку поиска на строку замены
strpos(haystack, needle) // возвращает позицию первого вхождения подстроки
strip_tags(str) // удаляет html и php теги из строки
strstr(haystack, needle) // находит первое вхождение подстроки
substr(string, start) // возвращает подстроку
strlen(string) // возвращает длину строки

// Функции работы с массивами

array_pop(array) // извлечь последний элемент массива
array_shift(array) // извлечь первый элемент массива
array_rand(input) // одно или несколько случайных элементов из массива
array_reverse(array) // возвращает массив с элементами в обратном порядке
count(var) // посчитать количество элементов массива или кличество свойств объекта
in_array(needle, haystack) // проверить, присутствует ли в массиве значение
array_key_exists(key, search) // проверить, присуствует ли в массиве ключ
implode(glue, pieces) // объединить элементы массива в строку
        
php.net - там ссылка на документацию

Есть языковые консрукции, а есть функции - не путать! Отличие в том, что яз конструкции никогда ничего не возвращают, например echo. Исключение - языковая конструкция print возвращает 1

// Как читать описание функции в документации
Например int intval(mixed $var [, int $base])

[] означает необязательность параметра и у него есть значение по умолчанию

перед переменными слова означают ожидаемый тип, int - integer, mixed - означает что можно туда передать больше чем один тип, какие - пишется ниже в описании. Перед самой функцией тот тип, который она возвращает - тут int// если туда делать не ожидаемый тип, то php конвертирует в ожидаемое

в списке параметров описано то, что входит в mixed: var - скалярное...
Еще похожие функции пишутся в "СМ также"

Но лучше в мануале сидеть онлайн, там и коменты, и поиск легче...

// Функции работы с датой-временем

$arr = getdate(); // вернет массив с состоянием даты - времени
$arr = getdate(1234567890); // если туда передать дату в этом формате - это формат временная метка, он выдаст расшифровку, когда это было.
echo date("d-m-Y H:i:s"); // выводит дату в введенном формате
echo date("d-m-Y H:i:s", 1234567890); // выведет дату по метке, все буквы и обозначения есть в мануале на функции
time(); // возвращает текущую временную метку
mktime(0,0,0,2,15,1978); // вернет метку времени Unix для этой даты (15 фев 1978)
mktime(0,0,0,1,1,2011); // дата 1 янв 2011
mktime(0,0,0,13,1,2010); // дата 1 янв 2011
mktime(0,0,0,12,32,2010); // дата 1 янв 2011
checkdate(month, day, year) // дает true если эта дата существует или false - если нет

// Псевдофункции пишутся в войных подчеркиваниях - константы
echo __LINE__; // выведет номер строчки, в которой она прописана

echo __FILE__; // вернет полный путь к файлу

function FunctionName()
{
    echo __FUNCTION__; // вернет имя функции, в которой она прописана

}
echo PHP_VERSION; // выведет версию PHP, вообще подобных констант, описывающих PHP, много

************* КАК ВЫВЕСТИ НА ЭКРАН В ВИДЕ КОДА МАССИВ *****
echo '<pre>';
print_r($arrayname);
echo '</pre>';
*************************************
$_SERVER // массив, содержащий инфу о сервере и всем всем с этим связанном, ай-пи всякие, порты, адреса и т.д.

// Как достучаться до этих масивов? Через Глобалс либо по ним самим, если они отдельные:

echo $GLOBALS[_POST]['a']; // то же через глобалс (массив с глобальными переменными)
echo $_POST['a']; // одно и то же, но короче. Напрямую чаще всего, так пишут

echo 'Powered by '.$_SERVER['SERVER_SOFTWARE']; // выведет ячейку массива $SERVER с инфой о конфигурации

************** SSI **************
SSI - это когда мы отправляем несколько кусков, а на сервере они склеиваются воедино. Php это все дело заменяет
Есть функции эмуляции SSI d PHP
include (); include_once();
require (); require_once ();

include 'text.php'; // на это место вставить содержимое файла text.php если ошибка, то будет варнинг, но код продолжает выполняться. Можно сколь угодно этот файл сто раз ставить в разные места
require 'text.php'; // то же, но если есть ошибка, то ошибка будет фатал еррор и код не продолжится
include_once 'text.php'; // для избежания ошибок повторов подключить единожды. Если потом еще раз это написано, то он игнорит, подключает только один раз.


**** Копирайт самообновляющийся и поверед бай для крутости ****
?>
<b>&copy; SuperWebmaster, <?=date(Y)?></b>
<hr>
Powered by <?=&_SERVER['SERVER_SOFTWARE']?>

<?php
**** Как защититься от ошибок **********
Бывает, что при ошибке показывается путь к файлу и это могут взять хакеры и взломать все. Поэтому есть приемы против этого. Сразу смотрим слабые места, где могут быть ошибки в случае, если кто-то случайно поменяет код. Это функции в данном случае.

Функция должна что-то возвращать, чтоб проверить ее на успешность выполнения или неуспешность.
Например, если в переменную пришел не массив, то должно возвращаться false

пишем в функции так:
function FunMenu($usermenu, $vertical=true)
if (!is_array($usermenu)) // если это не массив, то возвращаем ложь
    return false;
$styleHorizont = '';
if (!$vertical) {
    $styleHorizont = ' style="display:inline; margin:15px"';
}
echo '<ul style="list-style-type:none">';
foreach ($usermenu as $key=>$value) {
    echo "<li$styleHorizont><a href='http://lol.ru/$value'>$key</a></li>";
}
echo "</ul>";
return true; // в конце возвращаем тру, если все работает
}
 
А там, где вызов функции, пишем так:
            <?php
            if (!getMenu($leftmenu))
            echo 'Извините, что-то произошло...';
            ?>
вместо простого <?php getMenu($leftmenu);?>

Лучше это упростить и универсализировать - завести под надпись "Извините. что-то произошло" - консанту, константа может содержаться в другом отдельном файле вместе с др. константами.

<?php
******* Функция без функции ***********
Можно инклюдный файл использовать как функцию, для этого никаких имен не надо - в файле пишем условия и внизу что вернуть надо. Подключаем файл и он возвращает результат, как функция

$a = 2; $b = 3;
$c = $a + $b;
return $c; // это пишется в инклюдном файле.

а в другом файле пишем
$res = include 'file.php';
echo $res; // выведет 5

?>

<?php
***************** Куки ***************

*** устанавливаем куки - задаем (отправляем) ***
setcookie ($name // имя куки - обязательный параметр
    , $value, // значение параметра 
    $expire= 0, // истечение срока годности, если надо установить на какое-то время, то бишь например, чтобы браузер не удалял куку неделю. Но если пользователь чистит куки, то исчезнет, конечно
    $path //  опредеяет часть домена. Например при запросе Specialist.ru/docs - надо, а при specialist.ru/contacts - не надо
    , $domain // по домену, например specialist.ru эту куку получит, а sare.ru - не получит.
     , $secure= false // безопасность, если труе, то будет идти через https
     $httponly= false)
setcookie("testcookie", $val); // кука по имени testcookie и посылается какие-то значение
setcookie("test2cookie", $val,time()+3600); // вешаем куку с периодом действия 1 час, даже если браузер закр/откр, она живет
setcookie("test2cookie", $val,time()+3600, "/docs/", " .site.com", 1); // вешаем куку с периодом действия 1 час, которая доступна в папке докс, только /docs ее получит. Доступна всем поддоменам сайта .site.com - new.site.com/docs, lol.site.com/docs например, плюс https исполняется

Важно! Куку надо отправлять до вывода чего-либо. То бишь после echo setcookie не работает, так как вывод уже начался, а выводит браузер заголовки вначале, если после вывода заголовков вывести еще что-то и попросить вывести куку - не выведет, потому что уже заголовки выводил и перебил как бы выводом другого
Внимание ! любые пробелы и все все в html (вне php) - уже считается выводом, а в php только всякие echo, print_r и т.д.

echo "a";
setcookie("name", "lol"); // выведет ошибку, не будет работать. Внутри php всякие echo считаются выводом, вне php любые пробелы - считаются выводом.


Куки записываются в глоб массив
echo $_COOKIE["name", "lool"]; // name - имя, в lool может быть массив

************ сохранить массив *************
$arr1 = array('one' => 1,
                'traa' => 'lol'
                '09' => true); 

echo serialize($arr1); // чтобы сохранить массив куда-то, но чтобы и структура сохранилась, есть serialize. Он хранит в строку, но при этом сохраняет инфу о структуре
$mass = unserialize($arr1); // развернуть обратно сохраненный массив $arr1 в массив $mass

**** удаление куки *****
Чтоб кука быстро удалилась, можно передавать ее пустой, с пустым значением или с отрицательным именем
setcookie("name"); // официально при отсутствии всех остальных данных, только обязательные - имя - кука удаляется при закрытии браузера.
setcookie("name","");
setcookie("name","",time() - 3600);

*** ВНИМАНИЕ! Нельзя редактировать файлы PHP в виндовсовском блокноте, т.к. он заменяет кодировку и делает ее с ВОМ, а значит куки все накроются!
Если кракозябры, то в корне сайта (папке) надо создать файл .htaccess и с помощью любого редактора вписать AddDefaultCharset UTF-8

header("string: значение"); // функция посылания заголовков
header("location: cookie.php"); // заголовок задаем страницу. все остальное браузер записывает уже из названного файла. Перенаправение это. Полный адрес надо писать. Они должны как куки посылаться ДО ВВОДА
header("location: ".$_SERVER["PHP_SELF"]); exit; // Это переход на ту же самую страницу и примочка чтобы после запуска данных формы при обновлении эти данные больше не запускались по сто раз, exit надо ставить
header("Refresh: 1"); // число - кол-во секунд. Перезагрузка каждые определенное количество секунд
header("Refresh: 2;url=http://www.lol.ku") // автоматическое перенаправление через указанное кол-во секунд
header("content-type: text/xml"); // отобразить документ как xml формат, по умолчанию - html
header("content-type: text/html; charset=UTF-8"); // прописывать кодировку важно и нужно! чтоб браузер не гадал и не было кракозябр. Бесплатные хостинги выставляют не utf-8
<meta http-equiv="content-type" content="text/html; charset=UTF-8"> // Заголовок приоритетнее, чем то же самое на мета-тегах, а мета рассматривается только если выше в заголовках не прописывается

// существуют всякие обманные ходы...
header("content-type:file/ostet-stream"); // мы ему говорим считать файл текстовым документом
header("content-disposition:attachment; filename=\"mytext.txt\""); // мы присваиваем другое имя, шифруем файл, так как будто это тхт
header("cache-control: no-store"); // запрет кэширования
header("last-modified: ".gmdate("D, d M Y H:i:s")." GMT"); // дата последнего изменения - нельзя ставить вот так (как советует википедия), это неудачно. А надо вписывать руками сюда дату. Для поисковиков, т.к. они свежак ставят первее
header("cache-control: PUBLIC"); // разрешение на кэширование
header("expires: ".date("r", time()+3600)); // вторая часть разрешения кэширования
header("Set-Cookie: name=John; expires=Wed, 19 Sep 02 14:39:39 GMT"); // задаем куки через заголовки

md5("str"); // функция зашифровки. Расшифровать нельзя, но плюс в том, что он дает постоянный код для каждой комбинации, так можно шифровать и хранить пароли

**** Сессии ******
Это файлы временные на сервере, аналог кук, только в файлах
session_start(); // прописывается на  страницах - кусочках сессии
$_SESSION["user"] = "John"; // по аналогии с куками все записывается в глоб массив Session
echo $_SESSION["user"];
Кука сама отправляется с именем и ид сессии при создании сессии. Временный файл с сериализованным массивом создается в папке темп.
session_id(); // id сессии
session_name(); // имя сессии
session_destroy(); // удалить сессию, но файл остается, он только очищается. Надо физически удалять и плюс удалить куку, которая будет напоминать данные и браузер будет создавать этот файл
Сессии можно поставить время жизни

$lol = explode("|", $massname); // функция для преобразования строки в массив. Выбираем разделитель и все между разделителями будет уложено в ячейки нового массива $lol

****** Работа с файлами ********
file_exists("filename.txt"); // существует ли файл
filesize("filename.txt"); // размер файла
fileatime("filename.txt"); // дата посл обращения к файлу, возвращается временная метка
filemtime("filename.txt"); // дата изменения файла, возвр врем метка
filectime("filename.txt"); // дата создания файла, возвр врем метка
fopen("filename.txt", mode); // открываем файл для чего-либо. mode - пишем режим. "r" - только для чтения, "r+" - для чтения и записи, "w" - для чтения и записи, текущее содержимое файла затирается, текущая позиция ставится в начало, "a" - для записи. Текущая заапись будет добавлена в конце файла, "a+" - для чтения и записи. В конец файла вносится запись, "b" - обрабатывать бинарный файл, для работы с бинарными файлами windows
$f = fopen("text.txt", "w+") or die("Ошиба"); // в переменную F в данном случае возвращается ресурс - указатель на файл. Тип данных - ресурс. там типа ссылка
fclose($f); // после открывания файла его надо закрывать!
fread("$f", 5); // читать первые 5 букв файла ресурса $f
fread("$f", filesize("text.txt")); // зачитать весь файл
fgets($f); // считывает построчно. вернет первую строку. Передаем $f - ресурс, дискриптор файла. Если друг за другом, то он первую сначала, потом вторую строку зачитывает, третью и т.д.
fgetss($f,255, "<br><a>"); // если файл с тегами, то зачитывать он гео будет игнорируя теги, параметр длина строки добавляется. Третьим параметром можно указать теги, которые хотим сохранить, если их несколько, то просто в строчку их пишем, без разделения
fgetc($f); // побуквенно: вернет первую букву ресурса. Если писать последовательно несколько раз, то вернет следующие буквы.
fwrite($f, string, 67); // пишем в файл. Задается дискриптор (ресурс), строка, что пишем,  и третий параметр необязателен, ограничение длины. Пишет прямо поверх, как insert.
fseek(handle, offset); // установка курсора в определенное место файла. offset - кол-во символов, на которое надо передвинуться. Можно отрицательное число -тогда движение справа налево. Третьим параметром можно задать константы:
SEEK_SET // движение начинается с начала файла
SEEK_CUR // движение идет от текущей позиции (по умолчанию)
SEEK_END // движение от конца файла
fseek($f, -10, SEEK_END);
$s = fread($f, 10) // зачитать последние 10 символов файла $f
$pos = ftell($f); // узнать текущую позицию курсора
rewind($f); // сброс курсора, перемещение его в начало
feof($f); // возвращает true или false - дошли ли мы до конца файла или нет
file("data.txt"); // получим масссив, где файл построчно в массиве, в каждой ячейке своя строка
file_get_contents($f); // файл возвращается в виде одной большой строки
file_put_contents("data.txt", "\nzapiskadata", FILE_APPEND); // запись. data - что пишем. Внимание! Затирает то, что было! Если мы добавляем, а не заново пишем, то последним параметром передаем константу FILE_APPEND
Внимание! Если файла не существует, то php будет пытаться его создать, если используются file_put_contents, file_get_contents. Но выдаст ошибку, если file(filename)
copy(source, dest); // копирование файла
rename(oldname, newname); // переименование
unlink(filename); // удаление файла
rename("folder1/test.txt", "folder2/text.txt"); // перемещение файла путем его переименования

if ($_SERVER["REQUEST_METHOD"]=="POST") { // проверка того, что форма была отправлена, проверка отправки формы
    ---
}

strip_tags(str); // удаление всех php и html тегов из заданной строки
$_POST["fname"]; // это мы выбираем что прислал input с именем name="fname", который отправлялся методом post
trim(strip_tags($_POST["fname"])); // очищаем от всяких пробелов и тегов то, что было введено в поле name="fname" формы с методом post

**** Директории (папки) ****
mkdir("pathname"); // создать директорию
rmdir("dirname"); // удадение директории. Внимание! Директория удаляется только когда она пустая!!! Чистить надо перед удалением
$dir = opendir("path"); // заходим в директорию. Возвращает название, ресурс, ссылку, дискриптор, как в файлах
$name = readdir($dir); // возвращает имя файла или папки, которое внутри $dir, причем возвращает без расширения и фиг пойми, что это - папка там или файл. Для этого используем is_dir, is_file
is_file("filename"); // по аналогии с is_array
is_dir("filename");
closedir(); // закрытие директории, как с файлом после работы
$d = opendir("."); // открыть ТЕКУЩУЮ директорию. Точка означает текущую
closedir($d); // мы ее закрываем
scandir("directory", 1); // аналог file() - возвращает все содержимое папки в массив. Если второй параметр - 1, то массив будет построен в обратном порядке
function dirs($dir, $tab) // функция для вывода дерева папок
{
    $d = opendir($dir);
    while ($name = readdir($d)) {
        if ($name=="." or $name=="..") { // обязательно с точками папки убирать
            continue;
        }
        if (is_dir($name)) {
            echo "<b>".$tab."[$name]</b><br>";
            $tab .= '-';
            dirs($dir."/$name",$tab);
        }else
        echo "$tab$name<br>";
            }
closedir($d);
}
dirs(".", "");

**** загрузка папок на сервер *****
Для этого надо настраивать php.ini
file_uploads // должен стоять on
upload_tmp_dir // временная папка на машине для загрузок, адрес прописать можно. Туда все файлы попадают после нажатия кнопки загрузить. Вся инфа про них попадает в массив $_FILES
upload_max_size // максимальный размер загрузки файлов

**** возможность загружать файл через форму строка "обзор"******
?>
<form action="files.php" method="POST" enctype="multipart/form-data"> // Внимание! обязательно должен быть такой параметр у enctype, иначе придет не файл, а его имя.
<input type="file" name="uf">
<input type="submit">
</form>
по умолчанию минимальный размер файла 2 мб, если хотим уменьшить, то после form создается
<input type="hidden" name="MAX_FILE_SIZE" value="51200"> // например, для аватарок, но не очень надежно, лучше на сервере проверить через $_FILES["lol"]["size"];
<?php
$_FILES["userfiles"]['name'] // userfiles - имя инпута с type="file", с кнопкой обзор, через который грузили файл, name - имя файла
$_FILES["userfiles"]['tmp_name'] // временное имя, физ путь к нему
$_FILES["userfiles"]['size'] // размер, через него можно проверить размер и не пустить
$_FILES["userfiles"]['type'] // тип файла
$_FILES["userfiles"]['error'] // тру или фолс, нормальный ли файл, целый и т.д.
move_uploaded_file("filename", "destination"); // filename - путь файла, где он лежит и имя, destination - куда сохраняем его
if ($_FILES['uf']['error']==0) {
    $t = $_FILES['uf']['tmp_name'];
    $n = $_FILES['uf']['name'];
    move_uploaded_file($t, "upload/".$n);
}
*********** отправка почты **********
снова php.ini
[mail function]
; for win32 only.
SMTP = localhost // надо указать имя SMTP-сервера
; for win32 only
sendmail_from = mail@localhost.com // адрес, по умолчанию "от кого"

mail("frog@lol.ru", "Тема письма", "Я к вам пишу\nЧего же боле...\nМне голос был"); // функция для отправки, возвращает true или false - передалось письмо или не передалось почтовику
mail("frog@lol.ru", "Тема", $message, "From: webmaster@$_SERVER_NAME\r\n"."Reply-To: webmaster@$_SERVER_NAME\r\n"."X-Mailer: PHP/" . phpversion()); // это мы добавили дополнтельные заголовки
// еще заголовки: мы загоняем их для удобства в одну переменную, и задать ее четвертым параметром в mail
$headers = "MIME-Version: 1.0\r\n";
$headers .= "content-type: text/html charset=iso-8859-1\r\n";
$headers .= "From: Birthday Reminder <birthday@example.com>\r\n";
$headers .= "Cc: birthdayarchive@example.com\r\n"; // копия
$headers .= "Bcc: birthdaycheck@example.com\r\n"; // скрытая копия

**** Базы данных *****
в ячейке таблицы бд должно быть только одно значение!
*********** ЗАПРОСЫ SQL **********
SELECT // регистронезависимое и пробелонезависимое, но для удобства надо писать заглавными и разделять.
SELECT name // это минимальный запрос. Дай мне все записи из поля "name" таблицы "teachers"
FROM teachers

SELECT name, addr, city // это минимальный запрос. Дай мне все записи из поля "name" таблицы "teachers"
FROM teachers ORDER BY name desc // сортировка по имени, если есть desc - то значит в обратном порядке, name - что сортируем

SELECT title // Выбор всего из колонки тайтл таблицы корсес, только те, в которых длина больше 30
FROM courses
WHERE lenght > 30 // оператор "где".

SELECT * // Выбор всех полей из колонки тайтл таблицы корсес, только те, в которых длина больше 30. * лучше не использовать.
FROM courses
WHERE lenght > 30 // оператор "где".
AND title LIKE 'Web%' // можно использовать разные операторы, всчкие or, and. LIKE - это значит вместо % все что угодно
****** Объединение таблиц ****
SELECT t.name, t.code, l.course
FROM teachers t //Перевод - "Что объединяем" для ускорения можно сокращать. Сокращение работает только в текущем запросе.  сокращение имен таблиц записывается в FROM - имя полное и через пробел сокращенное. И тогда он понимает, что t.name означает выборку ячейки name в таблице с названием teachers
INNER JOIN lessons l ON t.id = l.tid //INNER JOIN - внешнее объединение. Перевод - "с чем объединяем и по какому правилу" здесь тоже указание псевдонима lessons - l.
DESCRIBE msms; // запрос инфы о столбцах таблицы msms внутри созданной БД

В ответ этому запросу приходит таблица объединенная. Она строится из полей, которые "бьют"
LEFT OUTER JOIN lessons l ON t.id = l.tid // тоже объединение, но включаются и поля, которые не "бьют". Колонка без соответствия заполняется NULL-ом
SELECT DISTINCT lenght // выбирает единичные упоминания значений в указанном столбце lenght оператор, игнорирует совпадения, берет только уникальные

INSERT INTO courses // INSERT - оператор на вставку новой записи. courses - имя таблицы, 
VALUES (NULL, 'Java2', "...",40) // в скобках значения, которые вставляются в эту таблицу. Первое значение пойдет в первую колонку, второе - вторую и т.д. Внимание! Строковые данные в SQL заключаютс в оДИНАРНЫЕ каввычки!
INSERT INTO courses (title, lenght) // вставка в определенные колонки - они указываются в скобках и вставляется инфа соответственно и через пробел пишем
VALUES ('Java2', 40)

DELETE FROM lessons //удалить запись указанную или все, если не указано условия
WHERE lessons.date = '2005-06-11'

UPDATE teachers // изменение на уже существующую запись
Set
zarplata = zarplata * 2,
premia = premia * 10
WHERE name LIKE 'Иванов%' // WHERE - условие, которое обязательно, иначе просто все обновятся, а не те, что надо
OR name LIKE 'Петров%'
OR name LIKE 'Сидоров%'

UPDATE teachers
Set
zarplata = zarplata * 2,
premia = premia * 10
WHERE name IN
('Иванов', 'Петров', 'Сидоров') // то же, что и выше, только списком через IN
?>
SET NAMES 'cp866'; // установка кодировки для отображение русс букв

<?php
$lolDB = mysql_connect("localhost","root","rafikider"); // подключаемся к серверу mysql. Передаем сервер, логин, пароль, в переменную идет типа ссылка, линк на бд, удобно, если 2 соединения и более. По умолчанию у mysql пожизняк логин root и пустой пароль, можно менять
mysql_select_db("database_name") or die(mysql_error()); // выбор бд, аналог use в mysql. И сразу если ошибка в БД, чтоб выводил, а так не выведет
mysql_errno(); // возвращает номар ошибки
mysql_error(); // возвращает описание ошибки
mysql_query("query"); // посылание запроса, что надо делать, например delete
mysql_query("SET NAMES 'cp1251'") or die(mysql_error()); // установка кодировки
$result = mysql_query("SELECT * FROM teachers"); // результат запроса mysql передаем в переменную
$sql = "SELECT * FROM teachers"; // лучше всего запрос писать в отдельную переменную, чтоб избежать ошибок, в случае ошибки легко можно будет вывести с помощью echo
$result = mysql_query($sql);
mysql_close(); // закрывает соединение с БД, не обязательный, но лучше закрывать
mysql_close([$lolDB]); // можно так

********* алгоритм ***********
// Сначала подумать, сколько раз нам надо будет подключаться к базе, если 1, то коннект и селект пишем отдельно вверху, где константы
mysql_connect(); // устанавливаем соединение с бд
mysql_select_db("database_name"); // выбираем бд для работы
mysql_query(query); // посылаем запросы
mysql_query("SET NAMES 'utf8'"); // кодировка чтоб норм
mysql_close(); // закрываем соединение

******************************
$conn = mysql_connect("host","login","pass"); // лучше записывать в переменную.
mysql_close([$conn]); // и закрывать потом вот так
mysql_fetch_array($result,MYSQL_ASSOC); // возврашает массив из бд, но он удвоенный, если не указать MYSQL_ASSOC и ассоциативный, если указать. MYSQL_NUM - нумерованный массив, MYSQL_BOTH - сдвоенный
mysql_fetch_assoc(result); // аналог ассоциативный
mysql_fetch_row(result); // аналог нумерованный
while ($row = mysql_fetch_assoc($result)) {
    echo $row[name]."<br>";
 } // вывод данных таблицы, массива в столбик через вайл
mysql_result($result, 5, field); //точечная выборка
mysql_num_rows(result); // подсчитать количество записей
mysql_num_fields(result); // подсчитать количество полей
mysql_field_name(result, field_offset); // имя поля
mysql_affected_rows([$coll]); // количество изменений, до закрытия соединения пишется
mysql_insert_id([$conn]); // ид последней записи, работает только при автоинкременте

if (!empty($_POST['name']) and !empty($_POST['email'])) { // проверка заполненности формы
    ...
}
?>
<a href='gbook.php?del=<?=$user["id"]?>'>Delete</a> <?php // это мы отправляем в массив Get ячейку del, которая содержит определенный id
if (isset(["del"])) { // проверяем, если существует дел в массиве Get, то ...
  $id = ClearData($_GET["del"],"i"); // выполняем действие с определенным id
}
*************** MYSQLi ****************
$conn = mysqli_connect('host', 'root', 'rafikider', 'news'); // у MySQLi, в отличие от Mysql при соединении сразу обязательно последним параметром прописывать имя БД, с которой соединяешься, там нет select_bd
$result = mysqli_query($conn, 'SELECT * FROM articles'); // у MySQLi, в отличие от Mysql при запросе обязательно первым параметром указывать переменную соединения.
mysqli_close($conn); // закрытие

*** MySQl View ***
// это типа призрачной таблицы, ярлык
CREATE TABLE t // создали таблицу t, где две колонки - gty числовое и price числовое
(gty int, price int);
CREATE VIEW v AS // создаем призрачную таблицу v как
SELECT gty,price,gty*price AS value FROM t // выбранные из таблицы t столбцы и плюс добавляем столбец с их произведением (в таблице t его нет)
SELECT * FROM v; // вызов этой таблицы-ярлыка будет по имени v
get_magic_quotes_gpc // принудительное экранирование в php, желательно этот параметр ставить off, для этого в файле htaсcess пишем строку php_flag get_magic_quotes_gpc off
?>
****************************************************************************************
****************************************************************************************



</body>
</html>


